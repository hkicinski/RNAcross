---
title: "Gene-Plot-Shiny-beta-4sps-ortho1-7"
author: "Hubert Kicinski"
date: "`r Sys.Date()`"
output: 
  html_notebook:
    toc: false
    toc_float: false
    code_folding: hide
    css: styles.css
runtime: shiny
resource_files:
  - ../www/rnacross-prominent-rna-logo-interactive.svg
---

<style type="text/css">
.main-container {
  max-width: 100% !important;
  margin-left: auto;
  margin-right: auto;
}

.container-fluid {
  padding-left: 0;
  padding-right: 0;
}

.row {
  margin-left: 0;
  margin-right: 0;
}

.col-sm-12 {
  padding-left: 0;
  padding-right: 0;
}

/* Hide YAML header elements */
.header-section {
  display: none !important;
}

.navbar {
  display: none !important;
}

.title {
  display: none !important;
}

.author {
  display: none !important;
}

.date {
  display: none !important;
}

h1.title {
  display: none !important;
}

h4.author {
  display: none !important;
}

h4.date {
  display: none !important;
}
body {
  margin: 0;
  padding: 0;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.main-container {
  max-width: 100% !important;
  margin: 0 !important;
  padding: 0 !important;
  flex: 1 0 auto;
}

.container-fluid {
  margin: 0 !important;
  padding: 0 !important;
}

/* Header specific adjustments */
.d-flex.justify-content-between.align-items-center {
  margin-top: 0 !important;
  padding-top: 0 !important;
}

/* transformation selector styling */
#global_transform {
  margin-bottom: 0;
}

#global_transform .radio {
  margin-bottom: 0;
  margin-right: 10px;
}

#global_transform label {
  color: white;
  font-size: 0.85em;
  margin-bottom: 0;
}

#global_transform input[type='radio'] {
  margin-right: 3px;
}

#global_transform .radio-inline {
  margin-right: 12px;
}

.wrapper {
  margin-top: 0 !important;
  padding-top: 0 !important;
}

/* Ensure the background color extends fully */
.bg-primary {
  margin: 0 !important;
  padding: 1rem !important;
  width: 100% !important;
}

/* Remove any potential html/body spacing */
html, body {
  margin: 0;
  padding: 0;
  overflow-x: hidden;
}

/* Fix container overflow issues */
.container-fluid {
  overflow-x: hidden !important;
  overflow-y: visible !important;
  max-width: 100% !important;
  padding-right: 0 !important;
  padding-left: 0 !important;
}

/* Control plot container dimensions */
.shiny-plot-output {
  max-width: 100% !important;
  height: auto !important;
  overflow: visible !important;
}

/* Prevent scroll bars */
.plotly {
  max-width: 100% !important;
  overflow: hidden !important;
}

/* Ensure the sidebar doesn't cause overflow */
.col-sm-4, .col-md-3 {
  padding-right: 10px !important;
}

/* Fix for custom groups container */
#gene_group_plot {
  width: 100% !important;
  overflow: hidden !important;
}

/* Fix for tab content */
.tab-content {
  width: 100% !important;
  padding: 0 !important;
  margin: 0 !important;
}

/* Prevent horizontal overflow in all divs */
div {
  max-width: 100% !important;
}

/* Custom styles for orthogroup selection */
.orthogroup-selection {
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 10px;
  margin-top: 10px;
}

.orthogroup-species {
  margin-bottom: 15px;
}

.orthogroup-species h5 {
  margin-bottom: 10px;
  font-weight: bold;
}

.gene-checkbox {
  margin-left: 20px;
  margin-bottom: 5px;
}

.orthogroup-info {
  background-color: #f8f9fa;
  padding: 10px;
  border-radius: 4px;
  margin-bottom: 10px;
}

[data-bs-theme='dark'] .orthogroup-info {
  background-color: #2c3034;
}

[data-bs-theme='dark'] .orthogroup-selection {
  border-color: #444;
}

/* Enhanced orthogroup selection styles */
.paralog-selection {
  background-color: #f8f9fa;
  border: 2px solid #dee2e6;
  border-radius: 5px;
  padding: 15px;
  margin: 10px 0;
}

.paralog-selection.selected {
  border-color: #007bff;
  background-color: #e7f3ff;
}

[data-bs-theme='dark'] .paralog-selection {
  background-color: #2c3034;
  border-color: #444;
}

[data-bs-theme='dark'] .paralog-selection.selected {
  border-color: #375a7f;
  background-color: #2a3f5f;
}

.paralog-header {
  font-weight: bold;
  color: #495057;
  margin-bottom: 10px;
}

[data-bs-theme='dark'] .paralog-header {
  color: #adb5bd;
}

.single-gene-notice {
  font-style: italic;
  color: #6c757d;
}

.paralog-notice {
  background-color: #fff3cd;
  border: 1px solid #ffeaa7;
  border-radius: 4px;
  padding: 10px;
  margin-bottom: 10px;
}

[data-bs-theme='dark'] .paralog-notice {
  background-color: #664d03;
  border-color: #997404;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r load_libraries, echo=FALSE}
#set cran here 
r <- getOption("repos")
r["CRAN"] <- "https://cloud.r-project.org"
options(repos = r)

#set to TRUE for debugging
DEBUG_MODE <- FALSE

#conditional debug print
debug_print <- function(...) {
  if (DEBUG_MODE) {
    message(paste0("[DEBUG] ", ...))
  }
}

debug_cat <- function(...) {
  if (DEBUG_MODE) {
    cat(...)
  }
}

#performance cache for data source changes
.performance_cache <- new.env(hash = TRUE)

clear_performance_cache <- function() {
  rm(list = ls(envir = .performance_cache), envir = .performance_cache)
}

#load the dependencies 
suppressMessages({
  # Core libraries
  library(tidyverse)
  library(data.table)
  library(cowplot)
  library(tidyr)
  
  # Shiny-related
  library(shiny)
  library(bslib)
  library(waiter)
  library(shinyjs)
  library(plotly)
  library(DT)
  library(fontawesome)
  library(shinyBS)
  library(viridis)
  library(ggridges)
  library(ggtree)
  library(ape)
  library(treeio)
  library(RColorBrewer)
  library(here)
})

# Load the new RData file with HOG-based orthogroups
load(file.path("..", "data", "RData_perSpecies_HOG_clean_11182025_rlog.RData"))

#preprocess gene lookup table at startup
if (!is.null(all_species_data$gene_lookup)) {
  if (!is.data.table(all_species_data$gene_lookup)) {
    all_species_data$gene_lookup <- as.data.table(all_species_data$gene_lookup)
  }
  
  #precompute uppercase for faster case-insensitive matching
  all_species_data$gene_lookup[, gene_id_upper := toupper(gene_id)]
  all_species_data$gene_lookup[, gene_name_upper := toupper(gene_name)]
  
  #create indices on actual query columns
  setindex(all_species_data$gene_lookup, gene_id_upper)
  setindex(all_species_data$gene_lookup, gene_name_upper)
  setindex(all_species_data$gene_lookup, hog_id)
  setindex(all_species_data$gene_lookup, species)
  setindex(all_species_data$gene_lookup, gene_id)
}
```

```{r theme_and_constants, echo=FALSE}
# Constants
TIME_POINTS <- c("0min", "15min", "30min", "45min", "1h", "1.5h", "2h", "2.5h", "3h", "3.5h", "4h", "6h", "8h")

#default species for demo data - will be overridden by user uploads
DEFAULT_SPECIES_CONFIG <- list(
  cg = list(name = "Candida glabrata", short = "C. glabrata"),
  sc = list(name = "Saccharomyces cerevisiae", short = "S. cerevisiae"),
  kl = list(name = "Kluyveromyces lactis", short = "K. lactis"),
  ca = list(name = "Candida albicans", short = "C. albicans")
)

# Keep SPECIES_CONFIG for backward compatibility 
SPECIES_CONFIG <- DEFAULT_SPECIES_CONFIG

# Default colors - will be extended dynamically for new species
DEFAULT_SPECIES_COLORS <- list(
  "C. glabrata" = "red",    
  "S. cerevisiae" = "blue",  
  "K. lactis" = "#f8c434",      
  "C. albicans" = "#74ac4c"     
)

SPECIES_COLORS <- DEFAULT_SPECIES_COLORS

# Additional colors for dynamic species assignment
DYNAMIC_COLOR_PALETTE <- c("#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", 
                          "#FFEAA7", "#DDA0DD", "#98D8C8", "#F7DC6F",
                          "#BB8FCE", "#85C1E2", "#F8B739", "#52BE80")

# theme configs
light_theme <- bs_theme(
  version = 5,
  bootswatch = "flatly",
  primary = "#2C3E50",
  secondary = "#95a5a6",
  success = "#18bc9c",
  info = "#3498db",
  warning = "#f39c12",
  danger = "#e74c3c",
  bg = "#ffffff",
  fg = "#333333"
)

dark_theme <- bs_theme(
  version = 5,
  bootswatch = "darkly",
  primary = "#375a7f",
  secondary = "#444444",
  success = "#00bc8c",
  info = "#3498db",
  warning = "#f39c12",
  danger = "#e74c3c",
  bg = "#222222",
  fg = "#ffffff"
)

# sets a loading screen
loading_screen <- tagList(
  spin_flower(),
  h3("Processing data...", style = "color: #2C3E50; margin-top: 15px;")
)

# custom CSS
custom_css <- tags$style(HTML("
  /* Base styles */
  .nav-tabs .nav-link.active {
    background-color: var(--bs-primary) !important;
    color: white !important;
    border-color: var(--bs-primary) !important;
  }
  
  .sidebar-panel {
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  }
  
  .results-panel {
    border-radius: 8px;
    padding: 20px;
    padding-bottom: 100px; 
    margin-bottofm: 15px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    overflow: visible;
  }
    /* Make the main flex container */
  .bslib-page-navbar {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0; 
  }
  .custom-button {
    width: 100%;
    padding: 10px;
    margin-top: 10px;
    background-color: var(--bs-primary);
    border: none;
    color: white;
    border-radius: 4px;
    transition: all 0.3s ease;
  }
  
  .custom-button:hover {
    background-color: #34495E;
    transform: translateY(-2px);
  }
  
  .gene-info {
    padding: 15px;
    border-radius: 4px;
    margin-top: 15px;
    font-family: monospace;
  }
  
    html {
    height: 100%;
    overflow-y: scroll;  
  }
  
  body {
    min-height: 100%;
    margin-bottom: 0 !important;
    padding-bottom: 0 !important;
  }
  
  /* Adjust the main container to fill space */
  .bslib-page-navbar {
    min-height: 100vh;
    margin-bottom: 0 !important;
  }
  
  .footer {
    background-color: var(--bs-primary);
    color: white;
    padding: 20px 0;
    width: 100%;
    flex-shrink: 0;
    margin-top: auto;
    position: fixed;
    bottom: -1px;
    left: 0;
    z-index: 100;
  }

/* Ensure page structure supports footer positioning */
  .bslib-page-navbar {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    padding-bottom: 80px; /* Add space for fixed footer */
  }

  /* Make main content flexible */
  .main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
  }
  
  /* Ensure tab content takes available space */
  .tab-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding-bottom: 100px !important; 
  }
  
  .tab-pane {
    flex: 1;
    padding-bottom: 100px !important; 
    min-height: calc(100vh - 200px);
  }

.modal-header {
  background-color: var(--bs-primary);
  color: white;
  border-radius: 8px 8px 0 0;
}

.modal-body {
  padding: 20px;
}

.modal-body h4 {
  color: var(--bs-primary);
  margin-top: 20px;
  margin-bottom: 10px;
}

.modal-body ul {
  margin-bottom: 15px;
}

.modal-body li {
  margin-bottom: 8px;
}

/* Dark mode support */
[data-bs-theme='dark'] .modal-content {
  background-color: #2c3034;
  color: #ffffff;
}

[data-bs-theme='dark'] .modal-header {
  border-bottom-color: #444;
}

[data-bs-theme='dark'] .modal-footer {
  border-top-color: #444;
}
  
  /* Dark mode theme */
  [data-bs-theme='dark'] {
    --bs-body-bg: #222222;
    --bs-body-color: #ffffff;
  }

  [data-bs-theme='light'] {
    --bs-body-bg: #ffffff;
    --bs-body-color: #212529;
  }
  
  /* Dark mode panels and containers */
  .dark-mode {
    background-color: #222222 !important;
    color: #ffffff !important;
  }
  
  .dark-mode .sidebar-panel,
  .dark-mode .results-panel {
    background-color: #2c3034 !important;
    color: #ffffff !important;
    border: 1px solid #444;
  }
  
  .dark-mode .gene-info {
    background-color: #2c3034 !important;
    color: #ffffff !important;
  }

  .dark-mode .gene-info pre {
    background-color: #2c3034 !important;
    color: #ffffff !important;
    border: none !important;
  }
  
  /* Dark mode plot styles */
  .dark-mode .plotly .main-svg {
    background-color: #2c3034 !important;
  }
  
  .dark-mode .plotly .bg {
    fill: #2c3034 !important;
  }
  
  .dark-mode .js-plotly-plot .plotly .modebar {
    background: #2c3034 !important;
    color: #ffffff !important;
  }
  
  /* Dark mode table styles */
  .dark-mode .dataTables_wrapper {
    color: #ffffff !important;
    background-color: #2c3034 !important;
  }
  
  .dark-mode .dataTable {
    background-color: #2c3034 !important;
    color: #ffffff !important;
  }
  
  .dark-mode .dataTable th,
  .dark-mode .dataTable td {
    background-color: #2c3034 !important;
    color: #ffffff !important;
    border-color: #444 !important;
  }
  
  .dark-mode .dataTables_info,
  .dark-mode .dataTables_length,
  .dark-mode .dataTables_filter,
  .dark-mode .dataTables_paginate {
    color: #ffffff !important;
  }
  
  /* Dark mode form controls */
  .dark-mode input,
  .dark-mode select,
  .dark-mode textarea {
    background-color: #2c3034 !important;
    color: #ffffff !important;
    border-color: #444 !important;
  }
  
  .dark-mode input::placeholder {
    color: #888888 !important;
  }
  
  .dark-mode .checkbox label {
    color: #ffffff !important;
  }
  
  /* Dark mode navigation */
  .dark-mode .nav-tabs {
    border-color: #444 !important;
  }
  
  .dark-mode .nav-tabs .nav-link {
    color: #ffffff !important;
  }
  
  .dark-mode .nav-tabs .nav-link.active {
    background-color: #2c3034 !important;
    border-color: #444 !important;
    color: #ffffff !important;
  }
  .title, .author, .date {
  display: none !important;
  }
  /* Fix for scroll bars and layout issues */
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow-x: hidden;
  }
  
  .container-fluid {
    padding: 0;
    margin: 0;
    width: 100%;
  }
  
  /* Fix for panel heights */
  .sidebar-panel {
    height: auto;
    overflow-y: auto;
    max-height: calc(100vh - 200px);
    padding-bottom: 20px;
  }
  
  /* Ensure the results panel expands properly */
  .results-panel {
    min-height: auto;
    overflow: visible;
    margin-bottom: 20px;
  } 
  
  /* Prevent horizontal scrolling */
  .row {
    margin-left: 0;
    margin-right: 0;
    width: 100%;
  }
  
  /* Make sure the footer doesn't overlap content */
  .footer {
    position: relative;
    margin-top: 30px;
  }
  /* Combined view selection improvements */
  #combined_orthogroup_container .orthogroup-species {
    background-color: #f8f9fa;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    border: 1px solid #dee2e6;
  }
  
  [data-bs-theme='dark'] #combined_orthogroup_container .orthogroup-species {
    background-color: #2c3034;
    border-color: #444;
  }
  
  #combined_orthogroup_container .radio label {
    margin-left: 5px;
    font-size: 14px;
  }
  
  #combined_orthogroup_container h6 {
    margin-bottom: 10px;
    font-weight: 600;
    color: var(--bs-primary);
  }
  
  #combined_orthogroup_container .alert {
    font-size: 13px;
    padding: 8px 12px;
  }
  
  /* Improve radio button spacing */
  #combined_orthogroup_container .radio {
    margin-bottom: 8px;
  }
  
  #combined_orthogroup_container .radio input[type='radio'] {
    margin-right: 5px;
  }
  
  /* Fix for Species Analysis dropdown menu */
  .navbar {
    overflow: visible !important;
  }
  
  .navbar-nav {
    overflow: visible !important;
  }
  
  .dropdown-menu {
    position: absolute !important;
    z-index: 1050 !important;
    background-color: var(--bs-body-bg);
    border: 1px solid var(--bs-border-color);
  }
  
  .navbar .dropdown {
    position: static;
  }
  
  .navbar .dropdown-menu {
    position: absolute !important;
    top: 100%;
    left: auto;
    right: auto;
  }
  
  /* Ensure the page navbar container allows overflow for dropdowns */
  .bslib-page-navbar > .navbar {
    overflow: visible !important;
  }
  
  /* Fix the nav container to allow dropdown visibility */
  .nav-underline {
    overflow: visible !important;
  }
  
  /* Ensure dropdown items are visible */
  .dropdown-item {
    color: var(--bs-body-color);
  }
  
  .dropdown-item:hover {
    background-color: var(--bs-primary);
    color: white;
  }
  /* Gene Explorer Styles */
  .gene-explorer-container {
    padding: 20px;
  }
  
  .query-panel {
    background-color: var(--bs-body-bg);
    border: 1px solid var(--bs-border-color);
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  
  .tree-panel {
    background-color: var(--bs-body-bg);
    border: 1px solid var(--bs-border-color);
    border-radius: 8px;
    padding: 20px;
    min-height: 400px;
  }
  
  .orthogroup-summary {
    background-color: var(--bs-body-bg);
    border: 1px solid var(--bs-border-color);
    border-radius: 8px;
    padding: 20px;
  }
  
  .query-status {
    margin-top: 15px;
    padding: 10px;
    border-radius: 4px;
    background-color: var(--bs-light);
  }
  
  [data-bs-theme='dark'] .query-status {
    background-color: #2c3034;
  }
  
  .tree-legend {
    margin-top: 20px;
    padding: 15px;
    background-color: #f8f9fa;
    border-radius: 4px;
  }
  
  [data-bs-theme='dark'] .tree-legend {
    background-color: #2c3034;
  }
  
    /* Animated DNA to Chart Icon */
  .icon-morph-container {
    display: inline-block;
    position: relative;
    width: 20px;
    height: 20px;
    margin-right: 5px;
  }
  
  .icon-morph-container .fa-dna,
  .icon-morph-container .fa-chart-line {
    position: absolute;
    top: 0;
    left: 0;
    transition: all 0.8s ease-in-out;
  }
  
  .icon-morph-container .fa-dna {
    animation: dna-morph 4s infinite;
  }
  
  .icon-morph-container .fa-chart-line {
    animation: chart-morph 4s infinite;
  }
  
  @keyframes dna-morph {
    0%, 20% {
      opacity: 1;
      transform: rotate(0deg) scale(1);
    }
    40%, 60% {
      opacity: 0;
      transform: rotate(180deg) scale(0.5);
    }
    80%, 100% {
      opacity: 1;
      transform: rotate(360deg) scale(1);
    }
  }
  
  @keyframes chart-morph {
    0%, 20% {
      opacity: 0;
      transform: translateY(10px) scale(0.5);
    }
    40%, 60% {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    80%, 100% {
      opacity: 0;
      transform: translateY(-10px) scale(0.5);
    }
  }
  
  /* Hover effect to pause animation */
  .icon-morph-container:hover .fa-dna,
  .icon-morph-container:hover .fa-chart-line {
    animation-play-state: paused;
  }
  
    /* Gene Explorer specific styles */
   .gene-explorer-container {
    padding: 20px;
    padding-bottom: 120px !important;
    max-width: 1400px;
    margin: 0 auto;
    min-height: calc(100vh - 200px);
  }
  
  /* Cross-Species Ortholog Analysis styles */
  .ortholog-analysis-panel {
    background-color: var(--bs-body-bg);
    border: 2px solid var(--bs-primary);
    border-radius: 8px;
    padding: 15px;
    margin: 15px 0;
  }
  
  [data-bs-theme='dark'] .ortholog-analysis-panel {
    background-color: #2c3034;
    border-color: #375a7f;
  }
  
  .coverage-badge {
    display: inline-block;
    padding: 4px 8px;
    margin: 2px;
    border-radius: 4px;
    font-size: 0.85em;
    font-weight: 500;
  }
  
  .coverage-badge.high {
    background-color: #d4edda;
    color: #155724;
  }
  
  .coverage-badge.medium {
    background-color: #fff3cd;
    color: #856404;
  }
  
  .coverage-badge.low {
    background-color: #f8d7da;
    color: #721c24;
  }
  
  [data-bs-theme='dark'] .coverage-badge.high {
    background-color: #1e4620;
    color: #a3d9a5;
  }
  
  [data-bs-theme='dark'] .coverage-badge.medium {
    background-color: #664d03;
    color: #ffc107;
  }
  
  [data-bs-theme='dark'] .coverage-badge.low {
    background-color: #58151c;
    color: #f1aeb5;
  }
  
  .ortholog-summary-box {
    background-color: #f8f9fa;
    border-left: 4px solid var(--bs-primary);
    padding: 10px;
    margin: 10px 0;
    border-radius: 4px;
  }
  
  [data-bs-theme='dark'] .ortholog-summary-box {
    background-color: #2c3034;
  }
  
  .query-panel {
    background: linear-gradient(135deg, var(--bs-primary) 0%, var(--bs-info) 100%);
    color: white;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  }
  
  .query-panel h3 {
    color: white;
    margin-bottom: 20px;
  }
  
  .query-panel p {
    color: rgba(255,255,255,0.9);
    margin-bottom: 20px;
  }
  
  .query-panel input {
    font-size: 16px;
    padding: 10px;
  }
  
  .tree-panel {
    overflow: hidden;
  }
  
  .orthogroup-summary h5 {
    color: var(--bs-primary);
    margin-bottom: 15px;
    font-weight: 600;
  }
  
  .orthogroup-summary ul {
    padding-left: 20px;
  }
  
  .orthogroup-summary li {
    margin-bottom: 8px;
  }
  
  /* Dark mode adjustments */
  [data-bs-theme='dark'] .query-panel {
    background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
  }
  
  [data-bs-theme='dark'] .tree-panel,
  [data-bs-theme='dark'] .orthogroup-summary {
    background-color: #2c3034;
    border-color: #444;
  }
  /* Data Upload Panel Styles */
  .upload-step {
    background-color: var(--bs-body-bg);
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 15px;
    border: 1px solid var(--bs-border-color);
  }
  
  .upload-step h5 {
    color: var(--bs-primary);
    margin-bottom: 10px;
    font-weight: 600;
  }
  
  .upload-step p {
    font-size: 0.9em;
    color: var(--bs-secondary);
    margin-bottom: 10px;
  }
  
  [data-bs-theme='dark'] .upload-step {
    background-color: #2c3034;
    border-color: #444;
  }
  
  #upload_status_banner {
    position: sticky;
    top: 0;
    z-index: 1000;
    margin-bottom: 20px;
  }
  
  /* Gene Explorer specific styles */
   .gene-explorer-container {
  
"))
#get expression matrix based on transformation (optimized)
get_expression_matrix <- function(species_code, transform_type, species_data = NULL) {
  if (is.null(species_data)) {
    species_data <- all_species_data[[species_code]]
  }
  
  #precompute matrix name
  is_cg <- species_code == "cg"
  
  if (transform_type == "rlog") {
    matrix_name <- if(is_cg) "rlog" else paste0(species_code, "_rlog")
    expr_matrix <- species_data[[matrix_name]]
  } else {
    matrix_name <- if(is_cg) "lcpm" else paste0(species_code, "_lcpm")
    expr_matrix <- species_data[[matrix_name]]
  }
  
  #debug output
  if (DEBUG_MODE) {
    if (!is.null(expr_matrix)) {
      debug_cat("\n=== get_expression_matrix DEBUG ===\n")
      debug_cat("Species:", species_code, "\n")
      debug_cat("Transform:", transform_type, "\n")
      debug_cat("Matrix name:", matrix_name, "\n")
      debug_cat("Rows:", nrow(expr_matrix), "Cols:", ncol(expr_matrix), "\n")
      debug_cat("First 5 rownames:", paste(head(rownames(expr_matrix), 5), collapse=", "), "\n")
    } else {
      debug_cat("\n!!! expr_matrix is NULL for species:", species_code, "transform:", transform_type, "\n")
    }
  }
  
  return(expr_matrix)
}

#helper function to get axis label based on transformation
get_expression_label <- function(transform_type) {
  if (transform_type == "rlog") {
    return("rlog expression")
  } else {
    return("log2(CPM)")
  }
}

```

```{r helper_functions, echo=FALSE}
#query genes using lookup table (optimized)
query_gene_lookup <- function(query, species_filter = NULL, current_data = NULL) {
  if (is.null(current_data)) {
    current_data <- all_species_data
  }
  lookup_table <- current_data$gene_lookup
  query <- toupper(trimws(query))
  
  #use precomputed uppercase columns if available
  if ("gene_id_upper" %in% names(lookup_table)) {
    matches <- lookup_table[gene_id_upper == query | gene_name_upper == query, ]
  } else {
    matches <- lookup_table[toupper(gene_id) == query | toupper(gene_name) == query, ]
  }
  
  if (!is.null(species_filter) && length(species_filter) > 0) {
    matches <- matches[species %in% species_filter]
  }
  return(matches)
}

#get expression matrix ID for a gene
get_expression_id <- function(query_gene_id, species_code) {
  lookup_table <- all_species_data$gene_lookup
  match <- lookup_table[gene_id == query_gene_id & species == species_code]
  
  if (nrow(match) > 0) {
    return(match$expression_id[1])
  }
  return(NULL)
}

#get all genes in an orthogroup
get_orthogroup_genes <- function(group_id, use_og = FALSE, current_data = NULL) {
  if (is.null(current_data)) {
    current_data <- all_species_data  
  }
  lookup_table <- current_data$gene_lookup
  
  #HOG-based search
  result <- lookup_table[hog_id == group_id, ]
  
  #fallback to OG if not all species found
  if (length(unique(result$species)) < 4 && nrow(result) > 0) {
    og_ids <- unique(result$og_id)
    og_ids <- og_ids[!is.na(og_ids)]
    
    if (length(og_ids) > 0) {
      og_result <- lookup_table[og_id %in% og_ids, ]
      if (nrow(og_result) > nrow(result)) {
        result <- og_result
      }
    }
  }
  
  return(result)
}

#identify species from gene ID using lookup table
identify_species <- function(query_gene_id, current_data = NULL) {
  if (is.null(current_data)) {
    current_data <- all_species_data
  }
  lookup_table <- current_data$gene_lookup
  match <- lookup_table[gene_id == query_gene_id]
  
  if (nrow(match) > 0) {
    return(as.character(match$species[1]))
  }
  return(NULL)
}

#function for orthogroup queries that works across all species
query_orthogroups <- function(gene_query, current_data, config, get_species_data_fn) {
  #searches in all species to find the gene
  for (species_id in names(config)) {
    species_data <- get_species_data_fn(species_id)
    
    if (!is.null(species_data)) {
      result <- query_gene_flexible(gene_query, species_data, current_data)
      
      if (!is.null(result) && result$source != "none") {
        return(result)
      }
    } 
  }
  
  return(NULL)
}


#query function for HOG + Gene Lookup (optimized)
query_gene_flexible <- function(gene_query, species_data, all_species_data) {
  gene_query <- toupper(trimws(gene_query))
  if (nchar(gene_query) == 0) return(NULL)
  
  debug_cat("\n=== query_gene_flexible ===\n")
  debug_cat("Query:", gene_query, "\n")
  
  # Use the lookup table to find the gene
  lookup_matches <- query_gene_lookup(gene_query, NULL, all_species_data)
  
  debug_cat("Total lookup matches:", nrow(lookup_matches), "\n")
  
  if (nrow(lookup_matches) == 0) {
    debug_cat("No matches found in lookup table\n")
    return(NULL)
  }
  
  # Get the first match
  match_info <- lookup_matches[1,]
  gene_id <- match_info$gene_id
  expression_id <- match_info$expression_id
  hog_id <- match_info$hog_id
  og_id <- match_info$og_id
  
  # Use expression_id for retrieving actual expression data
  actual_gene_id <- if(!is.na(expression_id) && expression_id != "") expression_id else gene_id
  
  debug_cat("First match - Gene ID:", gene_id, "HOG:", hog_id, "OG:", og_id, "\n")
  
  # Build result
  result <- list(
    query = gene_query,
    gene_id = gene_id,
    expression_id = expression_id,
    match_type = ifelse(gene_query == toupper(gene_id), "direct", "gene_name"),
    source = "gene_lookup",
    orthogroup = hog_id,
    og_id = og_id,  # Add og_id to result
    genes_by_species = list()
  )
  
  # Get all genes in this HOG (try both HOG and OG)
  if (!is.na(hog_id) && nchar(hog_id) > 0) {
    hog_genes <- get_orthogroup_genes(hog_id, FALSE, all_species_data)
    
    # If we didn't find enough genes, try using the OG ID
    if (nrow(hog_genes) < 4 && !is.na(og_id)) {
      debug_cat("Trying OG-based search as HOG gave limited results\n")
      og_id_value <- og_id
      og_genes <- all_species_data$gene_lookup[og_id == og_id_value]
      if (nrow(og_genes) > nrow(hog_genes)) {
        debug_cat("OG search found more genes:", nrow(og_genes), "vs", nrow(hog_genes), "\n")
        hog_genes <- og_genes
      }
    }
    
    debug_cat("Total orthogroup genes found:", nrow(hog_genes), "\n")
    
    # Group by species
    for (sp in unique(hog_genes$species)) {
      sp_genes <- hog_genes[species == sp]
      
      debug_cat("  Species", sp, ":", nrow(sp_genes), "genes\n")
      
      # Create display format
      genes_df <- data.frame(
        gene_id = sp_genes$gene_id,
        gene_name = sp_genes$gene_name,
        display = ifelse(
          !is.na(sp_genes$gene_name) & sp_genes$gene_name != "",
          paste0(sp_genes$gene_name, " (", sp_genes$gene_id, ")"),
          sp_genes$gene_id
        ),
        expression_id = sp_genes$expression_id,
        stringsAsFactors = FALSE
      )
      
      result$genes_by_species[[sp]] <- genes_df
    }
  }
  
  return(result)
}

# Simplified add_gene_names function
add_gene_names <- function(gene_ids, species_id) {
  if (length(gene_ids) == 0) return(data.frame(
    gene_id = character(),
    gene_name = character(),
    display = character(),
    stringsAsFactors = FALSE
  ))
  
  # Use lookup table
  lookup_table <- all_species_data$gene_lookup
  
  # Get genes for this species
  gene_info <- lookup_table[gene_id %in% gene_ids & species == species_id]
  
  # Create result dataframe
  result <- data.frame(
    gene_id = gene_info$gene_id,
    gene_name = gene_info$gene_name,
    display = ifelse(
      !is.na(gene_info$gene_name) & gene_info$gene_name != "",
      paste0(gene_info$gene_name, " (", gene_info$gene_id, ")"),
      gene_info$gene_id
    ),
    stringsAsFactors = FALSE
  )
  
  return(result)
}

# Helper function for hidden input
hiddenInput <- function(inputId, value) {
  tags$input(
    id = inputId,
    type = "hidden",
    value = value
  )
}

#Modified plot function to handle selected genes
create_gene_plot <- function(lc, gene, sample_info, species_name, is_dark_mode = FALSE, species_colors = NULL, transform_type = "lcpm") {
  tryCatch({
    # Try to find the gene with different formats (for K. lactis)
    gene_found <- FALSE
    gene_to_use <- gene
    
    # For K. lactis, try multiple formats
    if (grepl("^KLLA0", gene)) {
      possible_genes <- c(gene, gsub("_", "", gene), gsub("^(KLLA0)(.*)", "\\1_\\2", gene))
      for (pg in possible_genes) {
        if (pg %in% rownames(lc)) {
          gene_to_use <- pg
          gene_found <- TRUE
          break
        }
      }
    } else {
      gene_found <- gene %in% rownames(lc)
      gene_to_use <- gene
    }
    
    if(!gene_found) {
      # More informative error message
      available_example <- head(rownames(lc)[grepl(substr(gene, 1, 5), rownames(lc))], 3)
      error_msg <- paste("Gene ID", gene, "not found in expression data.")
      if (length(available_example) > 0) {
        error_msg <- paste(error_msg, "\nSimilar genes:", paste(available_example, collapse = ", "))
      }
      
      return(plotly_empty() %>% 
             add_annotations(text = error_msg,
                           showarrow = FALSE))
    }
    
    # Get the appropriate color for this species
    species_color <- if(!is.null(species_colors) && species_name %in% names(species_colors)) {
      species_colors[[species_name]]
    } else {
      "#440154"  # Default color
    }
    
    # Normalize timepoint format (handle both "0min" and "0" formats)
    normalized_timepoints <- sample_info$Timepoint
    normalized_timepoints <- gsub("^(\\d+)$", "\\1min", normalized_timepoints)  # Add "min" if missing
    normalized_timepoints <- gsub("^(\\d+)min$", "\\1min", normalized_timepoints)  # Ensure format
    
    dt <- data.table(
      Sample = colnames(lc),
      Timepoint = factor(normalized_timepoints, levels = TIME_POINTS),
      Replicate = sample_info$Replicate,
      exn = as.numeric(lc[gene_to_use,])
    )
    
    plot_bg_color <- if(is_dark_mode) "#2c3034" else "white"
    text_color <- if(is_dark_mode) "white" else "black"
    grid_color <- if(is_dark_mode) "gray30" else "gray90"
    
    #custom color scale with two shades of the species color for any rep number
    n_replicates <- length(unique(dt$Replicate))
    if (n_replicates == 1) {
      replicate_colors <- species_color
    } else if (n_replicates == 2) {
      replicate_colors <- c(species_color, adjustcolor(species_color, alpha.f = 0.7))
    } else {
      # Generate a gradient for more replicates
      alpha_values <- seq(1, 0.4, length.out = n_replicates)
      replicate_colors <- sapply(alpha_values, function(a) adjustcolor(species_color, alpha.f = a))
    }
    
    p <- ggplot(dt, aes(x = Timepoint, y = exn, color = factor(Replicate), group = Replicate)) +
      geom_point(size = 3) + 
      geom_line(linewidth = 1) +
      scale_color_manual(values = replicate_colors) +
      labs(
        y = get_expression_label(transform_type),
        title = paste("Expression of", gene, "in", species_name),
        color = "Replicate"
      ) +
      theme_minimal() +
      theme(
        text = element_text(color = text_color),
        axis.text.x = element_text(angle = 45, hjust = 1, color = text_color),
        axis.text.y = element_text(color = text_color),
        plot.title = element_text(size = 14, face = "bold", color = text_color),
        panel.grid.major = element_line(color = grid_color),
        panel.grid.minor = element_line(color = ifelse(is_dark_mode, "gray20", "gray95")),
        plot.background = element_rect(fill = plot_bg_color, color = NA),
        panel.background = element_rect(fill = plot_bg_color, color = NA),
        legend.background = element_rect(fill = plot_bg_color),
        legend.text = element_text(color = text_color),
        legend.title = element_text(color = text_color),
        axis.title = element_text(color = text_color)
      )
    
    ggplotly(p) %>%
      layout(
        plot_bgcolor = plot_bg_color,
        paper_bgcolor = plot_bg_color,
        font = list(color = text_color),
        hoverlabel = list(bgcolor = if(is_dark_mode) "#444" else "white"),
        showlegend = TRUE,
        margin = list(b = 100)
      ) %>%
      config(
        displayModeBar = TRUE,
        modeBarButtons = list(
          list("zoom2d", "pan2d", "resetScale2d", "toImage")
        )
      )
  }, error = function(e) {
    plotly_empty() %>% 
      add_annotations(
        text = paste("Error creating plot:", e$message),
        showarrow = FALSE
      )
  })
}

# modified gene search function with transformation awareness
search_gene <- function(query, species_data, transform_type = "lcpm") {
  query <- toupper(trimws(query))
  if (nchar(query) == 0) return(NULL)
  
  #get appropriate expression matrix based on transformation
  expr_matrix <- if(transform_type == "rlog") {
    #get rlog matrix
    rlog_name <- names(species_data)[grepl("rlog$", names(species_data))][1]
    if(is.null(rlog_name)) species_data$lcpm else species_data[[rlog_name]]
  } else {
    #get lcpm matrix
    lcpm_name <- names(species_data)[grepl("lcpm$", names(species_data))][1]
    if(is.null(lcpm_name)) species_data$lcpm else species_data[[lcpm_name]]
  }
  
  #direct match to expression matrix
  if (query %in% rownames(expr_matrix)) {
    return(list(id = query, type = "direct_match"))
  }
  
  #matches via annotation 
  if (!is.null(species_data$anno) && query %in% species_data$anno$GeneName) {
    gene_id <- species_data$anno$GeneID[species_data$anno$GeneName == query]
    if (length(gene_id) == 1 && gene_id[1] %in% rownames(expr_matrix)) {
      return(list(id = gene_id[1], type = "annotation_match"))
    }
  }
  
  #legacy S. cerevisiae match (if available)
  if (!is.null(all_species_data$legacy_synteny)) {
    #check the appropriate legacy mapping based on species
    # Check the appropriate legacy mapping based on species
    # This is simplified - you'd need to implement the full logic
  }
  
  return(NULL)
}

# creates a species panel with orthogroup selection
create_species_panel <- function(species) {
  nav_panel(
    species$name,
    fluidRow(
      column(
        width = 3,
        div(
          class = "sidebar-panel",
          h4(class = "mb-4", "Analysis Controls"),
          textInput(
            paste0(species$id, "_genename"),
            "Gene name or ID:",
            placeholder = "e.g., PHO4"
          ),
          actionButton(
            paste0(species$id, "_search_button"),
            "Search Gene",
            icon = icon("search"),
            class = "custom-button"
          ),
          # Orthogroup selection area
          div(
            id = paste0(species$id, "_orthogroup_container"),
            style = "display: none;",
            hr(),
            div(
              class = "orthogroup-info",
              h5("Orthogroup Members"),
              p("Select genes to analyze from the orthogroup:"),
              div(
                id = paste0(species$id, "_orthogroup_selection"),
                class = "orthogroup-selection",
                # PRE-CREATE the radio buttons with dummy choice
                radioButtons(
                  paste0(species$id, "_", species$id, "_selection"),
                  label = NULL,
                  choices = c("Search for a gene..." = ""),
                  selected = ""
                )
              )
            ),
            actionButton(
              paste0(species$id, "_plot_button"),
              "Generate Plot",
              icon = icon("chart-line"),
              class = "custom-button"
            )
          ),
          downloadButton(
            paste0(species$id, "_download"),
            "Download Plot",
            class = "btn btn-secondary mt-2 w-100"
          ),
          hr(),
          div(class = "gene-info",
            verbatimTextOutput(paste0(species$id, "_gene_info"))
          )
        )
      ),
      column(
        width = 9,
        div(
          class = "results-panel",
          plotlyOutput(paste0(species$id, "_gene_plot"), height = "400px"),
          fluidRow(
            column(
              width = 6,
              div(
                class = "mt-4",
                h5(paste(species$name, "Search Results")),
                DTOutput(paste0(species$id, "_search_results"))
              )
            ),
            column(
              width = 6,
              div(
                class = "mt-4",
                h5("Orthogroup Members"),
                DTOutput(paste0(species$id, "_orthogroup_results"))
              )
            )
          )
        )
      )
    )
  )
}

#processes gene group data with HOG support
process_gene_group_data <- function(gene_groups, species_data, all_species_data, config, species_code) {
  # species_code is now passed as parameter
  # config is now passed as parameter
  for (sp_id in names(config)) {
    removeUI(
      selector = paste0("#combined_", sp_id, "_selection_ui > *"),
      multiple = TRUE,
      immediate = TRUE
    )
  }
  
  #extract expression data for each gene
  expression_data <- lapply(unique(gene_groups$group_member), function(gene) {
    #use the flexible query to find the gene
    gene_result <- query_gene_flexible(gene, species_data, all_species_data)
    
    if (!is.null(gene_result) && !is.null(gene_result$gene_id)) {
      #check if the gene exists in the current species
      if (species_code %in% names(gene_result$genes_by_species)) {
        species_genes <- gene_result$genes_by_species[[species_code]]
        if (nrow(species_genes) > 0) {
          #try to find the exact match first
          gene_id <- NULL
          gene_upper <- toupper(trimws(gene))
          
          #check if the queried gene itself is in the species genes
          for (i in 1:nrow(species_genes)) {
            #checkboth gene_id and gene_name for exact match
            if (toupper(species_genes$gene_id[i]) == gene_upper || 
                toupper(species_genes$gene_name[i]) == gene_upper) {
              gene_id <- species_genes$gene_id[i]
              break
            }
          }
          
          #no exact match foun fall back first gene 
          if (is.null(gene_id)) {
            gene_id <- species_genes$gene_id[1]
          }
          
          #handle K. lactis underscore format 
          if (species_code == "kl" && !gene_id %in% rownames(species_data$lcpm)) {
            gene_id_alt <- gsub("^(KLLA0)(.*)", "\\1_\\2", gene_id)
            if (gene_id_alt %in% rownames(species_data$lcpm)) {
              gene_id <- gene_id_alt
            }
          }
          
          if (gene_id %in% rownames(species_data$lcpm)) {
            data.frame(
              Gene = gene,
              Group = gene_groups$group_name[gene_groups$group_member == gene],
              Timepoint = factor(species_data$sample_info$Timepoint, levels = TIME_POINTS),
              Replicate = species_data$sample_info$Replicate,
              Expression = as.numeric(species_data$lcpm[gene_id, ]),
              stringsAsFactors = FALSE
            )
          }
        }
      }
    }
  })
  
  #combine all data
  filtered_data <- Filter(Negate(is.null), expression_data)
  if (length(filtered_data) > 0) {
    rbindlist(filtered_data, fill = TRUE)
  } else {
    NULL
  }
}
extract_orthology_for_genes <- function(gene_list, all_species_data = NULL, config = NULL) {
  if (is.null(all_species_data)) {
    all_species_data <- get_all_species_data()
  }
  if (is.null(config)) {
    config <- DEFAULT_SPECIES_CONFIG  
  }
  ortholog_gene_map <- list()
  
  for (gene in gene_list) {
    gene_found <- FALSE
    
    #use existing query_gene_flexible like Combined View does
    query_result <- NULL
    for (sp_id in names(config)) {
      sp_data <- list(
        lcpm = if(!is.null(all_species_data[[sp_id]]$lcpm)) all_species_data[[sp_id]]$lcpm else all_species_data[[sp_id]][[paste0(sp_id, "_lcpm")]],
        anno = if(!is.null(all_species_data[[sp_id]]$anno)) all_species_data[[sp_id]]$anno else all_species_data[[sp_id]][[paste0(sp_id, "_anno")]],
        sample_info = if(!is.null(all_species_data[[sp_id]]$sample_info)) all_species_data[[sp_id]]$sample_info else all_species_data[[sp_id]][[paste0(sp_id, "_sample_info")]]
      )
      
      result <- query_gene_flexible(gene, sp_data, all_species_data)
      if (!is.null(result) && result$source != "none") {
        query_result <- result
        gene_found <- TRUE
        break
      }
    }
    
    if (!is.null(query_result) && !is.null(query_result$genes_by_species)) {
      #build entry with all genes from orthogroup
      gene_entry <- list(original = gene)
      
      for (sp_code in names(config)) {
        if (sp_code %in% names(query_result$genes_by_species)) {
          sp_genes_df <- query_result$genes_by_species[[sp_code]]
          if (!is.null(sp_genes_df) && nrow(sp_genes_df) > 0) {
            gene_entry[[sp_code]] <- sp_genes_df$gene_id
          } else {
            gene_entry[[sp_code]] <- NULL
          }
        } else {
          gene_entry[[sp_code]] <- NULL
        }
      }
      
      ortholog_gene_map[[length(ortholog_gene_map) + 1]] <- gene_entry
    }
  }
  
  return(ortholog_gene_map)
}
#aggregate gene expression to species means
aggregate_to_species_mean <- function(plot_data) {
  #calculate mean and SE per species per timepoint
  aggregated <- plot_data %>%
    group_by(Species, Timepoint, Replicate) %>%
    summarise(
      Expression = mean(Expression, na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    mutate(Gene = paste0(Species, "_mean"))
  
  return(aggregated)
}

process_pathway_comparison <- function(pathway_definitions, species_data_list, config, all_species_data) {
  pathway_results <- list()
  gene_details_list <- list()
  detail_idx <- 1
  
  for (pathway_name in names(pathway_definitions)) {
    gene_list <- pathway_definitions[[pathway_name]]
    
    #map genes to orthologs
    gene_mapping <- extract_orthology_for_genes(gene_list, all_species_data, config)
    
    if (is.null(gene_mapping) || length(gene_mapping) == 0) {
      next
    }
    
    #extract expression data
    pathway_expr <- process_multi_species_gene_set(gene_mapping, species_data_list, config)
    
    if (is.null(pathway_expr) || nrow(pathway_expr) == 0) {
      next
    }
    
    #store gene details per species for this pathway
    species_in_data <- unique(pathway_expr$Species)
    for (sp in species_in_data) {
      sp_expr <- pathway_expr[pathway_expr$Species == sp, ]
      gene_details_list[[detail_idx]] <- data.frame(
        Pathway = pathway_name,
        Species = sp,
        Genes = paste(sort(unique(sp_expr$Gene)), collapse = ", "),
        GeneIDs = paste(sort(unique(sp_expr$GeneID)), collapse = ", "),
        stringsAsFactors = FALSE
      )
      detail_idx <- detail_idx + 1
    }
    
    #calculate mean expression per species per timepoint
    pathway_summary <- pathway_expr %>%
      group_by(Species, Timepoint) %>%
      summarise(
        MeanExpression = mean(Expression, na.rm = TRUE),
        SEExpression = sd(Expression, na.rm = TRUE) / sqrt(n()),
        NGenes = n_distinct(Gene),
        .groups = 'drop'
      ) %>%
      mutate(Pathway = pathway_name)
    
    pathway_results[[pathway_name]] <- pathway_summary
  }
  
  if (length(pathway_results) == 0) {
    return(NULL)
  }
  
  #combine all pathway data
  combined_data <- rbindlist(pathway_results, fill = TRUE)
  combined_genes <- if (length(gene_details_list) > 0) {
    rbindlist(gene_details_list, fill = TRUE)
  } else {
    data.frame(Pathway = character(), Species = character(), 
               Genes = character(), GeneIDs = character())
  }
  
  #attach gene details as attribute
  result <- as.data.frame(combined_data)
  attr(result, "gene_details") <- as.data.frame(combined_genes)
  return(result)
}

process_single_species_pathway <- function(pathway_definitions, species_data, species_name, transform_type = "lcpm") {
  pathway_results <- list()
  gene_details <- list()
  
  #get expression matrix
  lcpm_matrix <- if (!is.null(species_data$lcpm)) {
    species_data$lcpm
  } else {
    #try prefixed version
    prefix_names <- names(species_data)[grepl("_lcpm$", names(species_data))]
    if (length(prefix_names) > 0) species_data[[prefix_names[1]]] else NULL
  }
  
  sample_info <- if (!is.null(species_data$sample_info)) {
    species_data$sample_info
  } else {
    prefix_names <- names(species_data)[grepl("_sample_info$", names(species_data))]
    if (length(prefix_names) > 0) species_data[[prefix_names[1]]] else NULL
  }
  
  anno <- if (!is.null(species_data$anno)) {
    species_data$anno
  } else {
    prefix_names <- names(species_data)[grepl("_anno$", names(species_data))]
    if (length(prefix_names) > 0) species_data[[prefix_names[1]]] else NULL
  }
  
  if (is.null(lcpm_matrix) || is.null(sample_info)) {
    return(NULL)
  }
  
  for (pathway_name in names(pathway_definitions)) {
    gene_list <- pathway_definitions[[pathway_name]]
    expression_data <- list()
    
    for (gene in gene_list) {
      gene_upper <- toupper(trimws(gene))
      
      #find gene in matrix (by ID or name via anno)
      gene_id <- NULL
      
      #direct match in rownames
      if (gene_upper %in% toupper(rownames(lcpm_matrix))) {
        idx <- which(toupper(rownames(lcpm_matrix)) == gene_upper)
        gene_id <- rownames(lcpm_matrix)[idx[1]]
      }
      
      #match via annotation
      if (is.null(gene_id) && !is.null(anno)) {
        if ("GeneName" %in% colnames(anno)) {
          anno_match <- which(toupper(anno$GeneName) == gene_upper)
          if (length(anno_match) > 0 && "GeneID" %in% colnames(anno)) {
            potential_id <- anno$GeneID[anno_match[1]]
            if (potential_id %in% rownames(lcpm_matrix)) {
              gene_id <- potential_id
            }
          }
        }
        if (is.null(gene_id) && "GeneID" %in% colnames(anno)) {
          anno_match <- which(toupper(anno$GeneID) == gene_upper)
          if (length(anno_match) > 0) {
            potential_id <- anno$GeneID[anno_match[1]]
            if (potential_id %in% rownames(lcpm_matrix)) {
              gene_id <- potential_id
            }
          }
        }
      }
      
      if (!is.null(gene_id) && gene_id %in% rownames(lcpm_matrix)) {
        expr_df <- data.frame(
          Gene = gene,
          GeneID = gene_id,
          Species = species_name,
          Timepoint = factor(sample_info$Timepoint, levels = TIME_POINTS),
          Replicate = sample_info$Replicate,
          Expression = as.numeric(lcpm_matrix[gene_id, ]),
          stringsAsFactors = FALSE
        )
        expression_data[[length(expression_data) + 1]] <- expr_df
      }
    }
    
    if (length(expression_data) == 0) next
    
    pathway_expr <- rbindlist(expression_data, fill = TRUE)
    
    #calculate mean expression per timepoint
    pathway_summary <- pathway_expr %>%
      group_by(Species, Timepoint) %>%
      summarise(
        MeanExpression = mean(Expression, na.rm = TRUE),
        SEExpression = sd(Expression, na.rm = TRUE) / sqrt(n()),
        NGenes = n_distinct(Gene),
        .groups = 'drop'
      ) %>%
      mutate(Pathway = pathway_name)
    
    pathway_results[[pathway_name]] <- pathway_summary
  }
  
  if (length(pathway_results) == 0) {
    return(NULL)
  }
  
  combined_data <- rbindlist(pathway_results, fill = TRUE)
  combined_genes <- rbindlist(gene_details, fill = TRUE)
  
  result <- as.data.frame(combined_data)
  attr(result, "gene_details") <- as.data.frame(combined_genes)
  return(result)
}

#calculate fold-change from baseline (t=0) for pathway heatmap
calculate_pathway_foldchange <- function(pathway_data) {
  #ensure timepoint is a factor with correct order
  pathway_data$Timepoint <- factor(pathway_data$Timepoint, levels = TIME_POINTS)
  
  #calculate fold-change per pathway per species
  fc_data <- pathway_data %>%
    group_by(Pathway, Species) %>%
    arrange(Timepoint) %>%
    mutate(
      BaselineExpr = {
        baseline_vals <- MeanExpression[Timepoint == "0min"]
        if (length(baseline_vals) == 0 || all(is.na(baseline_vals))) {
          #fallback to first timepoint if 0min missing
          first(MeanExpression)
        } else {
          baseline_vals[1]
        }
      },
      FoldChange = MeanExpression - BaselineExpr,
      Log2FC = FoldChange
    ) %>%
    ungroup()
  
  return(fc_data)
}

#create pathway comparison heatmap
create_pathway_heatmap <- function(pathway_data, value_type = "foldchange", 
                                   is_dark_mode = FALSE, cluster_pathways = FALSE,
                                   timepoint_mode = "all") {
  #validate input
  if (is.null(pathway_data) || nrow(pathway_data) == 0) {
    return(plotly_empty() %>% 
             add_annotations(text = "No pathway data available", showarrow = FALSE))
  }
  
  plot_bg_color <- if(is_dark_mode) "#2c3034" else "white"
  text_color <- if(is_dark_mode) "white" else "black"
  
  #prepare data based on value type
  if (value_type == "foldchange") {
    heatmap_data <- calculate_pathway_foldchange(pathway_data)
    value_col <- "Log2FC"
    colorbar_title <- "log2 Fold-Change"
    zmid_val <- 0
    zmin_val <- -3
    zmax_val <- 3
  } else {
    heatmap_data <- pathway_data
    value_col <- "MeanExpression"
    colorbar_title <- "Mean log2 CPM"
    zmid_val <- NULL
    zmin_val <- NULL
    zmax_val <- NULL
  }
  
  #validate value column exists
  if (!value_col %in% colnames(heatmap_data)) {
    return(plotly_empty() %>% 
             add_annotations(text = paste("Missing column:", value_col), showarrow = FALSE))
  }
  
  #get all unique pathways and species
  all_pathways <- unique(heatmap_data$Pathway)
  species_list <- unique(heatmap_data$Species)
  n_species <- length(species_list)
  n_pathways <- length(all_pathways)
  
  #validate we have data
  if (n_species == 0 || n_pathways == 0) {
    return(plotly_empty() %>% 
             add_annotations(text = "No pathways or species found in data", showarrow = FALSE))
  }
  
  #get timepoints present in data
  all_data_timepoints <- unique(as.character(heatmap_data$Timepoint))
  all_data_timepoints <- all_data_timepoints[all_data_timepoints %in% TIME_POINTS]
  all_data_timepoints <- TIME_POINTS[TIME_POINTS %in% all_data_timepoints]
  
  if (length(all_data_timepoints) == 0) {
    return(plotly_empty() %>% 
             add_annotations(text = "No valid timepoints found", showarrow = FALSE))
  }
  
  #determine which timepoints to display based on mode
  if (timepoint_mode == "comparable") {
    #find intersection of timepoints across all species
    timepoints_by_species <- lapply(species_list, function(sp) {
      sp_data <- heatmap_data[heatmap_data$Species == sp, ]
      unique(as.character(sp_data$Timepoint))
    })
    comparable_timepoints <- Reduce(intersect, timepoints_by_species)
    comparable_timepoints <- TIME_POINTS[TIME_POINTS %in% comparable_timepoints]
    
    if (length(comparable_timepoints) == 0) {
      return(plotly_empty() %>% 
               add_annotations(text = "No comparable timepoints across species", showarrow = FALSE))
    }
    
    data_timepoints <- comparable_timepoints
  } else {
    data_timepoints <- all_data_timepoints
  }
  
  #optional clustering of pathways (globally across all species)
  pathway_order <- all_pathways
  if (cluster_pathways && n_pathways > 1) {
    tryCatch({
      #aggregate to handle duplicates before pivot
      avg_data <- heatmap_data %>%
        group_by(Pathway, Timepoint) %>%
        summarise(AvgValue = mean(.data[[value_col]], na.rm = TRUE), .groups = 'drop')
      
      avg_matrix <- avg_data %>%
        pivot_wider(names_from = Timepoint, values_from = AvgValue, values_fn = mean) %>%
        as.data.frame()
      
      rownames(avg_matrix) <- avg_matrix$Pathway
      avg_matrix <- as.matrix(avg_matrix[, -1, drop = FALSE])
      
      if (nrow(avg_matrix) > 1 && ncol(avg_matrix) > 0) {
        avg_matrix[is.na(avg_matrix)] <- 0
        row_dist <- dist(avg_matrix)
        row_hc <- hclust(row_dist)
        pathway_order <- rownames(avg_matrix)[row_hc$order]
      }
    }, error = function(e) {
      #clustering failed, use original order
      pathway_order <- all_pathways
    })
  }
  
  #calculate dynamic grid layout
  grid_layout <- calculate_subplot_grid(n_species)
  
  #create subplot list
  subplot_list <- list()
  annotations <- list()
  
  for (i in seq_len(n_species)) {
    sp <- species_list[i]
    sp_data <- heatmap_data %>% filter(Species == sp)
    
    #aggregate duplicates before pivot (handle paralogs)
    sp_agg <- sp_data %>%
      group_by(Pathway, Timepoint) %>%
      summarise(Value = mean(.data[[value_col]], na.rm = TRUE), .groups = 'drop')
    
    #create matrix: pathways x timepoints
    heat_wide <- sp_agg %>%
      pivot_wider(names_from = Timepoint, values_from = Value, values_fn = mean)
    
    #ensure all pathways present
    missing_pathways <- setdiff(pathway_order, heat_wide$Pathway)
    if (length(missing_pathways) > 0) {
      missing_df <- data.table(Pathway = missing_pathways)
      missing_df[, (data_timepoints) := NA_real_]
      heat_wide <- rbindlist(list(as.data.table(heat_wide), missing_df), fill = TRUE)
    }
    
    #ensure all timepoints are present as columns
    for (tp in data_timepoints) {
      if (!tp %in% colnames(heat_wide)) {
        heat_wide[[tp]] <- NA_real_
      }
    }
    
    #convert to matrix with proper ordering
    heat_df <- as.data.frame(heat_wide)
    rownames(heat_df) <- heat_df$Pathway
    heat_matrix <- as.matrix(heat_df[, data_timepoints, drop = FALSE])
    
    #reorder rows to match pathway_order
    valid_pathways <- intersect(pathway_order, rownames(heat_matrix))
    if (length(valid_pathways) == 0) {
      heat_matrix <- matrix(NA, nrow = 1, ncol = length(data_timepoints))
      rownames(heat_matrix) <- "No Data"
      colnames(heat_matrix) <- data_timepoints
    } else {
      heat_matrix <- heat_matrix[valid_pathways, , drop = FALSE]
    }
    
    #mark missing data distinctly for "all" mode
    #NA values will show as gray in the heatmap
    missing_mask <- is.na(heat_matrix)
    
    #validate matrix dimensions before creating hover text
    n_rows <- nrow(heat_matrix)
    n_cols <- ncol(heat_matrix)
    
    if (n_rows == 0 || n_cols == 0) {
      heat_matrix <- matrix(NA, nrow = 1, ncol = length(data_timepoints))
      rownames(heat_matrix) <- "No Data"
      colnames(heat_matrix) <- data_timepoints
      n_rows <- 1
      n_cols <- length(data_timepoints)
    }
    
    #create hover text matrix safely
    values_display <- ifelse(
      is.na(as.vector(heat_matrix)),
      "No data",
      round(as.vector(heat_matrix), 2)
    )
    
    hover_text <- matrix(
      paste0(
        "Species: ", sp,
        "<br>Pathway: ", rep(rownames(heat_matrix), times = n_cols),
        "<br>Timepoint: ", rep(colnames(heat_matrix), each = n_rows),
        "<br>Value: ", values_display
      ),
      nrow = n_rows,
      ncol = n_cols,
      byrow = FALSE
    )
    
    #determine y-axis label visibility based on grid position
    show_y_labels <- (i - 1) %% grid_layout$ncols == 0
    
    #create heatmap with shared colorscale
    p <- plot_ly(
      z = heat_matrix,
      x = colnames(heat_matrix),
      y = rownames(heat_matrix),
      type = "heatmap",
      colorscale = list(
        list(0, "#2166AC"),
        list(0.5, "#F7F7F7"),
        list(1, "#B2182B")
      ),
      zmid = zmid_val,
      zmin = zmin_val,
      zmax = zmax_val,
      showscale = (i == 1),
      hoverinfo = "text",
      text = hover_text,
      colorbar = if(i == 1) {
        list(
          title = list(text = colorbar_title, side = "right"),
          len = 0.7,
          thickness = 15,
          x = 1.02,
          y = 0.45,
          yanchor = "middle",
          xpad = 10
        )
      } else NULL
    )
    
    p <- p %>% layout(
      xaxis = list(
        title = "",
        tickangle = -45,
        tickfont = list(size = 9),
        showticklabels = TRUE,
        side = "bottom"
      ),
      yaxis = list(
        title = "",
        autorange = "reversed",
        tickfont = list(size = 10),
        showticklabels = show_y_labels
      ),
      plot_bgcolor = plot_bg_color,
      paper_bgcolor = plot_bg_color,
      font = list(color = text_color),
      margin = list(l = if(show_y_labels) 120 else 20, r = 20, t = 50, b = 80)
    )
    
    subplot_list[[i]] <- p
    
    #use domain-relative coordinates for precise positioning
    #plotly names axes: x, y for first subplot; x2, y2 for second; etc.
    axis_suffix <- if (i == 1) "" else as.character(i)
    
    annotations[[i]] <- list(
      text = paste0("<i>", sp, "</i>"),
      xref = paste0("x", axis_suffix, " domain"),
      yref = paste0("y", axis_suffix, " domain"),
      x = 0.5,
      y = 1.08,
      xanchor = "center",
      yanchor = "bottom",
      showarrow = FALSE,
      font = list(size = 14, color = text_color)
    )
  }
  
  #calculate row heights for subplot
  row_heights <- rep(1 / grid_layout$nrows, grid_layout$nrows)
  
  #combine into dynamic grid
  combined_plot <- subplot(
    subplot_list,
    nrows = grid_layout$nrows,
    shareX = FALSE,
    shareY = FALSE,
    margin = 0.12,
    heights = row_heights
  )
  
  combined_plot <- combined_plot %>% layout(
    title = list(
      text = paste("Pathway Comparison Across Species -", 
                   ifelse(value_type == "foldchange", "Fold-Change from Baseline", "Absolute Expression")),
      font = list(size = 16, color = text_color),
      y = 0.98
    ),
    annotations = annotations,
    showlegend = FALSE,
    plot_bgcolor = plot_bg_color,
    paper_bgcolor = plot_bg_color,
    font = list(color = text_color),
    margin = list(r = 100)
  )
  
  return(combined_plot)
}

#helper function to calculate optimal subplot grid layout
calculate_subplot_grid <- function(n_species) {
  if (n_species <= 1) {
    return(list(nrows = 1, ncols = 1))
  } else if (n_species == 2) {
    return(list(nrows = 1, ncols = 2))
  } else if (n_species <= 4) {
    return(list(nrows = 2, ncols = 2))
  } else if (n_species <= 6) {
    return(list(nrows = 2, ncols = 3))
  } else if (n_species <= 9) {
    return(list(nrows = 3, ncols = 3))
  } else {
    ncols <- ceiling(sqrt(n_species))
    nrows <- ceiling(n_species / ncols)
    return(list(nrows = nrows, ncols = ncols))
  }
}

# group visualization
create_group_visualization <- function(plot_data, viz_type, is_dark_mode = FALSE,
                                     distance_method = "pearson", 
                                     linkage_method = "average",
                                     data_transform = "raw",
                                     show_significance = TRUE,
                                     alpha = 0.05,
                                     selected_gene = NULL,
                                     selected_comparisons = NULL) {
  plot_bg_color <- if(is_dark_mode) "#2c3034" else "white"
  text_color <- if(is_dark_mode) "white" else "black"
  grid_color <- if(is_dark_mode) "gray30" else "gray90"
  
  
  if (viz_type == "line") {
    # Get unique gene count for subtitle
    n_genes <- length(unique(plot_data$Gene))
    n_groups <- length(unique(plot_data$Group))
    
    p <- ggplot(plot_data, 
                aes(x = Timepoint, y = Expression, 
                    color = Gene, group = interaction(Gene, Replicate))) +
      geom_line(linewidth = 1) +
      geom_point(size = 3) +
      # Remove the facet_wrap line entirely
      labs(
        title = "Gene Set Analysis: Trajectory Plot",
        subtitle = paste("Analyzing", n_genes, "genes across", n_groups, 
                         if(n_groups == 1) "group" else "groups"),
        x = "Timepoint",
        y = "log2 count per million"
      ) +
      theme_minimal()
    
    # Apply theme
    p <- p + theme(
      text = element_text(color = text_color),
      axis.text.x = element_text(angle = 45, hjust = 1, color = text_color),
      axis.text.y = element_text(color = text_color),
      plot.title = element_text(size = 14, face = "bold", color = text_color),
      panel.grid.major = element_line(color = grid_color),
      panel.grid.minor = element_line(color = ifelse(is_dark_mode, "gray20", "gray95")),
      plot.background = element_rect(fill = plot_bg_color, color = NA),
      panel.background = element_rect(fill = plot_bg_color, color = NA),
      legend.background = element_rect(fill = plot_bg_color),
      legend.text = element_text(color = text_color),
      legend.title = element_text(color = text_color),
      strip.background = element_rect(fill = plot_bg_color),
      strip.text = element_text(color = text_color)
    )
    
    return(ggplotly(p) %>%
             layout(
               plot_bgcolor = plot_bg_color,
               paper_bgcolor = plot_bg_color,
               font = list(color = text_color),
               hoverlabel = list(bgcolor = if(is_dark_mode) "#444" else "white"),
               showlegend = TRUE
             ))
    
  } else if (viz_type == "bar") {
    summary_data <- plot_data %>%
      group_by(Timepoint, Group, Gene) %>%
      summarise(Mean = mean(Expression), .groups = 'drop')
    
    p <- ggplot(summary_data, aes(x = Timepoint, y = Mean, fill = Gene)) +
      geom_bar(stat = "identity", position = "dodge") +
      facet_wrap(~Group) +
      theme_minimal()
    
    # Apply theme
    p <- p + theme(
      text = element_text(color = text_color),
      axis.text.x = element_text(angle = 45, hjust = 1, color = text_color),
      axis.text.y = element_text(color = text_color),
      plot.title = element_text(size = 14, face = "bold", color = text_color),
      panel.grid.major = element_line(color = grid_color),
      panel.grid.minor = element_line(color = ifelse(is_dark_mode, "gray20", "gray95")),
      plot.background = element_rect(fill = plot_bg_color, color = NA),
      panel.background = element_rect(fill = plot_bg_color, color = NA),
      legend.background = element_rect(fill = plot_bg_color),
      legend.text = element_text(color = text_color),
      legend.title = element_text(color = text_color),
      strip.background = element_rect(fill = plot_bg_color),
      strip.text = element_text(color = text_color)
    )
    
    # Add significance markers if requested
    if (show_significance && !is.null(selected_gene) && !is.null(selected_comparisons) && length(selected_comparisons) > 0) {
      # Calculate significance
      sig_results <- calculate_significance(
        plot_data, 
        alpha, 
        selected_gene, 
        selected_comparisons
      )
      
      # Add significance annotations if we have results
      if (length(sig_results) > 0) {
        # Convert significance results to a data frame for ggplot
        sig_data <- data.frame(
          Gene = sapply(sig_results, function(x) x$gene),
          Group = sapply(sig_results, function(x) unique(plot_data$Group[plot_data$Gene == x$gene])[1]),
          Timepoint1 = sapply(sig_results, function(x) x$timepoint1),
          Timepoint2 = sapply(sig_results, function(x) x$timepoint2),
          YPosition = sapply(sig_results, function(x) x$y_position),
          Significance = sapply(sig_results, function(x) x$significance),
          stringsAsFactors = FALSE
        )
        
        # For each group-gene combination, add significance markers
        for (g in unique(sig_data$Group)) {
          for (gene in unique(sig_data$Gene[sig_data$Group == g])) {
            gene_sig <- sig_data[sig_data$Group == g & sig_data$Gene == gene, ]
            
            for (i in 1:nrow(gene_sig)) {
              # Get positions for timepoints
              pos1 <- which(levels(summary_data$Timepoint) == gene_sig$Timepoint1[i])
              pos2 <- which(levels(summary_data$Timepoint) == gene_sig$Timepoint2[i])
              
              # Calculate bar positions accounting for dodge position
              dodge_width <- 0.9  # default dodge width
              gene_pos <- which(unique(summary_data$Gene) == gene) - 1
              num_genes <- length(unique(summary_data$Gene))
              bar_width <- dodge_width / num_genes
              
              # Adjusted positions
              x1 <- pos1 - dodge_width/2 + bar_width/2 + gene_pos * bar_width
              x2 <- pos2 - dodge_width/2 + bar_width/2 + gene_pos * bar_width
              
              # Draw bracket and significance marker
              p <- p + 
                geom_segment(
                  data = data.frame(
                    Group = g,
                    x = x1,
                    xend = x2,
                    y = gene_sig$YPosition[i],
                    yend = gene_sig$YPosition[i]
                  ),
                  aes(x = x, y = y, xend = xend, yend = yend),
                  inherit.aes = FALSE
                ) +
                # Vertical segments at each end
                geom_segment(
                  data = data.frame(
                    Group = g,
                    x = x1,
                    xend = x1,
                    y = gene_sig$YPosition[i] - 0.2,
                    yend = gene_sig$YPosition[i]
                  ),
                  aes(x = x, y = y, xend = xend, yend = yend),
                  inherit.aes = FALSE
                ) +
                geom_segment(
                  data = data.frame(
                    Group = g,
                    x = x2,
                    xend = x2,
                    y = gene_sig$YPosition[i] - 0.2,
                    yend = gene_sig$YPosition[i]
                  ),
                  aes(x = x, y = y, xend = xend, yend = yend),
                  inherit.aes = FALSE
                ) +
                # Significance text
                geom_text(
                  data = data.frame(
                    Group = g,
                    x = (x1 + x2) / 2,
                    y = gene_sig$YPosition[i] + 0.2,
                    label = gene_sig$Significance[i]
                  ),
                  aes(x = x, y = y, label = label),
                  inherit.aes = FALSE,
                  size = 3
                )
            }
          }
        }
      }
    }
    
    # Convert to plotly with adjusted layout
    return(ggplotly(p) %>%
             layout(
               plot_bgcolor = plot_bg_color,
               paper_bgcolor = plot_bg_color,
               font = list(color = text_color),
               hoverlabel = list(bgcolor = if(is_dark_mode) "#444" else "white"),
               showlegend = TRUE
             ))
    
  } else if (viz_type == "heatmap") {
    # Prepare data for heatmap
    heatmap_data <- plot_data %>%
      group_by(Gene, Timepoint) %>%
      summarise(Expression = mean(Expression), .groups = 'drop') %>%
      pivot_wider(names_from = Timepoint, values_from = Expression)
    
    # Extract gene names and create expression matrix
    gene_names <- heatmap_data$Gene
    expression_matrix <- as.matrix(heatmap_data[, -1])
    rownames(expression_matrix) <- gene_names
    
    # Apply data transformation
    transformed_matrix <- switch(data_transform,
                                 "raw" = expression_matrix,
                                 "centered" = t(scale(t(expression_matrix), center = TRUE, scale = FALSE)),
                                 "zscore" = t(scale(t(expression_matrix), center = TRUE, scale = TRUE)),
                                 expression_matrix
    )
    
    # Apply clustering if there's more than one gene
    if (nrow(transformed_matrix) > 1) {
      if (distance_method == "euclidean") {
        # Euclidean distance clustering
        dist_matrix <- dist(transformed_matrix, method = "euclidean")
        hclust_result <- hclust(dist_matrix, method = linkage_method)
        row_order <- hclust_result$order
      } else if (distance_method == "pearson") {
        # Pearson correlation distance (1 - correlation)
        cor_matrix <- cor(t(transformed_matrix))
        dist_matrix <- as.dist(1 - cor_matrix)
        hclust_result <- hclust(dist_matrix, method = linkage_method)
        row_order <- hclust_result$order
      } else {
        # No clustering
        row_order <- 1:nrow(transformed_matrix)
      }
      
      # Reorder matrix according to clustering
      transformed_matrix <- transformed_matrix[row_order, ]
    }
    
    # Set plot parameters based on transformation
    plot_params <- switch(data_transform,
                          "raw" = list(
                            zmid = mean(range(transformed_matrix)),
                            zmin = min(transformed_matrix),
                            zmax = max(transformed_matrix),
                            title = "Raw log2CPM"
                          ),
                          "centered" = list(
                            zmid = 0,
                            zmin = -2,
                            zmax = 2,
                            title = "Centered log2CPM"
                          ),
                          "zscore" = list(
                            zmid = 0,
                            zmin = -2,
                            zmax = 2,
                            title = "Z-score"
                          ),
                          list(
                            zmid = mean(range(transformed_matrix)),
                            zmin = min(transformed_matrix),
                            zmax = max(transformed_matrix),
                            title = "Expression Values"
                          )
    )
    
    # Create heatmap with clustering info in title
    p <- plot_ly(
      z = transformed_matrix,
      x = colnames(transformed_matrix),
      y = rownames(transformed_matrix),
      type = "heatmap",
      colorscale = list(
        c(0, "#0000FF"),
        c(0.5, "#000000"),
        c(1, "#FFFF00")
      ),
      zmid = plot_params$zmid,
      zmin = plot_params$zmin,
      zmax = plot_params$zmax,
      hoverinfo = "text",
      text = matrix(
        paste(
          "Gene:", rep(rownames(transformed_matrix), each = ncol(transformed_matrix)),
          "<br>Time:", rep(colnames(transformed_matrix), times = nrow(transformed_matrix)),
          "<br>Value:", round(as.vector(t(transformed_matrix)), 2)
        ),
        nrow = nrow(transformed_matrix),
        ncol = ncol(transformed_matrix),
        byrow = TRUE
      )
    ) %>%
      layout(
        title = paste("Gene Expression Heatmap -", plot_params$title, 
                      "<br><sub>Clustering:", 
                      if(nrow(transformed_matrix) > 1) paste(distance_method, "distance") else "None",
                      "</sub>"),
        xaxis = list(
          title = "Timepoint",
          tickangle = -45
        ),
        yaxis = list(
          title = "Gene",
          autorange = "reversed"
        ),
        plot_bgcolor = plot_bg_color,
        paper_bgcolor = plot_bg_color,
        font = list(color = text_color)
      )
    
    return(p)
  }
}

# Create summary table
create_group_summary_table <- function(plot_data, species_name = NULL) {
  summary_data <- plot_data %>%
    group_by(Group, Gene) %>%
    summarise(
      Mean_Expression = mean(Expression),
      Max_Expression = max(Expression),
      Min_Expression = min(Expression),
      .groups = 'drop'
    )
  
  # Replace "Custom Group" with species-specific name
  if (!is.null(species_name) && "Custom Group" %in% summary_data$Group) {
    summary_data$Group[summary_data$Group == "Custom Group"] <- paste(species_name, "Gene Set")
  }
  
  datatable(
    summary_data,
    options = list(
      pageLength = 10,
      scrollX = TRUE,
      dom = 'tp'
    ),
    rownames = FALSE
  )
}

#aggregate HOG expression across paralogs using various methods
aggregate_hog_expression <- function(expr_matrix, method = "eigengene") {
  #expr_matrix: genes (paralogs)  samples
  
  if (nrow(expr_matrix) == 1) {
    return(as.numeric(expr_matrix[1, ]))
  }
  
  if (nrow(expr_matrix) == 0) {
    return(NULL)
  }
  
  switch(method,
         "mean" = colMeans(expr_matrix, na.rm = TRUE),
         
         "median" = apply(expr_matrix, 2, median, na.rm = TRUE),
         
         "eigengene" = {
           #WGCNA-style: PC1 of expression matrix
           #validate we have multiple samples for eigengene computation
           if (ncol(expr_matrix) < 2) {
             warning("eigengene requires multiple samples (received ", ncol(expr_matrix), 
                     " sample). falling back to mean.")
             return(colMeans(expr_matrix, na.rm = TRUE))
           }
           
           #center and scale each gene first
           expr_scaled <- t(scale(t(expr_matrix), center = TRUE, scale = TRUE))
           
           #remove any genes with zero variance
           gene_vars <- apply(expr_scaled, 1, var, na.rm = TRUE)
           if (sum(gene_vars > 0, na.rm = TRUE) == 0) {
             return(colMeans(expr_matrix, na.rm = TRUE))
           }
           expr_scaled <- expr_scaled[gene_vars > 0, , drop = FALSE]
           
           #check if we still have multiple genes after filtering
           if (nrow(expr_scaled) < 2) {
             warning("only one gene with variance. using that gene.")
             return(as.numeric(expr_scaled[1, ]))
           }
           
           #PCA on genes to get first PC as eigengene
           pca <- tryCatch({
             prcomp(t(expr_scaled), center = FALSE, scale. = FALSE)
           }, error = function(e) {
             warning("PCA failed: ", e$message, ". falling back to mean.")
             return(NULL)
           })
           
           if (is.null(pca)) {
             return(colMeans(expr_matrix, na.rm = TRUE))
           }
           
           eigengene <- pca$x[, 1]
           
           #orient eigengene to have positive correlation with mean expression
           mean_expr <- colMeans(expr_matrix, na.rm = TRUE)
           if (cor(eigengene, mean_expr, use = "complete.obs") < 0) {
             eigengene <- -eigengene
           }
           
           #store variance explained as attribute
           var_explained <- (pca$sdev[1]^2 / sum(pca$sdev^2)) * 100
           attr(eigengene, "var_explained") <- var_explained
           attr(eigengene, "n_paralogs") <- nrow(expr_matrix)
           
           eigengene
         },
         
         "max_expr" = {
           #paralog with highest mean expression
           mean_exprs <- rowMeans(expr_matrix, na.rm = TRUE)
           best_idx <- which.max(mean_exprs)
           as.numeric(expr_matrix[best_idx, ])
         },
         
         "max_var" = {
           #paralog with highest variance
           gene_vars <- apply(expr_matrix, 1, var, na.rm = TRUE)
           best_idx <- which.max(gene_vars)
           as.numeric(expr_matrix[best_idx, ])
         },
         
         "var_weighted" = {
           #variance-weighted mean
           gene_vars <- apply(expr_matrix, 1, var, na.rm = TRUE)
           if (sum(gene_vars, na.rm = TRUE) == 0) {
             return(colMeans(expr_matrix, na.rm = TRUE))
           }
           weights <- gene_vars / sum(gene_vars, na.rm = TRUE)
           colSums(expr_matrix * weights, na.rm = TRUE)
         },
         
         stop("Unknown aggregation method")
  )
}


#single-species PCA plot
create_pca_plot <- function(expression_matrix, sample_info, is_dark_mode = FALSE) {
  debug_print("Starting PCA plot creation")
  debug_print(paste("Expression matrix dimensions:", nrow(expression_matrix), "x", ncol(expression_matrix)))
  debug_print(paste("Sample info rows:", nrow(sample_info)))
  
  if (!is.matrix(expression_matrix) && !is.data.frame(expression_matrix)) {
    stop("Expression matrix must be a matrix or data frame")
  }
  
  if (is.data.frame(expression_matrix)) {
    expression_matrix <- as.matrix(expression_matrix)
  }
  
  #filter genes with zero variance
  debug_print("Calculating gene variances")
  var_genes <- apply(expression_matrix, 1, var)
  expression_matrix <- expression_matrix[var_genes > 0, , drop = FALSE]
  debug_print(paste("Genes after variance filtering:", nrow(expression_matrix)))
  
  #transpose for PCA (samples as rows)
  debug_print("Transposing matrix")
  mat <- t(expression_matrix)
  debug_print(paste("Transposed matrix dimensions:", nrow(mat), "x", ncol(mat)))
  
  #run PCA with centering
  debug_print("Running PCA")
  pca_res <- prcomp(mat, scale. = FALSE, center = TRUE)
  
  #calculate variance explained
  var_explained <- (pca_res$sdev^2 / sum(pca_res$sdev^2)) * 100
  debug_print(paste("Variance explained PC1:", round(var_explained[1], 2), "%"))
  debug_print(paste("Variance explained PC2:", round(var_explained[2], 2), "%"))
  
  debug_print("Creating plot data frame")
  pca_data <- data.frame(
    PC1 = pca_res$x[, 1],
    PC2 = pca_res$x[, 2],
    Sample = rownames(pca_res$x)
  )
  
  debug_print("Merging with sample info")
  pca_data <- merge(pca_data, sample_info, by = "Sample", all.x = TRUE)
  debug_print(paste("Final data frame rows:", nrow(pca_data)))
  
  pca_data$Timepoint <- factor(pca_data$Timepoint, levels = TIME_POINTS)
  
  #precompute plot styling
  plot_bg_color <- if(is_dark_mode) "#2c3034" else "white"
  text_color <- if(is_dark_mode) "white" else "black"
  grid_color <- if(is_dark_mode) "gray30" else "gray90"
  minor_grid_color <- if(is_dark_mode) "gray20" else "gray95"
  
  debug_print("Creating ggplot with viridis colors")
  p <- ggplot(pca_data, aes(x = PC1, y = PC2, color = Timepoint, text = Sample)) +
    geom_point(size = 3) +
    # this is where viridis is
    scale_color_viridis(discrete = TRUE, option = "viridis") +
    labs(
      x = sprintf("PC1 (%.1f%%)", var_explained[1]),
      y = sprintf("PC2 (%.1f%%)", var_explained[2]),
      title = paste("PCA of Gene Expression Data -", ifelse(input$global_transform == "rlog", "rlog", "TMM+log2CPM"))
    ) +
    theme_minimal() +
    theme(
      text = element_text(color = text_color),
      axis.text = element_text(color = text_color),
      plot.title = element_text(size = 14, face = "bold", color = text_color),
      panel.grid.major = element_line(color = grid_color),
      panel.grid.minor = element_line(color = minor_grid_color),
      plot.background = element_rect(fill = plot_bg_color, color = NA),
      panel.background = element_rect(fill = plot_bg_color, color = NA),
      legend.background = element_rect(fill = plot_bg_color),
      legend.text = element_text(color = text_color),
      legend.title = element_text(color = text_color)
    )
  
  # converts to plotly output
  debug_print("Converting to plotly")
  plot <- plotly::ggplotly(p, tooltip = c("Sample", "Timepoint")) %>%
    layout(
      plot_bgcolor = plot_bg_color,
      paper_bgcolor = plot_bg_color,
      font = list(color = text_color),
      showlegend = TRUE,
      legend = list(bgcolor = plot_bg_color),
      margin = list(t = 50, r = 20, b = 50, l = 50)
    ) %>%
    config(
      displayModeBar = TRUE,
      modeBarButtons = list(
        list("zoom2d", "pan2d", "resetScale2d", "toImage")
      )
    )
  
  debug_print("PCA plot creation completed")
  return(plot)
}

#pre-aggregate HOG expression for a single species across all samples
preaggregate_species_hogs <- function(lcpm_matrix, species_hog_map, common_hogs, 
                                      aggregation_method = "eigengene", species_code = NULL) {
  #returns named list: hog_expr[[hog_id]] = vector of expression values (one per sample)
  
  hog_expr <- list()
  
  for (hog in common_hogs) {
    gene_ids <- species_hog_map[[hog]]
    
    if (is.null(gene_ids) || length(gene_ids) == 0) {
      hog_expr[[hog]] <- NULL
      next
    }
    
    #try alternative gene ID formats
    gene_ids_to_use <- sapply(gene_ids, function(gene_id) {
      if (gene_id %in% rownames(lcpm_matrix)) {
        return(gene_id)
      }
      #try removing transcript suffix
      gene_id_alt <- sub("(\\.[0-9]+)$", "", gene_id)
      if (gene_id_alt %in% rownames(lcpm_matrix)) {
        return(gene_id_alt)
      }
      #try K. lactis underscore pattern
      if (!is.null(species_code) && species_code == "kl") {
        gene_id_alt <- gsub("^(KLLA0)(.*)", "\\1_\\2", gene_id)
        if (gene_id_alt %in% rownames(lcpm_matrix)) {
          return(gene_id_alt)
        }
      }
      return(gene_id)
    })
    
    #get valid genes
    valid_genes <- gene_ids_to_use[gene_ids_to_use %in% rownames(lcpm_matrix)]
    
    if (length(valid_genes) == 0) {
      hog_expr[[hog]] <- NULL
    } else if (length(valid_genes) == 1) {
      #single-copy: extract directly
      hog_expr[[hog]] <- lcpm_matrix[valid_genes[1], ]
    } else {
      #multi-copy: aggregate across ALL samples at once
      paralog_expr <- lcpm_matrix[valid_genes, , drop = FALSE]
      aggregated <- aggregate_hog_expression(paralog_expr, method = aggregation_method)
      hog_expr[[hog]] <- aggregated
    }
  }
  
  return(hog_expr)
}

create_multi_species_pca <- function(get_species_data, is_dark_mode = FALSE, aggregation_method = "eigengene", species_config = DEFAULT_SPECIES_CONFIG, all_species_data_obj = NULL, transform_type = "lcpm", debug = FALSE) {
  
  method_label <- switch(aggregation_method,
                         "single_only" = "SINGLE-COPY GENES ONLY",
                         "mean" = "MEAN AGGREGATION",
                         "median" = "MEDIAN AGGREGATION", 
                         "eigengene" = "EIGENGENE AGGREGATION",
                         "max_expr" = "HIGHEST EXPRESSION SELECTION",
                         "max_var" = "HIGHEST VARIANCE SELECTION",
                         "var_weighted" = "VARIANCE-WEIGHTED MEAN",
                         "UNKNOWN METHOD"
  )
  
  if (debug) message(paste("PCA: Starting with", method_label))
  
  config <- species_config
  current_data <- if (!is.null(all_species_data_obj)) all_species_data_obj else all_species_data
  
  #get data and CACHE expression matrices upfront
  species_data_list <- list()
  expression_matrix_cache <- list()
  sample_info_cache <- list()
  
  for (species_id in names(config)) {
    sp_data <- get_species_data(species_id)
    species_data_list[[species_id]] <- sp_data
    
    if (!is.null(sp_data)) {
      expression_matrix_cache[[species_id]] <- get_expression_matrix(species_id, transform_type, sp_data)
      sample_info_cache[[species_id]] <- if (!is.null(sp_data$sample_info)) sp_data$sample_info else sp_data[[paste0(species_id, "_sample_info")]]
    }
  }
  
  # Get HOG data
  og_data <- current_data$orthofinder$orthogroups
  
  #pre-compute HOG-to-gene lookup table
  lookup_table <- current_data$gene_lookup
  hog_gene_map <- og_data %>%
    left_join(lookup_table[, .(gene_id, species)], by = "gene_id") %>%
    filter(!is.na(species)) %>%
    mutate(species = as.character(species)) %>%
    filter(species != "unknown") %>%
    split(.$hog_id) %>%
    lapply(function(hog_df) {
      split(hog_df$gene_id, hog_df$species)
    })
  if (debug) message(paste("PCA: Lookup table created with", length(hog_gene_map), "HOGs"))
  
  #filter or aggregate based on method
  if (aggregation_method == "single_only") {
    #find HOGs that have exactly one gene in each species that has representation
    single_copy_hogs <- names(hog_gene_map)[sapply(hog_gene_map, function(hog) {
      #check if all species present have exactly 1 gene
      gene_counts <- sapply(hog, length)
      #must have at least 2 species and all must be single-copy
      length(gene_counts) >= 2 && all(gene_counts == 1)
    })]
    
    if (debug) {
      message(paste("PCA: Found", length(single_copy_hogs), "single-copy HOGs"))
      #stats calculations only when debugging
      four_species_single <- sum(sapply(hog_gene_map[single_copy_hogs], function(hog) length(hog) == 4))
      three_species_single <- sum(sapply(hog_gene_map[single_copy_hogs], function(hog) length(hog) == 3))
      two_species_single <- sum(sapply(hog_gene_map[single_copy_hogs], function(hog) length(hog) == 2))
      message(paste("  -", four_species_single, "in all 4 species"))
      message(paste("  -", three_species_single, "in 3 species"))
      message(paste("  -", two_species_single, "in 2 species"))
    }
    
    #use all single-copy HOGs
    common_hogs <- single_copy_hogs
  } else {
    #use all HOGs with at least 2 species represented
    common_hogs <- names(hog_gene_map)[sapply(hog_gene_map, function(hog) {
      length(hog) >= 2
    })]
    
    if (debug) {
      message(paste("PCA: Found", length(common_hogs), "HOGs with at least 2 species"))
      single_copy_count <- sum(sapply(hog_gene_map[common_hogs], function(hog) {
        all(sapply(hog, length) == 1)
      }))
      message(paste("  -", single_copy_count, "single-copy,", length(common_hogs) - single_copy_count, "multi-copy"))
    }
  }
  
  # Check if we have any HOGs
  if (length(common_hogs) == 0) {
    error_msg <- "No single-copy HOGs found across species. Cannot perform PCA."
    showNotification(error_msg, type = "error")
    return(plotly_empty() %>% 
             add_annotations(text = error_msg, showarrow = FALSE))
  }
  
  #create sample metadata using cached data
  sample_metadata_list <- list()
  
  for (species_id in names(config)) {
    lcpm_matrix <- expression_matrix_cache[[species_id]]
    sample_info <- sample_info_cache[[species_id]]
    
    if (!is.null(lcpm_matrix) && !is.null(sample_info)) {
      sample_metadata_list[[species_id]] <- data.frame(
        Sample = colnames(lcpm_matrix),
        Species = config[[species_id]]$short,
        Timepoint = sample_info$Timepoint,
        Replicate = sample_info$Replicate,
        stringsAsFactors = FALSE
      )
    }
  }
  
  sample_metadata <- rbindlist(sample_metadata_list, fill = TRUE)
  if (debug) message(paste("PCA: Total samples:", nrow(sample_metadata)))
  
  # Create expression matrix based on single-copy HOGs
  sample_matrix <- matrix(NA, 
                          nrow = nrow(sample_metadata), 
                          ncol = length(common_hogs))
  rownames(sample_matrix) <- sample_metadata$Sample
  colnames(sample_matrix) <- common_hogs
  
  # Track successful matches by species
  matches_by_species <- list(cg = 0, sc = 0, kl = 0, ca = 0)
  
  #track aggregation statistics
  aggregation_stats <- list()
  for (sp_code in names(config)) {
    aggregation_stats[[sp_code]] <- list(
      single_copy = 0,
      multi_copy = 0,
      total_hogs = 0
    )
  }
  
  #count single vs multi-copy for each species across all HOGs
  for (hog in common_hogs) {
    if (!is.null(hog_gene_map[[hog]])) {
      for (sp_code in names(config)) {
        if (!is.null(hog_gene_map[[hog]][[sp_code]])) {
          gene_count <- length(hog_gene_map[[hog]][[sp_code]])
          aggregation_stats[[sp_code]]$total_hogs <- aggregation_stats[[sp_code]]$total_hogs + 1
          
          if (gene_count == 1) {
            aggregation_stats[[sp_code]]$single_copy <- aggregation_stats[[sp_code]]$single_copy + 1
          } else if (gene_count > 1) {
            aggregation_stats[[sp_code]]$multi_copy <- aggregation_stats[[sp_code]]$multi_copy + 1
          }
        }
      }
    }
  }
  
  if (debug) {
    message("PCA: HOG composition by species:")
    for (sp_code in names(aggregation_stats)) {
      stats <- aggregation_stats[[sp_code]]
      message(paste("  ", sp_code, ": ", stats$total_hogs, " HOGs (", 
                    stats$single_copy, " single, ", stats$multi_copy, " multi)", sep = ""))
    }
  }
  
  #pre-aggregate HOGs per species using cached matrices
  species_hog_expr <- list()
  
  for (species_id in names(config)) {
    lcpm_matrix <- expression_matrix_cache[[species_id]]
    if (is.null(lcpm_matrix)) next
    
    if (debug) message(paste("PCA: pre-aggregating", species_id, "-", nrow(lcpm_matrix), "genes"))
    
    #build species HOG map
    species_hog_map <- lapply(hog_gene_map[common_hogs], function(hog) {
      if (!is.null(hog[[species_id]])) hog[[species_id]] else NULL
    })
    names(species_hog_map) <- common_hogs
    
    #aggregate HOGs using cached matrix
    species_hog_expr[[species_id]] <- preaggregate_species_hogs(
      lcpm_matrix = lcpm_matrix,
      species_hog_map = species_hog_map,
      common_hogs = common_hogs,
      aggregation_method = aggregation_method,
      species_code = species_id
    )
  }
  
  #prebuild species code lookup
  species_short_to_code <- setNames(names(config), sapply(config, `[[`, "short"))
  species_name_to_code <- setNames(names(config), sapply(config, `[[`, "name"))
  
  #fill matrix using pre-aggregated values
  for (i in 1:nrow(sample_metadata)) {
    sample_name <- sample_metadata$Sample[i]
    species <- sample_metadata$Species[i]
    
    #find species code via lookup
    species_code <- if (species %in% names(species_short_to_code)) {
      species_short_to_code[[species]]
    } else if (species %in% names(species_name_to_code)) {
      species_name_to_code[[species]]
    } else {
      NULL
    }
    
    if (is.null(species_code)) next
    if (is.null(species_hog_expr[[species_code]])) next
    
    lcpm_matrix <- expression_matrix_cache[[species_code]]
    
    if (is.null(lcpm_matrix)) next
    if (!sample_name %in% colnames(lcpm_matrix)) next
    
    sample_idx <- which(colnames(lcpm_matrix) == sample_name)
    
    #fill HOG values from pre-aggregated data
    for (j in seq_along(common_hogs)) {
      hog <- common_hogs[j]
      
      if (!is.null(species_hog_expr[[species_code]][[hog]])) {
        sample_matrix[i, j] <- species_hog_expr[[species_code]][[hog]][sample_idx]
        matches_by_species[[species_code]] <- matches_by_species[[species_code]] + 1
      }
    }
  }
  
  if (debug) {
    message("PCA: Match statistics by species:")
    for (sp in names(matches_by_species)) {
      message(paste(sp, ":", matches_by_species[[sp]], "HOG values filled"))
    }
  }
  
  #check how many NAs we have
  total_nas <- sum(is.na(sample_matrix))
  total_cells <- nrow(sample_matrix) * ncol(sample_matrix)
  
  #remove columns (HOGs) with too many NAs (more than 50% missing)
  na_proportion <- apply(sample_matrix, 2, function(x) sum(is.na(x)) / length(x))
  keep_cols <- na_proportion < 0.5
  
  if (debug) {
    message(paste("PCA: NAs:", total_nas, "/", total_cells, "(", round(100 * total_nas / total_cells, 1), "%)"))
    message(paste("PCA: HOGs >50% missing:", sum(!keep_cols), ", complete:", sum(na_proportion == 0)))
  }
  
  if (sum(keep_cols) < 2) {  # Need at least 2 HOGs for PCA
    error_msg <- "Too few single-copy HOGs with sufficient data. Cannot perform PCA."
    showNotification(error_msg, type = "error")
    return(plotly_empty() %>% 
             add_annotations(text = error_msg, showarrow = FALSE))
  }
  
  sample_matrix <- sample_matrix[, keep_cols, drop = FALSE]
  debug_print(paste("Using", sum(keep_cols), "single-copy HOGs for PCA"))
  
  #remove samples with all NAs
  row_has_data <- apply(sample_matrix, 1, function(x) !all(is.na(x)))
  if (sum(row_has_data) < nrow(sample_matrix)) {
    debug_print(paste("Removing", sum(!row_has_data), "samples with no data"))
    sample_matrix <- sample_matrix[row_has_data, , drop = FALSE]
    sample_metadata <- sample_metadata[row_has_data, , drop = FALSE]
  }
  
  #impute NAs with column means (vectorized)
  debug_print("Imputing missing values")
  col_means <- colMeans(sample_matrix, na.rm = TRUE)
  na_matrix <- is.na(sample_matrix)
  imputed_count <- sum(na_matrix)
  
  for (j in which(colSums(na_matrix) > 0)) {
    sample_matrix[na_matrix[, j], j] <- col_means[j]
  }
  debug_print(paste("Imputed", imputed_count, "missing values with column means"))
  
  #remove all-NA columns
  valid_cols <- !is.na(col_means)
  sample_matrix <- sample_matrix[, valid_cols, drop = FALSE]
  
  debug_print(paste("Final matrix dimensions:", nrow(sample_matrix), "x", ncol(sample_matrix)))
  
  # Final check before PCA
  if (ncol(sample_matrix) < 2 || nrow(sample_matrix) < 3) {
    showNotification("Insufficient valid data for PCA", type = "error")
    return(plotly_empty() %>% 
             add_annotations(text = "Not enough valid single-copy orthogroups for analysis",
                             showarrow = FALSE))
  }
  
  # Run PCA
  debug_print("Running PCA on single-copy HOG matrix")
  
  tryCatch({
    # Run PCA with scaling and centering
    pca_result <- prcomp(sample_matrix, scale. = TRUE, center = TRUE)
    var_explained <- (pca_result$sdev^2 / sum(pca_result$sdev^2)) * 100
    
    debug_print(paste("PCA successful. PC1 explains", round(var_explained[1], 1), "% variance"))
    debug_print(paste("PC2 explains", round(var_explained[2], 1), "% variance"))
    debug_print(paste("First 5 PCs explain", round(sum(var_explained[1:min(5, length(var_explained))]), 1), "% total variance"))
    
    # Create plotting data
    plot_data <- data.frame(
      PC1 = pca_result$x[, 1],
      PC2 = pca_result$x[, 2],
      Sample = rownames(pca_result$x)
    )
    
    # Add metadata
    plot_data <- merge(plot_data, sample_metadata, by = "Sample")
    plot_data$Timepoint <- factor(plot_data$Timepoint, levels = TIME_POINTS)
    
    # Set plot styling
    plot_bg_color <- if(is_dark_mode) "#2c3034" else "white"
    text_color <- if(is_dark_mode) "white" else "black"
    grid_color <- if(is_dark_mode) "gray30" else "gray90"
    
    # Create plot
    p <- ggplot(plot_data, aes(x = PC1, y = PC2, 
                               color = Timepoint,
                               shape = Species,
                               text = paste0("Sample: ", Sample, 
                                             "<br>Species: ", Species, 
                                             "<br>Timepoint: ", Timepoint))) +
      geom_point(size = 4, alpha = 0.8) +
      scale_color_viridis(discrete = TRUE, option = "viridis") +
      scale_shape_manual(values = c(16, 17, 15, 18)) +
      labs(
        x = sprintf("PC1 (%.1f%%)", var_explained[1]),
        y = sprintf("PC2 (%.1f%%)", var_explained[2]),
        title = paste("PCA of HOG Expression Across Species -", method_label),
        subtitle = paste(ncol(sample_matrix), "HOGs compared across", 
                         length(unique(plot_data$Species)), "species",
                         if(aggregation_method != "single_only") {
                           paste("(", sum(sapply(aggregation_stats, function(x) x$multi_copy)), 
                                 "multi-copy HOGs aggregated)")
                         } else "")
      ) +
      theme_minimal() +
      theme(
        text = element_text(color = text_color),
        axis.text = element_text(color = text_color),
        plot.title = element_text(size = 14, face = "bold", color = text_color),
        plot.subtitle = element_text(size = 12, color = text_color),
        panel.grid.major = element_line(color = grid_color),
        panel.grid.minor = element_line(color = if(is_dark_mode) "gray20" else "gray95"),
        plot.background = element_rect(fill = plot_bg_color, color = NA),
        panel.background = element_rect(fill = plot_bg_color, color = NA),
        legend.background = element_rect(fill = plot_bg_color),
        legend.text = element_text(color = text_color),
        legend.title = element_text(color = text_color)
      )
    
    # Store matrices data for download
    matrices_data <- list(
      sample_matrix = sample_matrix,
      sample_metadata = sample_metadata,
      common_hogs = colnames(sample_matrix),
      method = aggregation_method,
      aggregation_stats = if(aggregation_method != "single_only") aggregation_stats else NULL,
      pca_result = pca_result,
      var_explained = var_explained
    )
    
    attr(p, "matrices_data") <- matrices_data
    
    # Convert to plotly
    plot <- plotly::ggplotly(p, tooltip = "text") %>%
      layout(
        plot_bgcolor = plot_bg_color,
        paper_bgcolor = plot_bg_color,
        font = list(color = text_color),
        hoverlabel = list(
          bgcolor = if(is_dark_mode) "#444" else "white",
          bordercolor = "white"
        )
      ) %>%
      config(displayModeBar = TRUE)
    
    attr(plot, "matrices_data") <- matrices_data
    
    debug_print("PCA plot created successfully")
    return(plot)
    
  }, error = function(e) {
    debug_print(paste("Error in PCA:", e$message))
    debug_print("Debug info:")
    debug_print(paste("Matrix has", sum(!is.na(sample_matrix)), "non-NA values"))
    debug_print(paste("Matrix variance:", var(as.vector(sample_matrix), na.rm = TRUE)))
    
    showNotification(paste("PCA failed:", e$message), type = "error")
    return(plotly_empty() %>% 
             add_annotations(text = paste("PCA Error:", e$message),
                             showarrow = FALSE))
  })
}
# used for the bar-graph visualization in gene groups 
calculate_significance <- function(plot_data, alpha = 0.05, selected_gene = NULL, selected_comparisons = NULL) {
  # If no gene or comparisons selected, return empty list
  if (is.null(selected_gene) || is.null(selected_comparisons) || length(selected_comparisons) == 0) {
    return(list())
  }
  
  # Filter data for the selected gene
  gene_data <- plot_data[plot_data$Gene == selected_gene, ]
  if (nrow(gene_data) == 0) {
    return(list())
  }
  
  timepoints <- levels(plot_data$Timepoint)
  sig_results <- list()
  
  # Process each selected comparison
  for (comparison in selected_comparisons) {
    # Parse the comparison string
    t_pair <- strsplit(comparison, " vs. ")[[1]]
    t1 <- t_pair[1]
    t2 <- t_pair[2]
    
    # Extract data for these timepoints
    t1_data <- gene_data$Expression[gene_data$Timepoint == t1]
    t2_data <- gene_data$Expression[gene_data$Timepoint == t2]
    
    # Only test if we have enough data points (at least 2 replicates)
    if (length(t1_data) >= 2 && length(t2_data) >= 2) {
      # Perform t-test
      test_result <- t.test(t1_data, t2_data)
      p_value <- test_result$p.value
      
      # Determine significance level
      significance <- "ns"
      if (p_value < 0.001) significance <- "***"
      else if (p_value < 0.01) significance <- "**" 
      else if (p_value < 0.05) significance <- "*"
      
      # Add result regardless of significance (to show "ns" when not significant)
      sig_results[[length(sig_results) + 1]] <- list(
        gene = selected_gene,
        timepoint1 = t1,
        timepoint2 = t2,
        p_value = p_value,
        significance = significance,
        mean1 = mean(t1_data),
        mean2 = mean(t2_data),
        y_position = max(mean(t1_data), mean(t2_data)) * 1.1  # Position above the bars
      )
    }
  }
  
  return(sig_results)
}

# Modified extract ortholog expression to use HOGs
extract_ortholog_expression <- function(gene_mapping, species_data_list, config = NULL, transform_type = "lcpm") {
  #prepare data structure to hold all expression values
  expression_data <- list()
  
  #get species configuration if not provided
  if (is.null(config)) {
    config <- DEFAULT_SPECIES_CONFIG  #fallback to default
  }
  
  # for each mapped gene, extract expression from all species
  for (i in 1:length(gene_mapping)) {
    gene_map <- gene_mapping[[i]]
    gene_name <- gene_map$original
    
    # get expression for each species
    expression_by_species <- list()
    
    for (species_code in names(species_data_list)) {
      # Skip non-species entries
      if (species_code %in% c("orthofinder", "metadata", "gene_lookup", "phylo_trees")) {
        next
      }
      
      # Check if this species has the gene in the mapping
      if (!is.null(gene_map[[species_code]])) {
        gene_id <- gene_map[[species_code]]
        
        #get expression matrix based on transformation
        expr_matrix <- get_expression_matrix(species_code, transform_type, species_data_list[[species_code]])
        
        #get sample info - try direct access first, then prefixed
        sample_info <- species_data_list[[species_code]]$sample_info
        if (is.null(sample_info)) {
          sample_info <- species_data_list[[species_code]][[paste0(species_code, "_sample_info")]]
        }
        
        if (is.null(expr_matrix) || is.null(sample_info)) {
          next  #skip if we can't find the data
        }
        
        #handle K. lactis underscore issue (only for default data)
        if (species_code == "kl" && !is.null(gene_id)) {
          gene_id_with_underscore <- gsub("^(KLLA0)(.*)", "\\1_\\2", gene_id)
          if (gene_id_with_underscore %in% rownames(expr_matrix)) {
            gene_id <- gene_id_with_underscore
          }
        }
        
        if (gene_id %in% rownames(expr_matrix)) {
          # Get species display name
          species_display <- if (species_code %in% names(config)) {
            config[[species_code]]$short
          } else if (species_code %in% names(DEFAULT_SPECIES_CONFIG)) {
            DEFAULT_SPECIES_CONFIG[[species_code]]$short
          } else {
            species_code  
          }
          
          #this ensures timepoints are correctly matched with expression values
          if ("Sample" %in% colnames(sample_info)) {
            #match samples explicitly
            expression_values <- as.numeric(expr_matrix[gene_id, sample_info$Sample])
          } else {
            #fallback if Sample column doesn't exist - assume order matches
            expression_values <- as.numeric(expr_matrix[gene_id, ])
          }
          
          expr_df <- data.frame(
            Gene = gene_name,
            OriginalID = gene_id,
            Species = species_display,
            Timepoint = sample_info$Timepoint,
            Replicate = sample_info$Replicate,
            Expression = expression_values,
            stringsAsFactors = FALSE
          )
          expression_by_species[[species_code]] <- expr_df
        }
      }
    }
    #combine all species data for this gene
    if (length(expression_by_species) > 0) {
      combined_expr <- rbindlist(expression_by_species, fill = TRUE)
      if (nrow(combined_expr) > 0) {
        expression_data[[gene_name]] <- combined_expr
      }
    }
  }
  
  #merge all gene data
  if (length(expression_data) > 0) {
    all_expression <- rbindlist(expression_data, fill = TRUE)
    return(as.data.frame(all_expression))
  } else {
    return(data.frame(
      Gene = character(0),
      OriginalID = character(0),
      Species = character(0),
      Timepoint = character(0),
      Replicate = integer(0),
      Expression = numeric(0)
    ))
  }
}

# prepare heatmap matrix from expression data
prepare_heatmap_matrix <- function(expression_data, normalization = "zscore") {
  # ensure timepoints are properly ordered
  expression_data$Timepoint <- factor(expression_data$Timepoint, levels = TIME_POINTS)
  
  # average replicates
  avg_data <- expression_data %>%
    group_by(Gene, Species, Timepoint) %>%
    summarise(AvgExpression = mean(Expression, na.rm = TRUE), .groups = 'drop')
  
  # create a unique column ID for each species-timepoint combination
  avg_data$SpeciesTimepoint <- paste(avg_data$Species, avg_data$Timepoint, sep = "_")
  
  # create a wide format matrix
  heatmap_matrix <- avg_data %>%
    select(Gene, SpeciesTimepoint, AvgExpression) %>%
    pivot_wider(names_from = SpeciesTimepoint, values_from = AvgExpression)
  
  # convert to matrix format
  genes <- heatmap_matrix$Gene
  hm_matrix <- as.matrix(heatmap_matrix[, -1])
  rownames(hm_matrix) <- genes
  
  # apply normalization if requested
  if (normalization == "zscore") {
    # Check for genes with zero variance before normalization
    gene_vars <- apply(hm_matrix, 1, var)
    const_genes <- which(gene_vars == 0)
    
    if (length(const_genes) > 0) {
      showNotification(
        paste("Note:", length(const_genes), "genes have constant expression and will be shown at z-score = 0"),
        type = "info",
        duration = 5
      )
    }
    
    # apply z-score normalization to each gene (row) separately
    hm_matrix <- t(scale(t(hm_matrix)))
    
    # Replace any NaN or Inf values with 0 (genes with no variance)
    hm_matrix[!is.finite(hm_matrix)] <- 0
  }
  
  return(hm_matrix)
}

# create a cross-species heatmap visualization
create_cross_species_heatmap <- function(heatmap_matrix, is_dark_mode = FALSE, 
                                         cluster_rows = TRUE, cluster_cols = FALSE,
                                         config = NULL, species_colors_dynamic = NULL) {
  # Set color scheme based on dark mode
  plot_bg_color <- if(is_dark_mode) "#2c3034" else "white"
  text_color <- if(is_dark_mode) "white" else "black"
  
  # Define column groups (for species)
  column_names <- colnames(heatmap_matrix)
  species_names <- sapply(strsplit(column_names, "_"), function(x) x[1])
  
  # Get unique species for dynamic color assignment
  unique_species <- unique(species_names)
  
  # Create species colors mapping using the actual species names from columns
  if (!is.null(species_colors_dynamic)) {
    # Map the provided colors to the actual species names in the data
    species_colors <- list()
    
    # The dynamic colors are keyed by short names from config, but our column names might be full
    for (sp_name in unique_species) {
      # Check if this exact name exists in dynamic colors
      if (sp_name %in% names(species_colors_dynamic)) {
        species_colors[[sp_name]] <- species_colors_dynamic[[sp_name]]
      } else {
        # Try to find a matching species by checking all provided colors
        found_color <- FALSE
        for (provided_name in names(species_colors_dynamic)) {
          # Check if this is a match (could be short vs full name)
          if (grepl(sp_name, provided_name, ignore.case = TRUE) || 
              grepl(provided_name, sp_name, ignore.case = TRUE)) {
            species_colors[[sp_name]] <- species_colors_dynamic[[provided_name]]
            found_color <- TRUE
            break
          }
        }
        
        # If still no match, assign a default color
        if (!found_color) {
          if (FALSE) {
            } else {
            # Fallback color
            default_palette <- c("#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4")
            idx <- (which(unique_species == sp_name) - 1) %% length(default_palette) + 1
            species_colors[[sp_name]] <- default_palette[idx]
          }
        }
      }
    }
  } else {
    # No dynamic colors provided, use defaults based on species names
    species_colors <- list()
    for (sp_name in unique_species) {
      if (grepl("albicans", sp_name, ignore.case = TRUE)) {
        species_colors[[sp_name]] <- "#74ac4c"  # Green
      } else if (grepl("glabrata", sp_name, ignore.case = TRUE)) {
        species_colors[[sp_name]] <- "red"  # Red  
      } else if (grepl("lactis", sp_name, ignore.case = TRUE)) {
        species_colors[[sp_name]] <- "#f8c434"  # Yellow
      } else if (grepl("cerevisiae", sp_name, ignore.case = TRUE)) {
        species_colors[[sp_name]] <- "blue"  # Blue
      } else {
        # Default colors for unknown species
        default_palette <- c("#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4",
                            "#FFEAA7", "#DDA0DD", "#98D8C8", "#F7DC6F")
        idx <- (which(unique_species == sp_name) - 1) %% length(default_palette) + 1
        species_colors[[sp_name]] <- default_palette[idx]
      }
    }
  }
  
  # Build species mapping dynamically from config if provided
  if (!is.null(config)) {
    species_mapping <- list()
    for (sp in unique_species) {
      # Try to find this species in the config
      found <- FALSE
      for (sp_code in names(config)) {
        if (config[[sp_code]]$short == sp || config[[sp_code]]$name == sp) {
          species_mapping[[sp]] <- config[[sp_code]]$name
          found <- TRUE
          break
        }
      }
      if (!found) {
        # Fallback to using the species name as-is
        species_mapping[[sp]] <- sp
      }
    }
  } else {
    # Fallback mapping
    species_mapping <- setNames(unique_species, unique_species)
  }
  
  # Create a one-row matrix for the species annotation bar
  unique_species <- unique(species_names)
  species_to_num <- setNames(seq_along(unique_species), unique_species)
  species_matrix <- matrix(sapply(species_names, function(s) species_to_num[[s]]), nrow = 1)
  colnames(species_matrix) <- column_names
  rownames(species_matrix) <- "Species"
  
  # Custom colorscale for species bar - ALWAYS use position-based colors
  colorscale <- lapply(seq_along(unique_species), function(i) {
    species <- unique_species[i]
    
    # IGNORE species_colors parameter completely - always use dynamic palette
    dynamic_palette <- c("#808080", "#FFB6C1", "#8B4513", "#A52A2A", 
                        "#4682B4", "#32CD32", "#FF6347", "#9370DB",
                        "#20B2AA", "#FF69B4", "#CD853F", "#00CED1")
    species_color <- dynamic_palette[((i - 1) %% length(dynamic_palette)) + 1]
    
    return(list(
      (i-1)/(max(1, length(unique_species)-1)),
      species_color
    ))
  })
  
  # Convert the nested list to the format plotly expects
  colorscale_flat <- unlist(colorscale, recursive = FALSE)
  
  # Create the species annotation bar
  discrete_colorscale <- list()
  for (i in seq_along(unique_species)) {
    # Add two entries per color to create discrete blocks
    val_start <- (i - 1) / length(unique_species)
    val_end <- i / length(unique_species)
    color <- colorscale[[i]][[2]]
    
    discrete_colorscale[[length(discrete_colorscale) + 1]] <- list(val_start, color)
    discrete_colorscale[[length(discrete_colorscale) + 1]] <- list(val_end, color)
  }
  
  p1 <- plot_ly() %>%
    add_heatmap(
      z = species_matrix,
      x = column_names,
      y = c(""),  # No y labels
      showscale = FALSE,
      colorscale = discrete_colorscale,
      zmin = 0.5,
      zmax = length(unique_species) + 0.5,
      hoverinfo = "text",
      text = matrix(paste("Species:", species_names), nrow = 1)
    ) %>%
    layout(
      xaxis = list(
        showticklabels = FALSE,
        ticks = "",
        showgrid = FALSE,
        zeroline = FALSE
      ),
      yaxis = list(
        showticklabels = FALSE,
        ticks = "",
        showgrid = FALSE,
        zeroline = FALSE
      ),
      margin = list(l = 100, r = 50, b = 0, t = 10),
      plot_bgcolor = plot_bg_color,
      paper_bgcolor = plot_bg_color
    )
  
  p2 <- plot_ly(
    z = heatmap_matrix,
    x = column_names,
    y = rownames(heatmap_matrix),
    type = "heatmap",
    colorscale = "viridis",  
    zmin = -3, 
    zmax = 3,
    zmid = 0,
    hoverinfo = "text",
    text = matrix(
      paste(
        "Gene:", rep(rownames(heatmap_matrix), each = ncol(heatmap_matrix)),
        "<br>Species-Timepoint:", rep(column_names, times = nrow(heatmap_matrix)),
        "<br>Value:", round(as.vector(t(heatmap_matrix)), 2)
      ),
      nrow = nrow(heatmap_matrix),
      ncol = ncol(heatmap_matrix),
      byrow = TRUE
    ),
    showscale = TRUE,  # Explicitly show the colorbar scale
    colorbar = list(
      title = "Z-score",
      len = 0.6,       # Longer colorbar (was 0.4)
      thickness = 20,  # Thicker colorbar (was 15)
      y = 1.1,        # Higher position (was 0.77)
      x = 0.878,        # More to the right (was 0.85)
      outlinewidth = 1
    )
  )
  
  
  #build legend data from actual unique species in the data
  legend_data <- data.frame(
    species_code = unique_species,  # Keep exact same as unique_species
    species_name = unique_species,  # Display exactly what's in unique_species
    value = seq_along(unique_species),
    stringsAsFactors = FALSE
  )
  
  # Create the legend heatmap
  legend_plot <- plot_ly(
    height = 100 * length(unique_species)  # Adjust height based on number of species
  )
  
  # New code (lines 2164-2193)
  # Extract colors from the colorscale we created for the annotation bar
  # New code (lines 2170-2211)
  # Extract colors from the colorscale we created for the annotation bar
  annotation_colors <- list()
  for (i in seq_along(colorscale)) {
    # Each element of colorscale is a list with [position, color]
    species <- unique_species[i]
    color <- colorscale[[i]][[2]]  # Get the color (second element)
    annotation_colors[[species]] <- color
  }
  
  # Debug: Print what we have
  cat("DEBUG: annotation_colors =", paste(names(annotation_colors), annotation_colors, sep=":", collapse=", "), "\n")
  cat("DEBUG: legend_data$species_code =", paste(legend_data$species_code, collapse=", "), "\n")
  
  # Add separate scatter traces for each species with custom markers
  for (i in 1:nrow(legend_data)) {
    species_code <- legend_data$species_code[i]
    species_name <- legend_data$species_name[i]
    
    # Use the EXACT index to get color from colorscale to ensure match
    species_index <- which(unique_species == species_code)
    if (length(species_index) > 0) {
      marker_color <- colorscale[[species_index[1]]][[2]]
    } else {
      marker_color <- "#808080"  # Fallback gray
    }
    
    cat("DEBUG: Species", species_code, "gets color", marker_color, "\n")
    
    # Add colored square marker for the species  
    legend_plot <- legend_plot %>% add_trace(
      x = c(0.5),  # Position in center
      y = c(nrow(legend_data) - i + 1),  # Position from top to bottom
      type = "scatter",
      mode = "markers",
      marker = list(
        symbol = "square",
        size = 15,
        color = marker_color,  # This now uses annotation_colors which matches the bar
        line = list(color = "black", width = 1)
      ),
      text = species_code,  # Use species_code for consistency
      hoverinfo = "text",
      showlegend = FALSE
    )
    
    # Add text label for the species
    legend_plot <- legend_plot %>% add_annotations(
      x = 0.9,  # Position text to the right of square
      y = nrow(legend_data) - i + 1,
      text = species_code, 
      showarrow = FALSE,
      xanchor = "left"
    )
  }
  
  # Configure the legend plot layout
  legend_plot <- legend_plot %>% layout(
    xaxis = list(
      showticklabels = FALSE,
      showgrid = FALSE,
      zeroline = FALSE,
      range = c(0, 2)  # Set fixed range for consistent positioning
    ),
    yaxis = list(
      showticklabels = FALSE,
      showgrid = FALSE,
      zeroline = FALSE,
      range = c(0, nrow(legend_data) + 1)  # Add some padding
    ),
    margin = list(l = 0, r = 0, t = 30, b = 0),
    title = list(text = "Species", x = 0.5),
    plot_bgcolor = plot_bg_color,
    paper_bgcolor = plot_bg_color
  )
  
  # main heatmap layout
  p2 <- p2 %>% layout(
  xaxis = list(
    title = "Species-Timepoint",
    tickangle = -45,
    tickfont = list(size = 10),
    showticklabels = TRUE
  ),
  yaxis = list(
    title = "Gene",
    autorange = "reversed",
    tickmode = "array", 
    tickvals = 0:(length(rownames(heatmap_matrix))-1),  # Start from 0
    ticktext = rownames(heatmap_matrix),
    tickfont = list(size = 10)
  ),
  margin = list(l = 120, r = 100, b = 200, t = 0),  # Increased bottom margin for labels
  plot_bgcolor = plot_bg_color,
  paper_bgcolor = plot_bg_color,
  coloraxis = list(colorscale = "viridis")  
)
  
  #  annotation bar and main heatmap combined
  main_plot <- subplot(
    style(p1, showscale = FALSE), p2, 
    nrows = 2,
    heights = c(0.05, 0.95),
    shareX = TRUE, 
    titleY = FALSE
  )
  
  # Create a dummy plot to act as a spacer
  spacer_plot <- plot_ly() %>%
    layout(
      plot_bgcolor = 'rgba(0,0,0,0)',
      paper_bgcolor = 'rgba(0,0,0,0)',
      xaxis = list(visible = FALSE),
      yaxis = list(visible = FALSE),
      margin = list(l = 0, r = 0, t = 0, b = 0)
    )
  
  # First stack the spacer and legend vertically
  legend_column <- subplot(
    spacer_plot, legend_plot,
    nrows = 2,
    heights = c(0.45, 0.55)  # Adjust this ratio to position the legend lower
  )
  
  combined_plot <- subplot(
    main_plot, legend_column,
    widths = c(0.85, 0.15),
    titleX = TRUE,
    titleY = TRUE
  ) %>% layout(
    title = list(
      text = "Cross-Species Gene Expression Heatmap",
      x = 0.45  
    ),
    plot_bgcolor = plot_bg_color,
    paper_bgcolor = plot_bg_color,
    font = list(color = text_color),
    margin = list(l = 100, r = 100, b = 50, t = 50),
    showlegend = FALSE
  )
  
  return(combined_plot)
}

# create ortholog mapping table
create_ortholog_table <- function(gene_mapping, config = NULL) {
  if (is.null(config)) {
    config <- DEFAULT_SPECIES_CONFIG
  }
  
  # Start with the gene column
  ortholog_df <- data.frame(
    Gene = sapply(gene_mapping, function(x) x$original),
    stringsAsFactors = FALSE
  )
  
  # Dynamically add columns for each species in the config
  col_names <- c("Input Gene" = "Gene")
  
  for (sp_code in names(config)) {
    # Add column for this species
    col_name <- paste0(toupper(sp_code), "_ID")
    ortholog_df[[col_name]] <- sapply(gene_mapping, function(x) {
      ifelse(is.null(x[[sp_code]]), "-", x[[sp_code]])
    })
    
    # Add to column names mapping
    col_names[[config[[sp_code]]$name]] <- col_name
  }
  
  # create a datatable
  dt <- datatable(
    ortholog_df,
    options = list(
      pageLength = 10,
      scrollX = TRUE,
      dom = 'tip'
    ),
    colnames = col_names,
    rownames = FALSE
  )
  
  return(dt)
}

#ridgeline plot (optimized with list collection)
create_ridgeline_plot <- function(species_data_list, is_dark_mode = FALSE) {
  #preallocate list for faster data collection
  data_list <- vector("list", length = sum(sapply(species_data_list, function(x) {
    sample_info <- if("sample_info" %in% names(x)) x$sample_info else x[[paste0(names(species_data_list)[1], "_sample_info")]]
    nrow(sample_info)
  })))
  list_idx <- 1
  
  for (species_id in names(species_data_list)) {
    species_data <- species_data_list[[species_id]]
    species_name <- switch(species_id,
                          "cg" = "C. glabrata",
                          "sc" = "S. cerevisiae",
                          "kl" = "K. lactis",
                          "ca" = "C. albicans")
    
    expr_matrix <- if(species_id == "cg") species_data$lcpm else species_data[[paste0(species_id, "_lcpm")]]
    sample_info <- if(species_id == "cg") species_data$sample_info else species_data[[paste0(species_id, "_sample_info")]]
    
    for (i in 1:nrow(sample_info)) {
      sample_name <- sample_info$Sample[i]
      timepoint <- sample_info$Timepoint[i]
      replicate <- sample_info$Replicate[i]
      
      expr_values <- expr_matrix[, sample_name]
      
      #collect in list (faster than rbind)
      data_list[[list_idx]] <- data.table(
        Species = species_name,
        Timepoint = timepoint,
        Replicate = replicate,
        Expression = expr_values
      )
      list_idx <- list_idx + 1
    }
  }
  
  #combine using rbindlist
  all_density_data <- rbindlist(data_list[1:(list_idx-1)])
  
  # Convert timepoint to factor to preserve order
  all_density_data$Timepoint <- factor(all_density_data$Timepoint, 
                                      levels = TIME_POINTS)
  
  # Set plot styling based on dark mode
  plot_bg_color <- if(is_dark_mode) "#2c3034" else "white"
  text_color <- if(is_dark_mode) "white" else "black"
  grid_color <- if(is_dark_mode) "gray30" else "gray90"
  
  # Create ridgeline plot with ggplot2 and ggridges
  p <- ggplot(all_density_data, 
             aes(x = Expression, y = Timepoint, fill = Timepoint)) +
    geom_density_ridges(scale = 2, alpha = 0.7, quantile_lines = TRUE) +
    scale_fill_viridis(discrete = TRUE) +
    facet_wrap(~ Species, scales = "free_y") +
    labs(
      title = "Gene Expression Distribution Across Timepoints",
      x = "log2 CPM",
      y = "Timepoint"
    ) +
    theme_minimal() +
    theme(
      text = element_text(color = text_color),
      axis.text = element_text(color = text_color),
      plot.title = element_text(size = 14, face = "bold", color = text_color),
      panel.grid.major = element_line(color = grid_color),
      panel.grid.minor = element_line(color = if(is_dark_mode) "gray20" else "gray95"),
      plot.background = element_rect(fill = plot_bg_color, color = NA),
      panel.background = element_rect(fill = plot_bg_color, color = NA),
      strip.background = element_rect(fill = plot_bg_color),
      strip.text = element_text(color = text_color),
      legend.background = element_rect(fill = plot_bg_color),
      legend.text = element_text(color = text_color),
      legend.title = element_text(color = text_color)
    )
  
  return(p)
}

#gene count threshold plot (optimized)
create_threshold_ridgeline <- function(species_data_list, threshold = 2, is_dark_mode = FALSE) {
  count_list <- list()
  list_idx <- 1
  
  for (species_id in names(species_data_list)) {
    species_data <- species_data_list[[species_id]]
    species_name <- switch(species_id,
                          "cg" = "C. glabrata",
                          "sc" = "S. cerevisiae",
                          "kl" = "K. lactis",
                          "ca" = "C. albicans")
    
    expr_matrix <- if(species_id == "cg") species_data$lcpm else species_data[[paste0(species_id, "_lcpm")]]
    sample_info <- if(species_id == "cg") species_data$sample_info else species_data[[paste0(species_id, "_sample_info")]]
    
    for (i in 1:nrow(sample_info)) {
      sample_name <- sample_info$Sample[i]
      timepoint <- sample_info$Timepoint[i]
      replicate <- sample_info$Replicate[i]
      
      expr_values <- expr_matrix[, sample_name]
      genes_above <- sum(expr_values > threshold)
      percent_above <- (genes_above / length(expr_values)) * 100
      
      count_list[[list_idx]] <- data.table(
        Species = species_name,
        Timepoint = timepoint,
        Replicate = replicate,
        GenesAbove = genes_above,
        PercentAbove = percent_above
      )
      list_idx <- list_idx + 1
    }
  }
  
  count_data <- rbindlist(count_list)
  
  # Convert timepoint to factor to preserve order
  count_data$Timepoint <- factor(count_data$Timepoint, levels = TIME_POINTS)
  
  # Set plot styling based on dark mode
  plot_bg_color <- if(is_dark_mode) "#2c3034" else "white"
  text_color <- if(is_dark_mode) "white" else "black"
  grid_color <- if(is_dark_mode) "gray30" else "gray90"
  
  # Create bar plot
  p <- ggplot(count_data, 
             aes(x = Timepoint, y = PercentAbove, fill = Timepoint)) +
    geom_bar(stat = "identity", position = "dodge") +
    facet_wrap(~ Species) +
    scale_fill_viridis(discrete = TRUE) +
    labs(
      title = paste("Percentage of Genes with Expression Above", threshold, "log2 CPM"),
      x = "Timepoint",
      y = "Percent of Genes (%)"
    ) +
    theme_minimal() +
    theme(
      text = element_text(color = text_color),
      axis.text.x = element_text(angle = 45, hjust = 1, color = text_color),
      axis.text.y = element_text(color = text_color),
      plot.title = element_text(size = 14, face = "bold", color = text_color),
      panel.grid.major = element_line(color = grid_color),
      panel.grid.minor = element_line(color = if(is_dark_mode) "gray20" else "gray95"),
      plot.background = element_rect(fill = plot_bg_color, color = NA),
      panel.background = element_rect(fill = plot_bg_color, color = NA),
      strip.background = element_rect(fill = plot_bg_color),
      strip.text = element_text(color = text_color),
      legend.background = element_rect(fill = plot_bg_color),
      legend.text = element_text(color = text_color),
      legend.title = element_text(color = text_color)
    )
  
  return(p)
}

# main function to orchestrate the cross-species heatmap creation
generate_cross_species_heatmap <- function(gene_list, species_data_list, 
                                           normalization = "zscore", 
                                           is_dark_mode = FALSE,
                                           cluster_rows = TRUE,
                                           cluster_cols = FALSE,
                                           config = NULL,
                                           all_species_data = NULL,
                                           transform_type = "lcpm") {
  # clean up gene list - remove empty strings, trim whitespace
  gene_list <- gene_list[gene_list != ""]
  gene_list <- trimws(gene_list)
  
  # map genes across species using HOGs
  gene_mapping <- extract_orthology_for_genes(gene_list, all_species_data, config)
  
  # stop if no genes were mapped
  if (length(gene_mapping) == 0) {
    return(list(
      plot = NULL,
      table = NULL,
      error = "No genes could be mapped across species"
    ))
  }
  
  #extract expression data
  expression_data <- extract_ortholog_expression(gene_mapping, species_data_list, config, transform_type)
  
  # prepare heatmap matrix
  heatmap_matrix <- prepare_heatmap_matrix(expression_data, normalization)
  
  # create heatmap
  #get dynamic colors for current species configuration
  dynamic_colors <- NULL
  if (!is.null(config)) {
    auto_colors <- c("#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", 
                     "#FFEAA7", "#DDA0DD", "#98D8C8", "#F7DC6F",
                     "#BB8FCE", "#85C1E2", "#F8B739", "#52BE80")
    color_index <- 1
    dynamic_colors <- list()
    
    for (sp_code in names(config)) {
      sp_short <- config[[sp_code]]$short
      # Check if this species has a predefined color in DEFAULT_SPECIES_COLORS
      if (sp_short %in% names(DEFAULT_SPECIES_COLORS)) {
        dynamic_colors[[sp_short]] <- DEFAULT_SPECIES_COLORS[[sp_short]]
      } else {
        # Assign from auto_colors palette
        dynamic_colors[[sp_short]] <- auto_colors[color_index]
        color_index <- ((color_index - 1) %% length(auto_colors)) + 1
      }
    }
  }
  
  heatmap_plot <- create_cross_species_heatmap(
    heatmap_matrix, 
    is_dark_mode = is_dark_mode,
    cluster_rows = cluster_rows,
    cluster_cols = cluster_cols,
    config = config,
    species_colors_dynamic = dynamic_colors
  )
  
  # create ortholog table
  ortholog_table <- create_ortholog_table(gene_mapping, config)
  
  # return both the plot and table
  return(list(
    plot = heatmap_plot,
    table = ortholog_table,
    matrix = heatmap_matrix,  
    error = NULL
  ))
}

# Helper function to create orthogroup selection UI
create_orthogroup_selection_ui_enhanced <- function(query_result, prefix, config = NULL) {
  cat("\n=== Creating enhanced orthogroup selection UI ===\n")
  cat("Prefix:", prefix, "\n")
  
  #use default config if not provided
  if (is.null(config)) {
    config <- DEFAULT_SPECIES_CONFIG
  }
  
  if (is.null(query_result) || query_result$source == "none") {
    return(NULL)
  }
  
  # Determine which species to show
  current_species <- prefix
  if (prefix == "combined") {
    species_to_show <- names(query_result$genes_by_species)
  } else {
    species_to_show <- current_species
  }
  
  selection_ui <- tagList()
  
  # Check if any species has paralogs
  has_paralogs <- FALSE
  for (sp in species_to_show) {
    if (sp %in% names(query_result$genes_by_species)) {
      if (nrow(query_result$genes_by_species[[sp]]) > 1) {
        has_paralogs <- TRUE
        break
      }
    }
  }
  
  # Add paralog notice if applicable
  if (has_paralogs) {
    selection_ui <- tagList(
      selection_ui,
      div(
        class = "paralog-notice",
        icon("info-circle"),
        " Multiple gene copies (paralogs) detected. Select the appropriate gene for each species."
      )
    )
  }
  
  for (species_code in species_to_show) {
    if (species_code %in% names(query_result$genes_by_species)) {
      genes_df <- query_result$genes_by_species[[species_code]]
      
      if (nrow(genes_df) > 0) {
        radio_id <- paste0(prefix, "_", species_code, "_selection")
        
        # For single species view
        if (prefix != "combined") {
          if (nrow(genes_df) == 1) {
            # Single gene - show as info with auto-selection
            selection_ui <- div(
              class = "paralog-selection",
              div(class = "paralog-header", "Gene found in this species:"),
              div(
                class = "single-gene-notice",
                genes_df$display[1],
                " (automatically selected)"
              ),
              # Hidden radio button for consistency
              div(
                style = "display: none;",
                radioButtons(
                  radio_id,
                  label = NULL,
                  choices = setNames(genes_df$gene_id, genes_df$display),
                  selected = genes_df$gene_id[1]
                )
              )
            )
          } else {
            # Multiple paralogs
            selection_ui <- div(
              class = "paralog-selection",
              div(
                class = "paralog-header",
                paste0(nrow(genes_df), " paralogs found - Select one:")
              ),
              radioButtons(
                radio_id,
                label = NULL,
                choices = setNames(genes_df$gene_id, genes_df$display),
                selected = genes_df$gene_id[1]
              ),
              div(
                style = "margin-top: 10px; font-size: 0.9em; color: #6c757d;",
                "Tip: Paralogs are gene duplicates that may have diverged in function."
              )
            )
          }
          
        } else {
          species_name <- if(species_code %in% names(config)) {
            config[[species_code]]$short
          } else {
            species_code
          }
          
          species_ui <- div(
            class = "orthogroup-species",
            h5(
              species_name,
              if(nrow(genes_df) > 1) {
                span(
                  class = "badge bg-warning text-dark ms-2",
                  paste(nrow(genes_df), "paralogs")
                )
              }
            ),
            if (nrow(genes_df) == 1) {
              div(
                class = "single-gene-notice mb-2",
                "Single copy gene: ", genes_df$display[1]
              )
            },
            radioButtons(
              radio_id,
              label = NULL,
              choices = setNames(genes_df$gene_id, genes_df$display),
              selected = genes_df$gene_id[1],
              width = "100%"
            )
          )
          
          selection_ui <- tagList(selection_ui, species_ui)
        }
      }
    }
  }
  
  # If no genes found for this species
  if (length(selection_ui) == 0 && prefix != "combined") {
    selection_ui <- div(
      class = "alert alert-info",
      icon("info-circle"),
      " No genes found in this species for the queried orthogroup."
    )
  }
  
  return(selection_ui)
}

#function to load tree file
load_gene_tree <- function(og_id, current_data = NULL) {
  # Access trees from the loaded data structure
  if (is.null(current_data)) {
    current_data <- all_species_data  # Use global all_species_data as fallback
  }
  if (!is.null(current_data$phylo_trees$trees)) {
    tree_name <- paste0(og_id, "_tree.txt")
    
    # Check if tree exists in the list
    if (tree_name %in% names(current_data$phylo_trees$trees)) {
      tree_data <- current_data$phylo_trees$trees[[tree_name]]
      
      # Parse the newick string to create a tree object
      if (!is.null(tree_data$newick) && nchar(tree_data$newick) > 0) {
        tree <- read.tree(text = tree_data$newick)
        return(tree)
      }
    }
  }
  return(NULL)
}

#create formatted orthogroup table (optimized)
create_orthogroup_details_table <- function(query_result, config = NULL) {
  if (is.null(query_result) || is.null(query_result$genes_by_species)) {
    return(NULL)
  }
  
  #use default config if not provided
  if (is.null(config)) {
    config <- DEFAULT_SPECIES_CONFIG
  }
  
  #collect gene info using list collection
  gene_list <- lapply(names(query_result$genes_by_species), function(sp) {
    genes_df <- query_result$genes_by_species[[sp]]
    if (nrow(genes_df) > 0) {
      species_name <- if (!is.null(config[[sp]])) config[[sp]]$name else sp
      
      genes_df$Species <- species_name
      genes_df$SpeciesCode <- sp
      
      genes_df[, c("Species", "gene_id", "gene_name", "display"), drop = FALSE]
    } else {
      NULL
    }
  })
  
  gene_list <- Filter(Negate(is.null), gene_list)
  if (length(gene_list) == 0) return(NULL)
  
  all_genes <- rbindlist(gene_list, fill = TRUE)
  if (nrow(all_genes) == 0) return(NULL)
  
  # Create a nicely formatted datatable
  dt <- datatable(
    all_genes[, c("Species", "gene_id", "gene_name")],
    options = list(
      pageLength = 10,
      dom = 'tip',
      ordering = TRUE,
      columnDefs = list(
        list(className = 'dt-left', targets = '_all')
      )
    ),
    colnames = c("Species", "Gene ID", "Gene Name"),
    rownames = FALSE,
    caption = htmltools::tags$caption(
      style = 'caption-side: top; text-align: left; font-weight: bold;',
      paste("Orthogroup:", query_result$orthogroup, 
            "| Total genes:", nrow(all_genes))
    )
  )
  
  return(dt)
}
#phylo tree plot (optimized)
create_phylo_tree_plot <- function(tree, orthogroup_genes, orthogroup_id, is_dark_mode = FALSE, current_data = NULL, species_colors = NULL, species_config = NULL) {
  if (is.null(tree)) {
    return(NULL)
  }
  
  #create gene ID mapping using list collection
  mapping_list <- lapply(names(orthogroup_genes), function(sp) {
    if (nrow(orthogroup_genes[[sp]]) > 0) {
      genes_df <- orthogroup_genes[[sp]]
      genes_df$species_code <- sp
      genes_df[, c("gene_id", "display", "species_code"), drop = FALSE]
    } else {
      NULL
    }
  })
  gene_mapping <- rbindlist(Filter(Negate(is.null), mapping_list), fill = TRUE)
  
  #create metadata dataframe for tips
  tip_metadata <- data.frame(
    label = tree$tip.label,
    stringsAsFactors = FALSE
  )
  
  tip_metadata$display_label <- NA_character_
  tip_metadata$species <- NA_character_
  
  #extract lookup table once outside loop
  if (is.null(current_data)) {
    current_data <- all_species_data  
  }
  lookup_table <- current_data$gene_lookup
  config <- if(!is.null(species_config)) species_config else DEFAULT_SPECIES_CONFIG
  
  for (i in 1:nrow(tip_metadata)) {
    current_gene_id <- tip_metadata$label[i]
    
    lookup_match <- lookup_table[gene_id == current_gene_id, ]
    
    if (nrow(lookup_match) > 0) {
      sp_code <- as.character(lookup_match$species[1])
      
      if (sp_code %in% names(config)) {
        tip_metadata$species[i] <- config[[sp_code]]$short
        
        if (!is.na(lookup_match$gene_name[1]) && lookup_match$gene_name[1] != "") {
          tip_metadata$display_label[i] <- paste0(lookup_match$gene_name[1], " (", current_gene_id, ")")
        } else {
          tip_metadata$display_label[i] <- current_gene_id
        }
      } else {
        tip_metadata$species[i] <- "Unknown"
        tip_metadata$display_label[i] <- current_gene_id
      }
    } else {
      tip_metadata$species[i] <- "Unknown"
      tip_metadata$display_label[i] <- current_gene_id
    }
  }
  
  # Add colors for any species not in SPECIES_COLORS but present in the data
  unique_species <- unique(tip_metadata$species[!is.na(tip_metadata$species)])
  additional_colors <- c("#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", 
                        "#FFEAA7", "#DDA0DD", "#98D8C8", "#F7DC6F")
  color_index <- 1
  for (sp in unique_species) {
    if (!sp %in% names(species_colors)) {
      species_colors[[sp]] <- additional_colors[color_index]
      color_index <- (color_index %% length(additional_colors)) + 1
    }
  }
  
  # Calculate dynamic parameters based on tree size
  n_tips <- length(tree$tip.label)
  max_label_length <- max(nchar(tip_metadata$display_label))
  
  # Dynamic text size - smaller for larger trees
  text_size <- if(n_tips > 20) 2.5 else if(n_tips > 10) 3.0 else 3.5
  
  # Dynamic x-limit to accommodate long labels
  x_limit <- 8 + (max_label_length / 10)
  
  #create the tree plot and add metadata
  p <- ggtree(tree, layout = "rectangular", branch.length = "none") %<+% tip_metadata +
    geom_tiplab(aes(label = display_label, color = species), 
                size = text_size, align = TRUE, linesize = 0.5) +
    geom_nodepoint(color = if(is_dark_mode) "#666" else "#999", 
                   alpha = 0.5, size = 2) +
    scale_color_manual(values = species_colors, name = "Species") +
    guides(color = guide_legend(override.aes = list(label = "", size = 6, linetype = 0))) +
    theme_tree2() +
    xlim_tree(x_limit) + 
    theme(
      legend.position = "bottom",
      legend.box.background = element_rect(
        fill = if(is_dark_mode) "#2c3034" else "white",
        color = if(is_dark_mode) "#444" else "#ddd"
      ),
      plot.background = element_rect(
        fill = if(is_dark_mode) "#2c3034" else "white", 
        color = NA
      ),
      panel.background = element_rect(
        fill = if(is_dark_mode) "#2c3034" else "white", 
        color = NA
      ),
      legend.background = element_rect(
        fill = if(is_dark_mode) "#2c3034" else "white"
      ),
      legend.text = element_text(
        color = if(is_dark_mode) "white" else "black",
        size = 10
      ),
      legend.title = element_text(
        color = if(is_dark_mode) "white" else "black",
        size = 11,
        face = "bold"
      ),
      plot.title = element_text(
        color = if(is_dark_mode) "white" else "black",
        size = 14,
        face = "bold",
        hjust = 0.5
      )
    ) +
    ggtitle(paste("Phylogenetic Tree for Orthogroup", orthogroup_id))
  
  return(p)
}

create_orthogroup_summary <- function(query_result, config = NULL) {
  if (is.null(query_result)) return(NULL)
  
  if (is.null(config)) {
    config <- DEFAULT_SPECIES_CONFIG  # Use default if not provided
  }
  
  # Count genes per species
  gene_counts <- sapply(query_result$genes_by_species, nrow)
  total_genes <- sum(gene_counts)
  
  # Create summary HTML
  summary_html <- tags$div(
    h5("Orthogroup Summary"),
    tags$ul(
      tags$li(paste("HOG ID:", query_result$orthogroup)),
      tags$li(paste("Total genes:", total_genes)),
      tags$li(paste("Species represented:", sum(gene_counts > 0))),
      tags$li(
        "Gene distribution:",
        tags$ul(
          lapply(names(gene_counts)[gene_counts > 0], function(sp) {
            species_name <- if(sp %in% names(config)) config[[sp]]$name else sp
            count <- gene_counts[sp]
            tags$li(paste0(species_name, ": ", count, " gene", if(count > 1) "s" else ""))
          })
        )
      )
    )
  )
  
  return(summary_html)
}

#calculates ortholog coverage statistics for gene set analysis
calculate_ortholog_coverage <- function(gene_mapping, config) {
  if (is.null(gene_mapping) || length(gene_mapping) == 0) {
    return(NULL)
  }
  
  total_genes <- length(gene_mapping)
  coverage_stats <- list()
  
  for (sp_code in names(config)) {
    #count how many input genes have orthologs in this species
    genes_with_orthologs <- sum(sapply(gene_mapping, function(gene_map) {
      !is.null(gene_map[[sp_code]]) && length(gene_map[[sp_code]]) > 0
    }))
    
    #get unique ortholog genes (de-duplicate across orthogroups)
    all_orthologs <- unique(unlist(sapply(gene_mapping, function(gene_map) {
      gene_map[[sp_code]]
    })))
    
    total_orthologs <- length(all_orthologs)
    
    #count paralogs (genes beyond 1 per orthogroup)
    paralog_count <- sum(sapply(gene_mapping, function(gene_map) {
      max(0, length(gene_map[[sp_code]]) - 1)
    }))
    
    coverage_pct <- round((genes_with_orthologs / total_genes) * 100, 1)
    
    coverage_stats[[sp_code]] <- list(
      species_name = config[[sp_code]]$short,
      genes_found = genes_with_orthologs,
      total_orthologs = total_orthologs,
      paralog_count = paralog_count,
      total_genes = total_genes,
      coverage_pct = coverage_pct,
      coverage_class = if(coverage_pct >= 80) "high" else if(coverage_pct >= 50) "medium" else "low"
    )
  }
  
  return(coverage_stats)
}

#ortholog table for gene set analysis
create_ortholog_mapping_table <- function(gene_mapping, config) {
  if (is.null(gene_mapping) || length(gene_mapping) == 0) {
    return(NULL)
  }
  
  #build expanded data frame showing ALL paralogs
  rows_list <- list()
  
  for (gene_map in gene_mapping) {
    input_gene <- gene_map$original
    
    #get max number of paralogs across species for this gene
    max_paralogs <- max(sapply(names(config), function(sp_code) {
      orthologs <- gene_map[[sp_code]]
      if (is.null(orthologs)) 0 else length(orthologs)
    }), na.rm = TRUE)
    
    #create one row per paralog position
    for (i in 1:max_paralogs) {
      row_data <- list(InputGene = if(i == 1) input_gene else "")
      
      for (sp_code in names(config)) {
        col_name <- paste0(config[[sp_code]]$short, "_Ortholog")
        orthologs <- gene_map[[sp_code]]
        
        if (is.null(orthologs) || length(orthologs) == 0) {
          row_data[[col_name]] <- if(i == 1) "-" else ""
        } else if (i <= length(orthologs)) {
          #show paralog with indicator if multiple exist
          if (length(orthologs) == 1) {
            row_data[[col_name]] <- orthologs[i]
          } else {
            row_data[[col_name]] <- paste0(orthologs[i], " [", i, "/", length(orthologs), "]")
          }
        } else {
          row_data[[col_name]] <- ""
        }
      }
      
      rows_list[[length(rows_list) + 1]] <- as.data.frame(row_data, stringsAsFactors = FALSE)
    }
  }
  
  if (length(rows_list) > 0) {
    mapping_df <- rbindlist(rows_list, fill = TRUE)
    return(as.data.frame(mapping_df))
  } else {
    return(data.frame())
  }
}

# Process gene set for multi-species ortholog analysis
process_multi_species_gene_set <- function(gene_mapping, species_data_list, config) {
  all_expression_data <- list()
  
  for (gene_map in gene_mapping) {
    input_gene <- gene_map$original
    
    for (sp_code in names(config)) {
      if (!is.null(gene_map[[sp_code]]) && length(gene_map[[sp_code]]) > 0) {
        # Get species data
        sp_data <- species_data_list[[sp_code]]
        if (is.null(sp_data)) next
        
        # Get expression matrix
        lcpm_matrix <- if (!is.null(sp_data$lcpm)) {
          sp_data$lcpm
        } else {
          sp_data[[paste0(sp_code, "_lcpm")]]
        }
        
        # Get sample info
        sample_info <- if (!is.null(sp_data$sample_info)) {
          sp_data$sample_info
        } else {
          sp_data[[paste0(sp_code, "_sample_info")]]
        }
        
        if (is.null(lcpm_matrix) || is.null(sample_info)) next
        
        # For each ortholog in this species
        for (gene_id in gene_map[[sp_code]]) {
          # Handle K. lactis underscore format
          gene_id_to_use <- gene_id
          if (sp_code == "kl" && !gene_id %in% rownames(lcpm_matrix)) {
            gene_id_alt <- gsub("^(KLLA0)(.*)", "\\1_\\2", gene_id)
            if (gene_id_alt %in% rownames(lcpm_matrix)) {
              gene_id_to_use <- gene_id_alt
            }
          }
          
          if (gene_id_to_use %in% rownames(lcpm_matrix)) {
            expr_df <- data.frame(
              Gene = input_gene,
              GeneID = gene_id,
              Species = config[[sp_code]]$short,
              SpeciesCode = sp_code,
              Timepoint = factor(sample_info$Timepoint, levels = TIME_POINTS),
              Replicate = sample_info$Replicate,
              Expression = as.numeric(lcpm_matrix[gene_id_to_use, ]),
              stringsAsFactors = FALSE
            )
            
            all_expression_data[[length(all_expression_data) + 1]] <- expr_df
          }
        }
      }
    }
  }
  
  if (length(all_expression_data) > 0) {
    return(as.data.frame(rbindlist(all_expression_data, fill = TRUE)))
  } else {
    return(NULL)
  }
}
```

```{r ui_definition, echo=FALSE}
#capture current session state
capture_session_state <- function(selected_genes, query_results, global_query_state, combined_selections, ortholog_state, input) {
  list(
    version = "1.0",
    timestamp = format(Sys.time(), "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC"),
    selected_genes = reactiveValuesToList(selected_genes),
    query_results = reactiveValuesToList(query_results),
    current_query = global_query_state$current_query,
    combined_selections = reactiveValuesToList(combined_selections),
    gene_list = input$gene_list,
    enable_ortholog_analysis = input$enable_ortholog_analysis,
    current_tab = input$nav,
    group_analysis_species = input$group_analysis_species,
    group_viz_type = input$group_viz_type,
    distance_method = input$distance_method,
    data_transform = input$data_transform,
    aggregation_level = input$aggregation_level,
    ortholog_selected = ortholog_state$selected_orthologs
  )
}

restore_session_state <- function(state, selected_genes, query_results, global_query_state, combined_selections, ortholog_state, session) {
  tryCatch({
    if (!is.null(state$selected_genes)) {
      for (sp in names(state$selected_genes)) {
        selected_genes[[sp]] <- state$selected_genes[[sp]]
      }
    }
    
    if (!is.null(state$query_results)) {
      for (sp in names(state$query_results)) {
        query_results[[sp]] <- state$query_results[[sp]]
      }
    }
    
    if (!is.null(state$current_query)) {
      global_query_state$current_query <- state$current_query
    }
    
    if (!is.null(state$combined_selections)) {
      for (sp in names(state$combined_selections)) {
        combined_selections[[sp]] <- state$combined_selections[[sp]]
      }
    }
    
    #restore gene group analysis inputs with delay to ensure UI is ready
    if (!is.null(state$gene_list)) {
      tryCatch({
        updateTextAreaInput(session, "gene_list", value = state$gene_list)
      }, error = function(e) {
        debug_print("could not restore gene_list: ", e$message)
      })
    }
    
    if (!is.null(state$enable_ortholog_analysis)) {
      tryCatch({
        updateCheckboxInput(session, "enable_ortholog_analysis", value = state$enable_ortholog_analysis)
      }, error = function(e) {
        debug_print("could not restore enable_ortholog_analysis: ", e$message)
      })
    }
    
    if (!is.null(state$group_analysis_species)) {
      tryCatch({
        updateSelectInput(session, "group_analysis_species", selected = state$group_analysis_species)
      }, error = function(e) {
        debug_print("could not restore group_analysis_species: ", e$message)
      })
    }
    
    if (!is.null(state$group_viz_type)) {
      tryCatch({
        updateSelectInput(session, "group_viz_type", selected = state$group_viz_type)
      }, error = function(e) {
        debug_print("could not restore group_viz_type: ", e$message)
      })
    }
    
    if (!is.null(state$distance_method)) {
      tryCatch({
        updateSelectInput(session, "distance_method", selected = state$distance_method)
      }, error = function(e) {
        debug_print("could not restore distance_method: ", e$message)
      })
    }
    
    if (!is.null(state$data_transform)) {
      tryCatch({
        updateSelectInput(session, "data_transform", selected = state$data_transform)
      }, error = function(e) {
        debug_print("could not restore data_transform: ", e$message)
      })
    }
    
    if (!is.null(state$aggregation_level)) {
      tryCatch({
        updateRadioButtons(session, "aggregation_level", selected = state$aggregation_level)
      }, error = function(e) {
        debug_print("could not restore aggregation_level: ", e$message)
      })
    }
    
    #do NOT restore ortholog_state$mapped
    
    if (!is.null(state$ortholog_selected)) {
      tryCatch({
        ortholog_state$selected_orthologs <- state$ortholog_selected
      }, error = function(e) {
        debug_print("could not restore ortholog_selected: ", e$message)
      })
    }
    
    #restore current tab
    if (!is.null(state$current_tab)) {
      tryCatch({
        updateNavbarPage(session, "nav", selected = state$current_tab)
      }, error = function(e) {
        debug_print("could not restore current_tab: ", e$message)
      })
    }
  }, error = function(e) {
    debug_print("error in restore_session_state: ", e$message)
  })
}

#format time ago for display
format_time_ago <- function(timestamp) {
  if (is.null(timestamp)) return("just now")
  
  saved_time <- as.POSIXct(timestamp, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
  diff_secs <- as.numeric(difftime(Sys.time(), saved_time, units = "secs"))
  
  if (diff_secs < 60) return("just now")
  if (diff_secs < 3600) return(paste(round(diff_secs / 60), "minutes ago"))
  if (diff_secs < 86400) return(paste(round(diff_secs / 3600), "hours ago"))
  return(paste(round(diff_secs / 86400), "days ago"))
}

ui <- page_navbar(
  theme = light_theme,  # Start with light theme
  title = NULL,
  id = "nav",
  fillable = FALSE,
  
  # Add all the header elements before the nav panels
  header = tagList(
    useWaiter(),
    useShinyjs(),
    custom_css,
    
    # Add splash screen CSS
    tags$style(HTML("
      /* Splash Screen Styles */
      #splash-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        /* Use safe viewport units */
        height: 100svh;
        height: 100dvh;
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        z-index: 9999;
        overflow: hidden;
        display: grid;
        place-items: center;
        padding: clamp(12px, 3vw, 48px);
        box-sizing: border-box;
      }
      
      #splash-screen.fade-out {
        opacity: 0;
        transform: scale(1.1);
        transition: all 0.8s ease-out;
      }
      
      /* SVG container with safe viewport handling */
      #splash-logo {
        width: 100%;
        height: 100%;
        position: relative;
        display: grid;
        place-items: center;
        padding: 0;
        margin: 0;
      }
      
      /* SVG wrapper and direct SVG styling */
      #svg-wrapper {
        width: min(96vw, 1600px);
        height: auto;
        max-height: min(88svh, 760px);
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      
    #svg-wrapper svg, #splash-logo svg {
      width: 100vw !important;
      height: 100vh !important;
      object-fit: cover !important;
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      }
      
      /* Mobile-specific adjustments */
      @media (max-width: 480px) {
        #svg-wrapper {
          width: 92vw;
          max-height: 80svh;
        }
        
        #svg-wrapper svg, #splash-logo svg {
          max-height: 80svh !important;
        }
      }
      
      /* Very tall narrow screens */
      @media (max-aspect-ratio: 3/4) {
        #svg-wrapper svg, #splash-logo svg {
          max-height: 82svh !important;
        }
      }
      
      /* Prevent any overflow from the splash screen */
      body.splash-active {
        overflow: hidden;
      }
      
      /* Ensure proper scaling on all devices */
      #splash-screen * {
        max-width: 100%;
      }
            
      /* Glowing trail effect */
      .glow-trail {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10000;
        overflow: hidden;
      }
      
      .trail-particle {
        position: absolute;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        filter: blur(4px);
        animation: fadeOut 1.5s ease-out forwards;
        pointer-events: none;
      }
      
      @keyframes fadeOut {
        0% { 
          opacity: 1;
          transform: scale(1) translate(0, 0);
        }
        100% { 
          opacity: 0;
          transform: scale(0.3) translate(var(--tx, 0), var(--ty, 0));
        }
      }
      
      /* Yeast cell base styles */
      #splash-logo svg #cells > g[id^=\"cell-\"] {
        cursor: pointer;
        transition: all 0.3s ease;
        transform-origin: center;
      }
      
      /* Spinning animation for cells wrapper */
      @keyframes spinCells {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(720deg); }
      }
      
      .spinning-animation {
        animation: spinCells 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        transform-origin: center;
      }
      
      /* Dispersal animations */
      @keyframes disperseTopLeft {
        to { transform: translate(-200%, -200%) scale(0.1); opacity: 0; }
      }
      @keyframes disperseTopRight {
        to { transform: translate(200%, -200%) scale(0.1); opacity: 0; }
      }
      @keyframes disperseBottomLeft {
        to { transform: translate(-200%, 200%) scale(0.1); opacity: 0; }
      }
      @keyframes disperseBottomRight {
        to { transform: translate(200%, 200%) scale(0.1); opacity: 0; }
      }
      
      /*hint text animation hidden for now */
      #interaction-hint {
        display: none !important; 
      }

      
      @keyframes fadeInHint {
        to { opacity: 1; }
      }
      
      /* Skip link styling */
      #splash-skip {
        position: absolute;
        top: 20px;
        right: 20px;
        color: rgba(255, 255, 255, 0.7);
        text-decoration: none;
        font-size: 14px;
        cursor: pointer;
        transition: color 0.3s ease;
        z-index: 10001;
      }
      
      #splash-skip:hover {
        color: white;
      }
    ")),
    
    #div for the splash screen overlay
    div(
      id = "splash-screen",
      
      # Skip link
      tags$a(
        id = "splash-skip",
        href = "#",
        onclick = "skipSplash(); return false;",
        "Skip intro "
      ),
      
      # Logo SVG with proper wrapper for scaling
      tags$div(
        id = "splash-logo",
        tags$div(
          id = "svg-wrapper",
          HTML(paste(readLines(file.path("..", "www", "rnacross-prominent-rna-logo-interactive.svg"), warn = FALSE), collapse = "\n"))
        )
      ),
      
      # Interaction hint (hidden by CSS)
      div(id = "interaction-hint", "Click the cells to begin"),
      
      # Hidden audio element for sound effect
      tags$audio(
        id = "whoosh-sound",
        src = "data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTGH0fPTgjMGHm7A7+OZURE",
        type = "audio/wav",
        preload = "auto"
      )
    ),
    
    # Glow trail container (outside splash screen for z-index)
    div(class = "glow-trail", id = "glow-trail-container"),
    
    # Header
    div(
      class = "navbar-container",
      div(
        class = "d-flex justify-content-between align-items-center p-3 bg-primary text-white",
        span(
          div(
            class = "icon-morph-container",
            style = "margin-right: 3px; position: relative; top: 1px;", 
            icon("dna", class = "fas"),
            icon("chart-line", class = "fas")
          ),
          span(style = "margin-left: 2px;", "Comparative Transcriptomic Analysis")
        ),
        div(
          class = "d-flex align-items-center",
          div(
            class = "me-3",
            style = "border-left: 1px solid rgba(255,255,255,0.3); padding-left: 15px;",
            radioButtons(
              "global_transform",
              label = span(style = "font-size: 0.9em; margin-bottom: 3px;", "Expression Data:"),
              choices = c("TMM + log2CPM" = "lcpm", "DESeq2 rlog" = "rlog"),
              selected = "lcpm",
              inline = TRUE
            )
          ),
          actionButton("show_help", "Tutorial", icon = icon("question-circle"), 
                       class = "btn-link text-white me-2"),
          actionButton("theme_toggle", label = NULL,
                       icon = icon("moon", verify_fa = FALSE),
                       class = "btn-link text-white",
                       title = "Toggle dark/light mode")
        )
      )
    ),
    
    # JavaScript with SVG scaling fixes
    tags$script(HTML('
    // Auto-hide timer
    let splashTimer;
    let hasInteracted = false;
    
    // Start the auto-hide timer
    function startSplashTimer() {
      splashTimer = setTimeout(function() {
        if (!hasInteracted) {
          hideSplash();
        }
      }, 60000); // 60 seconds
    }
    
    // Initialize event listeners when DOM is ready
    function initializeSplash() {
      // Find yeast cells - try multiple selectors
      const svg = document.querySelector("#splash-logo svg, #svg-wrapper svg");
      if (!svg) {
        console.error("SVG not found");
        return;
      }
      
      // Ensure SVG scales properly without cropping
      svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
      svg.removeAttribute("width");
      svg.removeAttribute("height");
      svg.style.width = "100%";
      svg.style.height = "100%";
      
      const cells = svg.querySelectorAll(\'#cells > g[id^="cell-"], #cells-wrapper > g[id^="cell-"], g[id*="yeast"]\');
      const cellsWrapper = svg.querySelector("#cells-wrapper, #cells");
      
      console.log("Found cells:", cells.length);
      console.log("Found wrapper:", cellsWrapper);
      
      // Add click handlers with improved hover effects
      if (cells.length > 0) {
        cells.forEach(cell => {
          cell.style.cursor = "pointer";
          cell.addEventListener("click", handleYeastClick);
          
          // Improved hover effect
          cell.addEventListener("mouseenter", () => {
            if (!hasInteracted) {
              cell.style.filter = "brightness(1.3) saturate(1.2)";
            }
          });
          cell.addEventListener("mouseleave", () => {
            if (!hasInteracted) {
              cell.style.filter = "";
            }
          });
        });
      }
      // Also add handler to cells wrapper if it exists
      if (cellsWrapper) {
        cellsWrapper.style.cursor = "pointer";
        cellsWrapper.addEventListener("click", handleYeastClick);
      }
      
      // Fallback: make entire SVG clickable
      if (cells.length === 0 && !cellsWrapper) {
        svg.style.cursor = "pointer";
        svg.addEventListener("click", handleYeastClick);
      }
    }
    
    // Handle yeast click
    function handleYeastClick() {
      if (hasInteracted) return; // Prevent multiple clicks
      hasInteracted = true;
      
      // Clear the auto-hide timer
      clearTimeout(splashTimer);
      
      // Play sound effect
      const audio = document.getElementById("whoosh-sound");
      if (audio) {
        audio.play().catch(e => console.log("Audio play failed:", e));
      }
      
      // Get SVG elements
      const svgElement = document.querySelector("#splash-logo svg, #svg-wrapper svg");
      const cellsWrapper = svgElement.querySelector("#cells-wrapper, #cells");
      const cells = svgElement.querySelectorAll(\'#cells > g[id^="cell-"], #cells-wrapper > g[id^="cell-"]\');
      
      // Add spinning animation
      if (cellsWrapper) {
        cellsWrapper.classList.add("spinning-animation");
      }
      
      // Create glowing trails
      createGlowTrails();
      
      // After spin, disperse cells
      setTimeout(() => {
        disperseSVGCells(cells);
        
        // Hide splash after dispersal
        setTimeout(() => {
          hideSplash();
        }, 1000);
      }, 800);
    }
    
    // Create glowing trail particles
    function createGlowTrails() {
      const trailContainer = document.getElementById("glow-trail-container");
      const colors = ["#00F5FF", "#FF006E", "#8338EC", "#FFBE0B"];
      const rect = document.getElementById("splash-logo").getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      // Create burst of particles
      for (let i = 0; i < 40; i++) {
        setTimeout(() => {
          const particle = document.createElement("div");
          particle.className = "trail-particle";
          particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          
          // Random position around center
          const angle = (Math.PI * 2 * i) / 40;
          const radius = 20 + Math.random() * 60;
          const startX = centerX + Math.cos(angle) * radius;
          const startY = centerY + Math.sin(angle) * radius;
          
          particle.style.left = startX + "px";
          particle.style.top = startY + "px";
          
          // Set custom properties for animation
          const tx = Math.cos(angle) * (100 + Math.random() * 200);
          const ty = Math.sin(angle) * (100 + Math.random() * 200);
          particle.style.setProperty("--tx", tx + "px");
          particle.style.setProperty("--ty", ty + "px");
          
          trailContainer.appendChild(particle);
          
          // Remove particle after animation
          setTimeout(() => particle.remove(), 1500);
        }, i * 15);
      }
    }
    
    // Disperse SVG cells
    function disperseSVGCells(cells) {
      const animations = [
        "disperseTopLeft",
        "disperseTopRight", 
        "disperseBottomLeft",
        "disperseBottomRight"
      ];
      
      cells.forEach((cell, index) => {
        if (index < 4) {
          cell.style.animation = `${animations[index]} 1s ease-in forwards`;
        }
      });
    }
    
    // Hide splash screen
    function hideSplash() {
      const splash = document.getElementById("splash-screen");
      splash.classList.add("fade-out");
      
      // Remove body class when hiding splash
      document.body.classList.remove("splash-active");
      
      setTimeout(() => {
        splash.style.display = "none";
        // Clean up glow trail container
        const glowContainer = document.getElementById("glow-trail-container");
        if (glowContainer) glowContainer.remove();
      }, 800);
    }
    
    // Skip splash function
    function skipSplash() {
      hasInteracted = true;
      clearTimeout(splashTimer);
      hideSplash();
      localStorage.setItem("skipSplash", "true");
    }
    
    // Handle yeast click from SVG (if SVG has onclick)
    window.handleYeastClickFromSVG = handleYeastClick;
    
    // Initialize on page load
    document.addEventListener("DOMContentLoaded", function() {
      // Check if should skip
      const skipStored = localStorage.getItem("skipSplash");
      if (skipStored === "true") {
        document.getElementById("splash-screen").style.display = "none";
        document.getElementById("glow-trail-container").style.display = "none";
      } else {
        // Add body class when showing splash
        document.body.classList.add("splash-active");
        startSplashTimer();
        // Initialize event listeners after a small delay to ensure SVG is loaded
        setTimeout(initializeSplash, 100);
      }
    });
    ')),
  
  #localstorage for session persistence
  tags$script(HTML("
    //save session to browser localStorage
    Shiny.addCustomMessageHandler('saveSession', function(session_state) {
      try {
        console.log('Saving session state:', session_state);
        localStorage.setItem('rnacross_session', JSON.stringify(session_state));
        localStorage.setItem('rnacross_session_timestamp', new Date().toISOString());
        console.log('Session saved successfully');
      } catch(e) {
        console.error('localStorage save failed:', e);
      }
    });
    
    //load session on app startup
    $(document).on('shiny:connected', function() {
      console.log('Shiny connected, checking for saved session');
      var session_state = localStorage.getItem('rnacross_session');
      var timestamp = localStorage.getItem('rnacross_session_timestamp');
      
      if (session_state) {
        console.log('Found saved session from:', timestamp);
        try {
          Shiny.setInputValue('restore_session', {
            state: JSON.parse(session_state),
            saved_at: timestamp
          }, {priority: 'event'});
          console.log('Restore signal sent to R');
        } catch(e) {
          console.error('Failed to restore session:', e);
        }
      } else {
        console.log('No saved session found');
      }
    });
    
    //clear session
    Shiny.addCustomMessageHandler('clearSession', function(msg) {
      console.log('Clearing session');
      localStorage.removeItem('rnacross_session');
      localStorage.removeItem('rnacross_session_timestamp');
      location.reload();
    });
    "))
  ),
  
  # Footer
  footer = tags$footer(
    class = "footer",
    div(
      class = "container text-center",
      p(
        "Created by Hubert Kicinski",
        br(),
        "Contact: ",
        a(href = "mailto:hkicinski@uiowa.edu", "hkicinski@uiowa.edu", class = "text-white")
      ),
      p(
        class = "mt-2 mb-0",
        "Version 2.9.1 - Updated November 2025"
      )
    )
  ),
  
  # gene explorer panel:
  nav_panel(
      title = span(icon("dna"), " Gene Explorer"),
      value = "gene_explorer",
      
      div(
        class = "gene-explorer-container",
        style = "padding-bottom: 120px !important;",
        
        # Query Panel
        div(
          class = "query-panel",
          h3("Gene Query Hub", class = "mb-4"),
          p("Search for a gene to explore its orthogroup across all species. Your query will be available throughout all analysis tabs."),
        
        fluidRow(
          column(
            width = 8,
            textInput(
              "global_gene_query",
              label = NULL,
              placeholder = "Enter gene name or ID (e.g., PHO4, YFR034C, CAGL0D05170g)",
              width = "100%"
            )
          ),
          column(
            width = 4,
            actionButton(
              "global_search_button",
              "Search",
              icon = icon("search"),
              class = "btn btn-primary w-100"
            )
          )
        ),
        
        # Query status
        div(
          id = "query_status_container",
          style = "display: none;",
          class = "query-status",
          uiOutput("query_status")
        )
      ),
      
      # Results container
      div(
        id = "gene_explorer_results",
        style = "display: none; magin-bottom: 100px;",
        
        fluidRow(
          # Left column - Tree
          column(
            width = 7,
            div(
              class = "tree-panel",
              h4("Phylogenetic Tree"),
              uiOutput("phylo_tree_plot_ui"),
              div(
                class = "tree-legend",
                h5("Tree Information"),
                p("This tree shows the evolutionary relationships between orthogroup members."),
                p("Tips are colored by species. Branch lengths represent evolutionary distance.")
              )
            )
          ),
          
          #right columns is Orthogroup info
          column(
            width = 5,
            div(
              class = "orthogroup-summary",
              uiOutput("orthogroup_summary")
            ),
            
            #quick action buttons
            div(
              class = "mt-4",
              h5("Quick Actions"),
              actionButton(
                "explore_species_view",
                "View in Species Analysis",
                icon = icon("chart-line"),
                class = "btn btn-secondary w-100 mb-2"
              ),
              actionButton(
                "explore_combined_view",
                "View in Combined Analysis",
                icon = icon("layer-group"),
                class = "btn btn-secondary w-100 mb-2"
              ),
              actionButton(
                "explore_heatmap",
                "Generate Cross-Species Heatmap",
                icon = icon("th"),
                class = "btn btn-secondary w-100"
              )
            ),
            
            # Orthogroup table
            div(
              class = "mt-4",
              h5("Orthogroup Members"),
              DTOutput("explorer_orthogroup_table")
            )
          )
        )
      )
    )
  ),
  # Data Upload Panel
  nav_panel(
    title = span(icon("upload"), " Data Upload"),
    value = "data_upload",
    
    div(
      class = "container-fluid",
      style = "padding: 20px; padding-bottom: 120px;",
      
      # Upload Status Banner
      div(
        id = "upload_status_banner",
        style = "display: none;",
        class = "alert",
        uiOutput("upload_status_content")
      ),
      
      # Main upload interface
      fluidRow(
        # Left panel - Species Definition and Upload
        column(
          width = 4,
          div(
            class = "sidebar-panel",
            h4("Define Your Dataset", class = "mb-4"),
            
            # Step 1: Define Species/Groups
            div(
              class = "upload-step",
              h5("Step 1: Define Your Species/Groups", icon("dna")),
              p("Add each species or experimental group. You can use any organisms."),
              
              # Dynamic species input area
              div(id = "species_input_area",
                  div(class = "species-entry mb-2", id = "species_entry_1",
                      fluidRow(
                        column(3, 
                               textInput("species_code_1", "Code*", value = "", 
                                         placeholder = "e.g., hs, mm, dm")),
                        column(5, 
                               textInput("species_name_1", "Full Name*", value = "",
                                         placeholder = "e.g., Homo sapiens")),
                        column(4, 
                               textInput("species_short_1", "Display Name", value = "",
                                         placeholder = "e.g., Human"))
                      ),
                      tags$small(class = "text-muted", 
                                 "Code: short identifier for files. Full Name: scientific name. Display: for plots.")
                  )
              ),
              
              div(class = "mt-2 mb-3",
                  actionButton("add_species", "Add Species", 
                               icon = icon("plus"), class = "btn btn-sm btn-success"),
                  actionButton("remove_species", "Remove Last", 
                               icon = icon("minus"), class = "btn btn-sm btn-warning ml-2")
              ),
              
              # Current species display
              div(
                class = "mt-3 p-2 bg-light rounded",
                h6("Defined Species:", class = "mb-2"),
                tableOutput("current_species_table")
              ),
              hr()
            ),
            
            # Step 2: Upload Expression Data
            div(
              class = "upload-step",
              h5("Step 2: Expression Matrices", icon("table")),
              p("Upload normalized expression data (genes  samples)"),
              uiOutput("expression_upload_ui"),
              hr()
            ),
            
            # Step 3: Upload Sample Info
            div(
              class = "upload-step",
              h5("Step 3: Sample Metadata", icon("clipboard")),
              p("Required columns: Sample, Timepoint, Replicate"),
              uiOutput("sample_upload_ui"),
              hr()
            ),
            
            # Step 4: Upload Annotations (Optional)
            div(
              class = "upload-step",
              h5("Step 4: Gene Annotations", icon("book"), 
                 span("(Optional)", class = "badge badge-secondary ml-2")),
              p("Columns: GeneID, GeneName, Chr"),
              uiOutput("annotation_upload_ui")
            )
          )
        ),
        
        # Middle panel - Orthology
        column(
          width = 4,
          div(
            class = "sidebar-panel",
            h4("Orthology Mapping", class = "mb-4"),
            
            div(
              class = "upload-step",
              h5("Step 5: Define Orthology", icon("sitemap")),
              p("How genes relate across your species"),
              
              radioButtons(
                "orthology_source",
                "Orthology data source:",
                choices = list(
                  "Upload OrthoFinder output" = "orthofinder",
                  "Upload custom orthology table" = "custom",
                  "No orthology (single species)" = "none",
                  "Use demo data" = "default"
                ),
                selected = "none"
              ),
              
              conditionalPanel(
                condition = "input.orthology_source == 'orthofinder'",
                fileInput("upload_orthogroups", "Orthogroups.tsv:",
                          accept = c(".tsv", ".txt")),
                fileInput("upload_hog", "N0.tsv (HOGs, optional):",
                          accept = c(".tsv", ".txt"))
              ),
              
              conditionalPanel(
                condition = "input.orthology_source == 'custom'",
                fileInput("upload_custom_ortho", "Custom orthology:",
                          accept = c(".tsv", ".txt", ".csv")),
                p(class = "text-muted small mt-2",
                  "Required: gene_id, species_code, orthogroup_id")
              ),
              
              conditionalPanel(
                condition = "input.orthology_source == 'none'",
                div(class = "alert alert-info",
                    icon("info-circle"),
                    " Single-species mode. Cross-species features will be disabled.")
              ),
              hr()
            ),
            
            # Action buttons
            div(
              class = "mt-4",
              actionButton("validate_uploads", "Validate Data",
                           icon = icon("check-circle"),
                           class = "btn btn-info w-100 mb-2"),
              actionButton("process_uploads", "Process & Load",
                           icon = icon("cogs"),
                           class = "btn btn-success w-100 mb-2",
                           disabled = TRUE),
              actionButton("reset_to_default", "Use Demo Data",
                           icon = icon("undo"),
                           class = "btn btn-warning w-100")
            )
          )
        ),
        
        # Right panel - Validation
        column(
          width = 4,
          div(
            class = "results-panel",
            h4("Validation & Preview", class = "mb-4"),
            
            div(
              id = "validation_summary",
              style = "min-height: 200px;",
              uiOutput("validation_results")
            ),
            
            # Preview tabs
            div(
              class = "mt-4",
              tabsetPanel(
                id = "upload_preview_tabs",
                tabPanel("Expression", DTOutput("upload_expr_preview")),
                tabPanel("Samples", DTOutput("upload_sample_preview")),
                tabPanel("Annotations", DTOutput("upload_anno_preview")),
                tabPanel("Orthology", DTOutput("upload_ortho_preview"))
              )
            ),
            
            # Download section
            conditionalPanel(
              condition = "output.data_processed == true",
              div(
                class = "mt-4",
                h5("Export Configuration"),
                downloadButton("download_config", "Download Config",
                               class = "btn btn-primary w-100 mb-2"),
                downloadButton("download_processed_rdata", "Download RData",
                               class = "btn btn-secondary w-100")
              )
            )
          )
        )
      )
    )
  ),
  #dynamic species analysis tabs
  nav_panel(
    title = "Species Analysis",
    value = "species_analysis_container",
    uiOutput("dynamic_species_panels")
  ),
  
  
  
  #combined view tab
  nav_panel(
    "Combined View",
    fluidRow(
      column(
        width = 3,
        div(
          class = "sidebar-panel",
          h4("Combined Analysis"),
          textInput(
            "combined_genename",
            "Gene name or ID:",
            placeholder = "e.g., PHO4, MSN2"
          ),
          actionButton(
            "combined_search_button",
            "Search Gene",
            icon = icon("search"),
            class = "custom-button"
          ),
          
          # Enhanced orthogroup selection container
          div(
            id = "combined_orthogroup_container",
            style = "display: none;",
            hr(),
            div(
              class = "orthogroup-info",
              h5("Select Genes from Orthogroup"),
              p("Choose one or more genes per species to compare:"),
              
              # Information about paralog selection
              div(
                id = "paralog_info",
                class = "alert alert-info mb-3",
                style = "font-size: 0.9em;",
                icon("info-circle"),
                " When multiple paralogs exist, you can select multiple genes to compare their expression patterns."
              ),
              #dynamic div
              div(
                id = "combined_orthogroup_selection_wrapper"
                #containers will be added dynamically by observers
              )
            ),
            
            # Add a summary of selections
            div(
              id = "selection_summary",
              class = "mt-3 p-2 bg-light rounded",
              style = "font-size: 0.9em;",
              uiOutput("combined_selection_summary")
            )
          ),
          
          uiOutput("species_select_ui"),
          actionButton(
            "combined_plot_button",
            "Generate Combined Plot",
            icon = icon("chart-line"),
            class = "custom-button"
          ),
          
          # Download button for the plot
          downloadButton(
            "download_combined_plot",
            "Download Plot",
            class = "btn btn-secondary mt-2 w-100"
          )
        )
      ),
      column(
        width = 9,
        div(
          class = "results-panel",
          plotlyOutput("combined_gene_plot", height = "600px"),
          div(
            class = "mt-4",
            h5("Orthogroup Information"),
            DTOutput("combined_orthogroup_table")
          )
        )
      )
    )
  ),
  
  # gene group Analysis tab
  nav_panel(
    "Gene Group Analysis",
    fluidRow(
      column(
        width = 3,
        div(
          class = "sidebar-panel",
          h4("Gene Group Analysis Controls"),
          
          #pathway comparison mode toggle
          checkboxInput(
            "enable_pathway_comparison",
            label = div(
              icon("th"),
              strong(" Multi-Pathway Comparison Mode"),
              style = "display: inline;"
            ),
            value = FALSE
          ),
          
          #conditional UI for single vs multi-pathway mode
          conditionalPanel(
            condition = "input.enable_pathway_comparison == false",
            fileInput(
              "gene_group_file",
              "Upload Gene Groups (CSV)",
              accept = c("text/csv", ".csv")
            ),
            textAreaInput(
              "gene_list",
              "Or paste gene list:",
              rows = 5,
              placeholder = "Enter genes, one per line"
            )
          ),
          
          conditionalPanel(
            condition = "input.enable_pathway_comparison == true",
            div(
              class = "alert alert-info py-2 px-3 mb-3",
              style = "font-size: 0.9em;",
              icon("info-circle"),
              strong(" Pathway Format:"),
              br(),
              "Pathway Name",
              br(),
              "GENE1, GENE2, GENE3",
              br(),
              tags$small("Separate pathways with blank line")
            ),
            textAreaInput(
              "pathway_definitions",
              "Define Pathways:",
              rows = 15,
              placeholder = "Ribophagy\nATG11, ATG19, UBI4, RPN4\n\nMitophagy\nATG11, ATG32, ATG33\n\nPexophagy\nATG11, ATG30, ATG36, PEX3"
            ),
            fileInput(
              "pathway_file",
              "Or upload pathway file:",
              accept = c("text/plain", ".txt")
            )
          ),
          
          #cross-species ortholog analysis checkbox
          div(
            class = "ortholog-analysis-panel",
            checkboxInput(
              "enable_ortholog_analysis",
              label = div(
                icon("sitemap"),
                strong(" Cross-Species Ortholog Analysis"),
                style = "display: inline;"
              ),
              value = FALSE
            ),
            div(
              style = "margin-left: 25px; font-size: 0.9em; color: #6c757d;",
              "When checked:",
              tags$ul(
                style = "margin-top: 5px; margin-bottom: 5px;",
                tags$li("Maps genes to orthologs across species"),
                tags$li("Shows coverage badges for each species"),
                tags$li("Enables multi-species expression comparison")
              )
            ),
            #remap button (only shows when ortholog analysis is enabled)
            conditionalPanel(
              condition = "input.enable_ortholog_analysis == true",
              div(
                class = "mt-2 mb-2",
                actionButton(
                  "remap_orthologs",
                  "Update Ortholog Mapping",
                  icon = icon("sync-alt"),
                  class = "btn btn-warning btn-sm w-100"
                ),
                downloadButton(
                  "download_coverage_stats",
                  "Download Coverage Stats",
                  class = "btn btn-secondary btn-sm w-100 mt-2"
                ),
                tags$small(
                  class = "text-muted d-block mt-1",
                  "Click after changing gene list to refresh mappings"
                )
              )
            ),
            #ortholog mapping results (appears after mapping)
            div(
              id = "ortholog_mapping_results",
              style = "display: none; margin-top: 10px;",
              uiOutput("ortholog_coverage_summary"),
              
              #paralog selection interface
              div(
                class = "mt-3 mb-3 p-3",
                style = "border: 1px solid #ddd; border-radius: 4px; background-color: #f8f9fa;",
                h6(icon("check-square"), " Select Orthologs to Plot"),
                tags$small(class = "text-muted d-block mb-2",
                           "Choose which orthologs to include in visualization"),
                uiOutput("paralog_selection_ui"),
                actionButton(
                  "select_all_paralogs",
                  "Select All",
                  icon = icon("check-double"),
                  class = "btn btn-sm btn-secondary mt-2 me-2"
                ),
                actionButton(
                  "select_first_paralogs",
                  "Select First Only",
                  icon = icon("check"),
                  class = "btn btn-sm btn-secondary mt-2"
                )
              ),
              
              actionButton(
                "view_ortholog_details",
                "View Detailed Mapping",
                icon = icon("table"),
                class = "btn btn-sm btn-info w-100 mt-2"
              )
            )
          ),
          
          uiOutput("group_analysis_species_ui"),
          
          #conditional controls based on mode
          conditionalPanel(
            condition = "input.enable_pathway_comparison == false",
            selectInput(
              "distance_method",
              "Clustering Method:",
              choices = list(
                "Pearson Correlation" = "pearson",
                "Euclidean" = "euclidean"
              ),
              selected = "pearson"
            ),
            selectInput(
              "data_transform",
              "Data Transformation:",
              choices = list(
                "Raw log2CPM" = "raw",
                "Centered log2CPM" = "centered",
                "Z-score" = "zscore"
              ),
              selected = "centered"
            ),
            selectInput(
              "group_viz_type",
              "Visualization Type:",
              choices = list(
                "Line Plot" = "line",
                "Bar Chart" = "bar",
                "Heatmap" = "heatmap"
              )
            )
          ),
          
          #pathway comparison specific controls
          conditionalPanel(
            condition = "input.enable_pathway_comparison == true",
            selectInput(
              "pathway_value_type",
              "Heatmap Values:",
              choices = list(
                "Fold-Change from Baseline (t=0)" = "foldchange",
                "Absolute Expression" = "absolute"
              ),
              selected = "foldchange"
            ),
            checkboxInput(
              "cluster_pathways",
              "Cluster Pathways",
              value = FALSE
            ),
            selectInput(
              "timepoint_display_mode",
              "Timepoint Display:",
              choices = list(
                "All Timepoints" = "all",
                "Comparable Only" = "comparable"
              ),
              selected = "all"
            )
          ),
          
          # significance testing control
          div(
            id = "significance_controls",
            style = "margin-top: 15px; padding-top: 10px; border-top: 1px solid #ccc;",
            h5("Significance Testing"),
            
            # Toggle significance markers
            checkboxInput(
              "show_significance",
              "Show Statistical Significance",
              value = TRUE
            ),
            
            # Only show other controls if significance is enabled
            conditionalPanel(
              condition = "input.show_significance == true && input.group_viz_type == 'bar'",
              
              # P-value threshold slider
              sliderInput(
                "significance_threshold",
                "P-value Threshold:",
                min = 0.001,
                max = 0.05,
                value = 0.05,
                step = 0.001
              ),
              
              # Gene selector for significance testing
              selectizeInput(
                "sig_test_gene",
                "Select Gene to Test:",
                choices = NULL,  # Will be populated dynamically
                options = list(
                  placeholder = "Select a gene"
                )
              ),
              
              # Timepoint pair selector
              selectizeInput(
                "sig_test_timepoints",
                "Select Timepoint Comparison:",
                choices = NULL,  # Will be populated dynamically
                multiple = TRUE,
                options = list(
                  placeholder = "Select timepoint pairs to compare",
                  maxItems = 3  # Limit to 3 comparisons at a time
                )
              ),
              
              # Add button to apply the selection
              actionButton(
                "apply_sig_test",
                "Apply Significance Test",
                class = "btn btn-primary btn-sm w-100 mt-2"
              )
            )
          ),
          
          #aggregation level control (only shown when ortholog analysis is enabled)
          conditionalPanel(
            condition = "input.enable_ortholog_analysis == true",
            radioButtons(
              "aggregation_level",
              "Aggregation Level:",
              choices = list(
                "Individual genes" = "genes",
                "Mean per species" = "species_mean"
              ),
              selected = "genes"
            )
          ),
          
          actionButton(
            "analyze_gene_groups",
            "Generate Visualization",
            icon = icon("chart-line"),
            class = "custom-button"
          ),
          downloadButton(
            "download_group_plot",
            "Download Plot",
            class = "btn btn-secondary mt-2 w-100"
          ),
          conditionalPanel(
            condition = "input.enable_pathway_comparison == true",
            downloadButton(
              "download_pathway_data",
              "Download Pathway Data",
              class = "btn btn-secondary mt-2 w-100"
            )
          )
        )
      ),
      column(
        width = 9,
        div(
          class = "results-panel",
          plotlyOutput("gene_group_plot", height = "500px"),
          uiOutput("pathway_table_legend"),
          div(
            class = "mt-4",
            DTOutput("gene_group_table")
          ),
          
          # Significance legend
          conditionalPanel(
            condition = "input.show_significance == true && input.group_viz_type == 'bar'",
            div(
              class = "mt-3 p-3",
              style = "background-color: var(--bs-body-bg); border-radius: 4px; border: 1px solid var(--bs-border-color);",
              h5("Significance Legend", style = "margin-top: 0;"),
              tags$ul(
                style = "padding-left: 20px; margin-bottom: 5px;",
                tags$li("* : p < 0.05"),
                tags$li("** : p < 0.01"),
                tags$li("*** : p < 0.001")
              ),
              p("Statistical analysis based on unpaired t-test between timepoints.", 
                style = "font-size: 12px; margin-bottom: 0;")
            )
          )
        )
      )
    )
  ),
  
  # Updated PCA tab with removed color by and data transformation options
  nav_panel(
    "PCA",
    fluidRow(
      column(
        width = 3,
        div(
          class = "sidebar-panel",
          h4("PCA Controls"),
          radioButtons(
            "pca_type",
            "Analysis Type:",
            choices = list(
              "Single Species" = "single",
              "Multi-Species Comparison" = "multi"
            ),
            selected = "single"
          ),
          
          # Single species specific controls
          conditionalPanel(
            condition = "input.pca_type == 'single'",
            uiOutput("pca_species_ui")
          ),
          
          #multi-species aggregation method
          conditionalPanel(
            condition = "input.pca_type == 'multi'",
            selectInput(
              "hog_aggregation_method",
              "Multi-copy gene handling:",
              choices = list(
                "Eigengene" = "eigengene",
                "Mean expression" = "mean",
                "Median expression" = "median",
                "Single-copy genes only" = "single_only",
                "Highest expressed paralog" = "max_expr",
                "Most variable paralog" = "max_var",
                "Variance-weighted mean" = "var_weighted"
              ),
              selected = "eigengene"
            ),
            
            #info about the method
            div(
              class = "alert alert-info mt-2",
              style = "font-size: 0.85em; padding: 8px 12px;",
              uiOutput("hog_aggregation_info")
            )
          ),
          
          actionButton(
            "run_pca",
            "Run PCA",
            icon = icon("play"),
            class = "custom-button"
          ),
          
          # Add download button for the orthology matrix
          conditionalPanel(
            condition = "input.pca_type == 'multi'",
            downloadButton(
              "download_orthology_matrix",
              "Export Expression Matrix",
              class = "btn btn-secondary mt-3 w-100"
            )
          )
        )
      ),
      column(
        width = 9,
        div(
          class = "results-panel",
          plotlyOutput("pca_plot", height = "500px"),
          verbatimTextOutput("pca_debug_output")
        )
      )
    )
  ),
  
  # Cross-Species Heatmap tab 
  nav_panel(
    "Cross-Species Heatmap",
    fluidRow(
      column(
        width = 3,
        div(
          class = "sidebar-panel",
          h4("Gene Set Controls"),
          textAreaInput(
            "ortholog_gene_list",
            "Enter gene list:",
            rows = 5,
            placeholder = "Enter genes, one per line (e.g., PHO4, PHO81, PHO84)"
          ),
          fileInput(
            "ortholog_gene_file",
            "Or upload gene list (text file):",
            accept = c("text/plain", ".txt", ".csv")
          ),
          selectInput(
            "ortholog_normalization",
            "Data Normalization:",
            choices = list(
              "Z-score (by gene)" = "zscore",
              "Centered (by gene)" = "centered",
              "Raw log2CPM values" = "raw"
            ),
            selected = "zscore"
          ),
          checkboxInput(
            "ortholog_cluster_rows",
            "Cluster genes (rows)",
            value = TRUE
          ),
          checkboxInput(
            "ortholog_cluster_cols",
            "Cluster timepoints (columns)",
            value = FALSE
          ),
          actionButton(
            "generate_ortholog_heatmap",
            "Generate Heatmap",
            icon = icon("chart-line"),
            class = "custom-button"
          ),
          downloadButton(
            "download_ortholog_heatmap",
            "Download Heatmap",
            class = "btn btn-secondary mt-2 w-100"
          ),
          downloadButton(
            "download_ortholog_data",
            "Download Data Matrix",
            class = "btn btn-secondary mt-2 w-100"
          )
        )
      ),
      column(
        width = 9,
        div(
          class = "results-panel",
          plotlyOutput("ortholog_heatmap_plot", height = "500px"),
          div(
            class = "mt-4",
            h5("Ortholog Mapping Table"),
            DTOutput("ortholog_mapping_table")
          )
        )
      )
    )
  ),
  
  # Ridgeline Plots tab
  nav_panel(
    "Ridgeline Plots",
    fluidRow(
      column(
        width = 3,
        div(
          class = "sidebar-panel",
          h4("Ridgeline Plot Controls"),
          uiOutput("ridgeline_species_ui"),
          selectInput(
            "ridgeline_view",
            "View Type:",
            choices = list(
              "Expression Distribution" = "distribution",
              "Gene Count Above Threshold" = "count"
            ),
            selected = "distribution"
          ),
          sliderInput(
            "expression_threshold",
            "Expression Threshold:",
            min = 0,
            max = 10,
            value = 2,
            step = 0.5
          ),
          actionButton(
            "generate_ridgeline",
            "Generate Plot",
            icon = icon("chart-line"),
            class = "custom-button"
          ),
          downloadButton(
            "download_ridgeline",
            "Download Plot",
            class = "btn btn-secondary mt-2 w-100"
          )
        )
      ),
      column(
        width = 9,
        div(
          class = "results-panel",
          plotOutput("ridgeline_plot", height = "600px")
        )
      )
    )
  )
)
```

```{r server_definition, echo=FALSE}
server <- function(input, output, session) {
  # Theme state
  is_dark <- reactiveVal(FALSE)
  containers_update_needed <- reactiveVal(TRUE)
  
  #centralized container management
  manage_combined_containers <- function(config) {
    removeUI("#combined_orthogroup_selection_wrapper > *", multiple = TRUE, immediate = TRUE)
    
    for (sp_id in names(reactiveValuesToList(existing_containers))) {
      existing_containers[[sp_id]] <- NULL
    }
    
    for (sp_id in names(config)) {
      if (is.null(existing_containers[[sp_id]])) {
        insertUI(
          selector = "#combined_orthogroup_selection_wrapper",
          where = "beforeEnd",
          ui = div(
            id = paste0("combined_", sp_id, "_selection_ui"),
            class = "orthogroup-species mb-3"
          ),
          immediate = TRUE
        )
        existing_containers[[sp_id]] <- TRUE
      }
    }
  }
  
  observe({
    if (containers_update_needed()) {
      containers_update_needed(FALSE)
      config <- current_species_config()
      manage_combined_containers(config)
    }
  })
  #dynamic combined species 
  observeEvent(upload_state$processed, {
    if (upload_state$processed && data_source() == "custom") {
      containers_update_needed(TRUE)
    }
  })
  
  # New code (lines 2863-2867)
  observeEvent(data_source(), {
    config <- current_species_config()
    manage_combined_containers(config)
  }, ignoreInit = TRUE)
  
  
  #aggregation method info text
  output$hog_aggregation_info <- renderUI({
    req(input$hog_aggregation_method)
    
    info_text <- switch(input$hog_aggregation_method,
                        "single_only" = tagList(
                          icon("filter"), 
                          " Uses only genes with 1:1:1:1 orthology. Most conservative, excludes ~40-60% of HOGs."
                        ),
                        "mean" = tagList(
                          icon("calculator"),
                          " Averages expression across all paralogs. Simple and interpretable."
                        ),
                        "median" = tagList(
                          icon("chart-line"),
                          " Uses median expression. Robust to outlier paralogs (e.g., pseudogenes)."
                        ),
                        "eigengene" = tagList(
                          icon("project-diagram"),
                          strong(" Computes first PC to capture dominant pattern.")
                        ),
                        "max_expr" = tagList(
                          icon("arrow-up"),
                          " Selects most highly expressed paralog. Assumes dominant copy drives function."
                        ),
                        "max_var" = tagList(
                          icon("signal"),
                          " Selects most variable paralog. Focuses on dynamic genes, most informative for PCA."
                        ),
                        "var_weighted" = tagList(
                          icon("balance-scale"),
                          " Weights paralogs by expression variance. Compromise between mean and eigengene."
                        ),
                        ""
    )
    
    info_text
  })
  
  output$ridgeline_species_ui <- renderUI({
    config <- current_species_config()
    choices <- c(
      "All Species" = "all",
      setNames(names(config), sapply(config, `[[`, "name"))
    )
    selectInput(
      "ridgeline_species",
      "Select Species:",
      choices = choices,
      selected = "all"
    )
  })
  
  output$pca_species_ui <- renderUI({
    config <- current_species_config()
    choices <- setNames(
      names(config),
      sapply(config, `[[`, "name")
    )
    selectInput(
      "pca_species",
      "Select Species:",
      choices = choices,
      selected = names(config)[1]
    )
  })
  # Generate dynamic species menu (hidden in cross-species mode)
  output$group_analysis_species_ui <- renderUI({
    #hide when cross-species ortholog analysis is enabled
    if (!is.null(input$enable_ortholog_analysis) && input$enable_ortholog_analysis) {
      return(NULL)
    }
    
    config <- current_species_config()
    choices <- setNames(
      names(config),
      sapply(config, `[[`, "name")
    )
    selectInput(
      "group_analysis_species",
      "Select Species:",
      choices = choices,
      selected = names(config)[1]
    )
  })
  output$dynamic_species_menu <- renderUI({
    config <- current_species_config()
    
    if (length(config) == 0) {
      return(p("No species configured. Please upload data."))
    }
    
    # Create nav_menu dynamically
    menu_items <- lapply(names(config), function(id) {
      species <- c(list(id = id), config[[id]])
      nav_panel(
        title = species$name,
        value = paste0("species_", id),
        create_species_panel(species)
      )
    })
    
    # Return as nav_menu
    do.call(nav_menu, c(list(title = "Species Analysis"), menu_items))
  })
  
  # Generate species selection for combined view
  output$species_select_ui <- renderUI({
    config <- current_species_config()
    checkboxGroupInput(
      "species_select",
      "Select Species to Plot:",
      choices = setNames(
        names(config),
        sapply(config, `[[`, "name")
      ),
      selected = names(config)
    )
  })
  # Upload state management
  upload_state <- reactiveValues(
    validated = FALSE,
    processed = FALSE,
    validation_errors = list(),
    validation_warnings = list(),
    uploaded_data = list(),
    custom_all_species_data = NULL
  )
  
  #ortholog analysis state
  ortholog_state <- reactiveValues(
    mapped = FALSE,
    ortholog_data = NULL,
    coverage_stats = NULL,
    gene_mapping = NULL,
    multi_species_data = NULL,
    selected_orthologs = list()
  )
  # This manages the user-defined species list
  species_list <- reactiveValues(
    count = 1,
    entries = list(),
    config = list()
  )
  
  # Observer to add new species input fields
  observeEvent(input$add_species, {
    new_count <- species_list$count + 1
    species_list$count <- new_count
    
    insertUI(
      selector = "#species_input_area",
      where = "beforeEnd",
      ui = div(
        class = "species-entry mb-2",
        id = paste0("species_entry_", new_count),
        fluidRow(
          column(3, 
                 textInput(paste0("species_code_", new_count), "Code*", 
                           value = "", placeholder = "e.g., at")),
          column(5, 
                 textInput(paste0("species_name_", new_count), "Full Name*", 
                           value = "", placeholder = "e.g., Arabidopsis thaliana")),
          column(4, 
                 textInput(paste0("species_short_", new_count), "Display Name", 
                           value = "", placeholder = "e.g., Arabidopsis"))
        )
      )
    )
  })
  
  # Observer to remove species input fields
  observeEvent(input$remove_species, {
    if (species_list$count > 1) {
      removeUI(
        selector = paste0("#species_entry_", species_list$count),
        immediate = TRUE
      )
      species_list$count <- species_list$count - 1
    } else {
      showNotification("Must have at least one species", type = "warning")
    }
  })
  
  # Reactive to collect all defined species
  defined_species <- reactive({
    species_data <- list()
    
    for (i in 1:species_list$count) {
      code <- trimws(input[[paste0("species_code_", i)]])
      name <- trimws(input[[paste0("species_name_", i)]])
      short <- trimws(input[[paste0("species_short_", i)]])
      
      if (!is.null(code) && code != "") {
        # Auto-generate short name if not provided
        if (is.null(short) || short == "") {
          # Try to create abbreviated form (e.g., "H. sapiens" from "Homo sapiens")
          name_parts <- strsplit(name, " ")[[1]]
          if (length(name_parts) >= 2) {
            short <- paste0(substr(name_parts[1], 1, 1), ". ", 
                            paste(name_parts[-1], collapse = " "))
          } else {
            short <- name
          }
        }
        
        species_data[[code]] <- list(
          code = code,
          name = if(!is.null(name) && name != "") name else code,
          short = short
        )
      }
    }
    
    species_data
  })
  
  # Dynamic species configuration
  current_species_config <- reactive({
    if (data_source() == "custom" && length(defined_species()) > 0) {
      defined_species()
    } else {
      DEFAULT_SPECIES_CONFIG
    }
  })
  #dynamic color assignment to sps (will add more colors if needed) 
  species_colors_dynamic <- reactive({
    config <- current_species_config()
    colors <- list()
    
    # Use a diverse color palette for automatic assignment
    auto_colors <- c("#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", 
                     "#FFEAA7", "#DDA0DD", "#98D8C8", "#F7DC6F",
                     "#BB8FCE", "#85C1E2", "#F8B739", "#52BE80",
                     "#E74C3C", "#3498DB", "#9B59B6", "#1ABC9C")
    
    color_index <- 1
    
    for (sp_code in names(config)) {
      sp_short <- config[[sp_code]]$short
      
      # Check if this species has a predefined color
      if (sp_short %in% names(DEFAULT_SPECIES_COLORS)) {
        colors[[sp_short]] <- DEFAULT_SPECIES_COLORS[[sp_short]]
      } else {
        # Assign from auto_colors palette
        colors[[sp_short]] <- auto_colors[color_index]
        color_index <- ((color_index - 1) %% length(auto_colors)) + 1
      }
    }
    
    colors
  })
  
  # Display current species table
  output$current_species_table <- renderTable({
    species <- defined_species()
    if (length(species) > 0) {
      df <- data.frame(
        Code = sapply(species, `[[`, "code"),
        `Scientific Name` = sapply(species, `[[`, "name"),
        `Display Name` = sapply(species, `[[`, "short"),
        stringsAsFactors = FALSE,
        check.names = FALSE
      )
      df
    } else {
      data.frame(Note = "No species defined yet. Add at least one species above.")
    }
  }, striped = TRUE, hover = TRUE, spacing = "xs")
  
  #expression upload UI based on defined species
  output$expression_upload_ui <- renderUI({
    species <- defined_species()
    
    if (length(species) == 0) {
      return(div(class = "text-muted", icon("arrow-up"), 
                 " Define species in Step 1 first"))
    }
    
    upload_inputs <- lapply(names(species), function(sp_code) {
      sp_info <- species[[sp_code]]
      div(
        class = "mb-2",
        fileInput(
          paste0("upload_", sp_code, "_expr"),
          paste0(sp_info$name, " (", sp_code, "):"),
          accept = c(".tsv", ".txt", ".csv"),
          width = "100%"
        )
      )
    })
    
    do.call(tagList, upload_inputs)
  })
  
  # Generate sample metadata upload UI
  output$sample_upload_ui <- renderUI({
    species <- defined_species()
    
    if (length(species) == 0) {
      return(div(class = "text-muted", icon("arrow-up"),
                 " Define species in Step 1 first"))
    }
    
    upload_inputs <- lapply(names(species), function(sp_code) {
      sp_info <- species[[sp_code]]
      div(
        class = "mb-2",
        fileInput(
          paste0("upload_", sp_code, "_samples"),
          paste0(sp_info$name, " (", sp_code, "):"),
          accept = c(".tsv", ".txt", ".csv"),
          width = "100%"
        )
      )
    })
    
    do.call(tagList, upload_inputs)
  })
  
  # Generate annotation upload UI
  output$annotation_upload_ui <- renderUI({
    species <- defined_species()
    
    if (length(species) == 0) {
      return(div(class = "text-muted", icon("arrow-up"),
                 " Define species in Step 1 first"))
    }
    
    upload_inputs <- lapply(names(species), function(sp_code) {
      sp_info <- species[[sp_code]]
      div(
        class = "mb-2",
        fileInput(
          paste0("upload_", sp_code, "_anno"),
          paste0(sp_info$name, " (", sp_code, "):"),
          accept = c(".tsv", ".txt", ".csv"),
          width = "100%"
        )
      )
    })
    
    do.call(tagList, upload_inputs)
  })

  #data source toggle
  data_source <- reactiveVal("default")
  
  #clear cache when data source changes
  observeEvent(data_source(), {
    clear_performance_cache()
    debug_print("Performance cache cleared")
  }, ignoreInit = TRUE)
  
  #get appropriate species data
  get_all_species_data <- reactive({
    if (data_source() == "custom" && !is.null(upload_state$custom_all_species_data)) {
      return(upload_state$custom_all_species_data)
    } else {
      return(all_species_data)
    }
  })
  
  # Reactive values for combined selections - dynamically initialized
  combined_selections <- reactiveValues()
  existing_containers <- reactiveValues()
  
  observe({
    config <- current_species_config()
    for (sp_id in names(config)) {
      if (is.null(combined_selections[[sp_id]])) {
        combined_selections[[sp_id]] <- character(0)
      }
    }
    
    existing_species <- names(reactiveValuesToList(combined_selections))
    for (sp_id in existing_species) {
      if (!sp_id %in% names(config)) {
        combined_selections[[sp_id]] <- NULL
      }
    }
  })
  
  # Reactive values for storing query results
  query_results <- reactiveValues()
  selected_genes <- reactiveValues()
  
  global_query_state <- reactiveValues(
    current_query = NULL,
    query_result = NULL,
    tree_data = NULL,
    last_search_time = NULL
  )
  
  #restore session on startup
  observeEvent(input$restore_session, {
    req(input$restore_session)
    
    debug_print("restore session triggered")
    
    state <- input$restore_session$state
    saved_at <- input$restore_session$saved_at
    time_ago <- format_time_ago(saved_at)
    
    debug_print(paste("restoring state from", time_ago))
    debug_print(paste("state contents:", paste(names(state), collapse = ", ")))
    
    #delay restoration to ensure UI elements are rendered
    shinyjs::delay(500, {
      restore_session_state(state, selected_genes, query_results, global_query_state, combined_selections, ortholog_state, session)
      
      debug_print("state restored, showing notification")
      
      showNotification(
        ui = tagList(
          icon("check-circle"),
          span(paste("Session restored (saved", time_ago, ")")),
          actionButton(
            "clear_session_btn",
            "Start Fresh",
            class = "btn-sm btn-warning",
            style = "margin-left: 10px;"
          )
        ),
        duration = 8,
        type = "message",
        id = "session_restored"
      )
    })
  }, once = TRUE)
  
  #track initialization state to prevent saving empty data
  session_initialized <- reactiveVal(FALSE)
  
  #mark session as ready after short delay
  observe({
    invalidateLater(2000)
    isolate({
      session_initialized(TRUE)
      debug_print("session initialized, auto-save enabled")
    })
  }) %>% bindEvent(TRUE, once = TRUE)
  
  #auto-save session after changes
  observe({
    req(session_initialized())
    
    #reactive dependencies that trigger save
    deps <- list(
      selected = reactiveValuesToList(selected_genes),
      queries = reactiveValuesToList(query_results),
      combined = reactiveValuesToList(combined_selections),
      current_query = global_query_state$current_query,
      gene_list = input$gene_list,
      ortholog_enabled = input$enable_ortholog_analysis,
      nav = input$nav,
      species = input$group_analysis_species,
      viz = input$group_viz_type,
      distance = input$distance_method,
      transform = input$data_transform,
      aggregation = input$aggregation_level
    )
    
    isolate({
      if (is.null(deps$nav)) return()
      
      current_state <- list(
        version = "1.0",
        timestamp = format(Sys.time(), "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC"),
        selected_genes = deps$selected,
        query_results = deps$queries,
        current_query = deps$current_query,
        combined_selections = deps$combined,
        gene_list = deps$gene_list,
        enable_ortholog_analysis = deps$ortholog_enabled,
        current_tab = deps$nav,
        group_analysis_species = deps$species,
        group_viz_type = deps$viz,
        distance_method = deps$distance,
        data_transform = deps$transform,
        aggregation_level = deps$aggregation,
        ortholog_selected = if (exists("ortholog_state")) ortholog_state$selected_orthologs else NULL
      )
      
      session$sendCustomMessage(type = "saveSession", message = current_state)
      debug_print("session state saved")
    })
  }) %>% debounce(2000)
  
  #handle start fresh button
  observeEvent(input$clear_session_btn, {
    session$sendCustomMessage(type = "clearSession", message = list())
  })
  
  
  #helper function to update combined species table
  update_combined_table <- function(query_results, combined_selections, is_dark) {
    if (is.null(query_results$combined)) return(NULL)
    
    result <- query_results$combined
    config <- current_species_config()
    
    #collect data in list first, then combine once
    genes_list <- lapply(names(result$genes_by_species), function(sp) {
      sp_data <- result$genes_by_species[[sp]]
      if (nrow(sp_data) == 0) return(NULL)
      
      sp_data$Species <- if(sp %in% names(config)) config[[sp]]$short else sp
      
      #add a column to indicate currently selected gene(s)
      selected_genes <- combined_selections[[sp]]
      if (is.null(selected_genes)) selected_genes <- character(0)
      sp_data$Selected <- sp_data$gene_id %in% selected_genes
      
      sp_data[, c("Species", "gene_id", "gene_name", "Selected")]
    })
    
    #combine all at once
    all_genes <- rbindlist(Filter(Negate(is.null), genes_list), fill = TRUE)
    
    if (nrow(all_genes) == 0) return(NULL)
    
    dt <- datatable(
      all_genes[, c("Species", "gene_id", "gene_name")],
      options = list(
        pageLength = 10,
        scrollX = TRUE,
        dom = 'tp'
      ),
      colnames = c("Species", "Gene ID", "Gene Name"),
      rownames = FALSE
    )
    
    # Highlight selected genes
    if (any(all_genes$Selected)) {
      dt <- dt %>% formatStyle(
        columns = 1:3,
        target = "row",
        backgroundColor = styleRow(which(all_genes$Selected), 
                                   if(is_dark()) "#3a4a5a" else "#e6f3ff")
      )
    }
    
    return(dt)
  }
  
  # Observe for gene group analysis (bar plot significance testing)
  observe({
    req(input$gene_list, input$group_viz_type == "bar")
    
    # Parse gene list from textarea
    gene_list <- strsplit(trimws(input$gene_list), "[\n\r]+")[[1]]
    gene_list <- gene_list[gene_list != ""]
    
    updateSelectizeInput(
      session,
      "sig_test_gene",
      choices = setNames(gene_list, gene_list),
      selected = NULL
    )
  })
  
  observe({
    req(input$sig_test_gene, input$group_viz_type == "bar")
    
    # Create all possible timepoint pairs
    timepoint_pairs <- combn(TIME_POINTS, 2, simplify = FALSE)
    comparisons <- sapply(timepoint_pairs, function(pair) {
      paste(pair[1], "vs.", pair[2])
    })
    
    updateSelectizeInput(
      session,
      "sig_test_timepoints",
      choices = setNames(comparisons, comparisons),
      selected = NULL
    )
  })
  
  observe({
    req(global_query_state$current_query)
    
    # Make the query result available to all tabs
    config <- current_species_config()
    for (species_id in names(config)) {
      if (!is.null(global_query_state$query_result)) {
        query_results[[species_id]] <- global_query_state$query_result
      }
    }
    
    # Also make it available for combined view
    if (!is.null(global_query_state$query_result)) {
      query_results$combined <- global_query_state$query_result
    }
  })
  
  # Modified extract_orthology_matrix for HOGs
  extract_orthology_matrix <- function() {
    # Get data for all species
    species_data_list <- list()
    config <- current_species_config()
    for (species_id in names(config)) {
      species_data_list[[species_id]] <- get_species_data(species_id)
    }
    
    # Get HOG data
    current_data <- get_all_species_data()
    og_data <- current_data$orthofinder$orthogroups
    
    # Find HOGs with all 4 species
    hog_summary <- og_data %>%
      mutate(species = case_when(
        grepl("^Y[A-P][LR]", gene_id) ~ "sc",
        grepl("^CAGL0", gene_id) ~ "cg",
        grepl("^orf19", gene_id) ~ "ca",
        grepl("^KLLA0", gene_id) ~ "kl"
      )) %>%
      group_by(hog_id) %>%
      summarise(
        n_species = n_distinct(species),
        .groups = 'drop'
      ) %>%
      filter(n_species == 4)
    
    common_hogs <- hog_summary$hog_id
    
    # Create sample metadata dynamically
    sample_metadata_list <- list()
    
    for (species_id in names(config)) {
      sp_data <- species_data_list[[species_id]]
      if (!is.null(sp_data)) {
        # Get the lcpm matrix (handle both naming conventions)
        lcpm_matrix <- if (!is.null(sp_data$lcpm)) sp_data$lcpm else sp_data[[paste0(species_id, "_lcpm")]]
        # Get sample info
        sample_info <- if (!is.null(sp_data$sample_info)) sp_data$sample_info else sp_data[[paste0(species_id, "_sample_info")]]
        
        if (!is.null(lcpm_matrix) && !is.null(sample_info)) {
          sample_metadata_list[[species_id]] <- data.frame(
            Sample = colnames(lcpm_matrix),
            Species = config[[species_id]]$short,
            Timepoint = sample_info$Timepoint,
            Replicate = sample_info$Replicate,
            stringsAsFactors = FALSE
          )
        }
      }
    }
    
    sample_metadata <- do.call(rbind, sample_metadata_list)
    
    # Create expression matrix
    sample_matrix <- matrix(NA, 
                           nrow = nrow(sample_metadata), 
                           ncol = length(common_hogs))
    rownames(sample_matrix) <- sample_metadata$Sample
    colnames(sample_matrix) <- common_hogs
    
    # Fill matrix with expression values
    for (i in 1:nrow(sample_metadata)) {
      sample_name <- sample_metadata$Sample[i]
      species <- sample_metadata$Species[i]
      config <- current_species_config()
      species_code <- NULL
      for (sp_id in names(config)) {
        if (config[[sp_id]]$short == species || config[[sp_id]]$name == species) {
          species_code <- sp_id
          break
        }
      }
      
      # Dynamic lcpm matrix retrieval
      sp_data <- species_data_list[[species_code]]
      lcpm_matrix <- if (!is.null(sp_data$lcpm)) {
        sp_data$lcpm
      } else if (!is.null(sp_data[[paste0(species_code, "_lcpm")]])) {
        sp_data[[paste0(species_code, "_lcpm")]]
      } else {
        NULL
      }
      
      for (j in 1:length(common_hogs)) {
        hog <- common_hogs[j]
        
        lookup_matches <- current_data$gene_lookup[species == species_code & hog_id == hog]
        hog_genes <- lookup_matches$gene_id
        
        if (length(hog_genes) > 0 && hog_genes[1] %in% rownames(lcpm_matrix)) {
          sample_matrix[i, j] <- lcpm_matrix[hog_genes[1], sample_name]
        }
      }
    }
    
    # Remove columns with NAs
    na_cols <- apply(sample_matrix, 2, function(x) any(is.na(x)))
    sample_matrix <- sample_matrix[, !na_cols]
    
    return(list(
      sample_matrix = sample_matrix,
      sample_metadata = sample_metadata,
      common_hogs = colnames(sample_matrix)
    ))
  }
  
  # PCA observer - with aggregation method support
  observeEvent(input$run_pca, {
    waiter_show(html = loading_screen)
    
    debug_cat("PCA type:", input$pca_type, "\n")
    if (input$pca_type == "multi") {
      debug_cat("Aggregation method:", input$hog_aggregation_method, "\n")
    }
    
    tryCatch({
      if (input$pca_type == "single") {
        debug_cat("Single-species PCA\n")
        species_data <- get_species_data(input$pca_species)
        
        #get expression matrix based on transformation
        lcpm_data <- get_expression_matrix(input$pca_species, input$global_transform, species_data)
        
        sample_info <- if(input$pca_species == "cg") {
          species_data$sample_info
        } else {
          species_data[[paste0(input$pca_species, "_sample_info")]]
        }
        
        if (is.null(lcpm_data) || is.null(sample_info)) {
          stop("Required data not found for selected species")
        }
        
        output$pca_plot <- renderPlotly({
          create_pca_plot(
            expression_matrix = lcpm_data,
            sample_info = sample_info,
            is_dark_mode = is_dark()
          )
        })
        
        # Add debugging output
        output$pca_debug_output <- renderPrint({
          cat("Single species PCA completed for:", input$pca_species, "\n")
          cat("Number of genes analyzed:", nrow(lcpm_data), "\n")
          cat("Number of samples:", ncol(lcpm_data), "\n")
          cat("Data transformation: centered-scaled\n")  
        })
        
      } else {
        debug_cat("Multi-species PCA\n")
        #multi-species PCA with selected aggregation method
        aggregation_method <- if (!is.null(input$hog_aggregation_method)) {
          input$hog_aggregation_method
        } else {
          "eigengene"  #default
        }
        
        plot_result <- create_multi_species_pca(
          get_species_data = get_species_data,
          is_dark_mode = is_dark(),
          aggregation_method = aggregation_method,
          species_config = current_species_config(),
          all_species_data_obj = get_all_species_data(),
          transform_type = input$global_transform
        )
        
        # Check if plot was created successfully
        if (!is.null(plot_result)) {
          output$pca_plot <- renderPlotly({
            plot_result
          })
          
          # Store matrices data for download
          pca_matrices_data <- attr(plot_result, "matrices_data")
          if (!is.null(pca_matrices_data)) {
            session$userData$pca_matrices <- pca_matrices_data
          }
        }
        
        # Add debugging output
        output$pca_debug_output <- renderPrint({
          cat("Multi-species PCA completed\n")
          cat("Aggregation method:", aggregation_method, "\n")
          
          method_desc <- switch(aggregation_method,
                                "single_only" = "Using SINGLE-COPY GENES ONLY",
                                "mean" = "Averaging expression across paralogs",
                                "median" = "Using median expression (robust to outliers)",
                                "eigengene" = "Computing eigengene (first PC) for each HOG",
                                "max_expr" = "Selecting highest expressed paralog per HOG",
                                "max_var" = "Selecting most variable paralog per HOG",
                                "var_weighted" = "Variance-weighted mean across paralogs",
                                "Unknown method"
          )
          cat(method_desc, "\n\n")
          
          if (!is.null(session$userData$pca_matrices)) {
            cat("Matrix dimensions:", 
                nrow(session$userData$pca_matrices$sample_matrix), "x",
                ncol(session$userData$pca_matrices$sample_matrix), "\n")
            cat("Total HOGs used:", ncol(session$userData$pca_matrices$sample_matrix), "\n")
            
            #show aggregation stats if available
            if (aggregation_method != "single_only" && 
                !is.null(session$userData$pca_matrices$aggregation_stats)) {
              cat("\nHOG composition:\n")
              for (sp in names(session$userData$pca_matrices$aggregation_stats)) {
                stats <- session$userData$pca_matrices$aggregation_stats[[sp]]
                cat("  ", sp, ": ", stats$single_copy, " single-copy, ", 
                    stats$multi_copy, " multi-copy\n", sep = "")
              }
            }
          }
        })
      }
      
    }, error = function(e) {
      debug_cat("PCA error:", e$message, "\n")
      showNotification(
        paste("Error in PCA analysis:", e$message),
        type = "error",
        duration = NULL
      )
      
      # Show error in the debug output
      output$pca_debug_output <- renderPrint({
        cat("ERROR in PCA analysis:\n")
        cat(e$message, "\n")
      })
    })
    
    waiter_hide()
  })

  
  # Theme toggle
  observeEvent(input$theme_toggle, {
    current_dark <- is_dark()
    is_dark(!current_dark)
    
    if (!current_dark) {
      # Switching to dark mode
      addCssClass("html", "dark-mode")
      updateActionButton(session, "theme_toggle",
                        icon = icon("sun", verify_fa = FALSE))
      session$setCurrentTheme(dark_theme)
    } else {
      # Switching to light mode
      removeCssClass("html", "dark-mode")
      updateActionButton(session, "theme_toggle",
                        icon = icon("moon", verify_fa = FALSE))
      session$setCurrentTheme(light_theme)
    }
  })
  
  # Help modal
  observeEvent(input$show_help, {
    showModal(modalDialog(
      title = "Gene Expression Analysis Tutorial",
      
      tags$div(
        style = "font-size: 16px;",
        
        tags$h4("Basic Usage"),
        tags$ul(
          tags$li("Enter a gene name or ID in the search box (e.g., PHO4)"),
          tags$li("Click 'Search Gene' to find orthogroup members"),
          tags$li("Select genes from the orthogroup to analyze"),
          tags$li("Click 'Generate Plot' to visualize gene expression")
        ),
        
        tags$h4("New Features"),
        tags$ul(
          tags$li(strong("HOG-based Orthology:"), " Genes are now grouped by Hierarchical Orthologous Groups"),
          tags$li(strong("Gene Selection:"), " Choose specific genes from orthogroups for analysis"),
          tags$li(strong("Flexible Queries:"), " Captures paralogs and gene families, not just 1:1 orthologs"),
          tags$li(strong("Legacy Fallback:"), " Still searches YGOB/CGOB if genes aren't found in HOGs")
        ),
        
        tags$h4("Plot Interactions"),
        tags$ul(
          tags$li("Hover over points to see exact values"),
          tags$li("Use the toolbar to zoom, pan, or save the plot"),
          tags$li("Click legend items to show/hide species or replicates")
        ),
        
        tags$h4("Tips"),
        tags$ul(
          tags$li("Use either systematic names (e.g., CAGL0D05170g) or standard names (e.g., PHO4)"),
          tags$li("When multiple orthologs exist, select the most relevant for your analysis"),
          tags$li("Tables can be sorted by clicking column headers")
        )
      ),
      
      easyClose = TRUE,
      footer = modalButton("Close"),
      size = "l"
    ))
  })
  
  #species data cache with composite key
  species_data_cache <- new.env()
  
  get_species_data <- function(species_id) {
    config <- current_species_config()
    current_source <- data_source()
    
    current_data <- if (current_source == "custom" && !is.null(upload_state$custom_all_species_data)) {
      upload_state$custom_all_species_data
    } else {
      all_species_data
    }
    
    #composite cache key includes data source to prevent stale data
    cache_key <- paste(species_id, current_source, sep = "_")
    
    if (!exists(cache_key, envir = species_data_cache)) {
      if (species_id %in% names(current_data)) {
        sp_config <- config[[species_id]]
        
        #strategy 1: direct naming (standard for uploaded data and cg)
        if (!is.null(current_data[[species_id]]$lcpm) || !is.null(current_data[[species_id]]$rlog)) {
          data <- current_data[[species_id]]
          
          if (is.null(data$species_name)) {
            data$species_name <- if(!is.null(sp_config$short)) sp_config$short else species_id
          }
          
          #add prefixed aliases for backward compatibility
          for (key in names(data)) {
            prefixed_key <- paste0(species_id, "_", key)
            if (is.null(data[[prefixed_key]])) {
              data[[prefixed_key]] <- data[[key]]
            }
          }
        } 
        #strategy 2: prefixed naming (for original sc, kl, ca data)
        else {
          data <- list(
            species_name = if(!is.null(sp_config$short)) sp_config$short else species_id
          )
          
          prefixed_keys <- names(current_data[[species_id]])
          prefix_pattern <- paste0("^", species_id, "_")
          
          for (key in prefixed_keys) {
            if (grepl(prefix_pattern, key)) {
              base_name <- sub(prefix_pattern, "", key)
              data[[key]] <- current_data[[species_id]][[key]]
              data[[base_name]] <- current_data[[species_id]][[key]]
            }
          }
        }
        
        #verify expression matrix exists
        has_expr_data <- any(sapply(names(data), function(nm) {
          obj <- data[[nm]]
          is.matrix(obj) || (is.data.frame(obj) && ncol(obj) > 5)
        }))
        
        if (!has_expr_data) {
          warning(paste("No expression data found for species:", species_id))
          return(NULL)
        }
        
        assign(cache_key, data, envir = species_data_cache)
      } else {
        return(NULL)
      }
    }
    get(cache_key, envir = species_data_cache)
  }
  
  # FIXED Combined view search handler
  observeEvent(input$combined_search_button, {
    waiter_show(html = loading_screen)
    
    gene <- trimws(input$combined_genename)
    
    if (gene == "") {
      showNotification("Please enter a gene name or ID", type = "warning")
      waiter_hide()
      return()
    }
    
    # Reset selections - store as character vectors to support multiple selections
    config <- current_species_config()
    for (sp_id in names(config)) {
      combined_selections[[sp_id]] <- character(0)
    }
    
    # Ensure containers exist for current configuration
    config <- current_species_config()
    
    # Check if containers need refresh
    if (length(names(existing_containers)) != length(names(config))) {
      manage_combined_containers(config)
    }
    
    # Search for the gene in all species
    found_in_species <- NULL
    config <- current_species_config()
    current_data <- get_all_species_data()
    for (species_id in names(config)) {
      species_data <- get_species_data(species_id)
      result <- query_gene_flexible(gene, species_data, current_data)
      if (!is.null(result) && result$source != "none") {
        found_in_species <- species_id
        query_results$combined <- result
        break
      }
    }
    
    if (!is.null(found_in_species)) {
      # Show orthogroup container
      shinyjs::show("combined_orthogroup_container")
      
      # Get current configuration
      config <- current_species_config()
      
      # Create selection UI for each species
      for (sp_id in names(config)) {
        local({
          species_id <- sp_id
          species_name <- config[[species_id]]$short
          
          # Check if this species has genes
          has_genes <- species_id %in% names(query_results$combined$genes_by_species) &&
                       !is.null(query_results$combined$genes_by_species[[species_id]]) &&
                       nrow(query_results$combined$genes_by_species[[species_id]]) > 0
          
          if (has_genes) {
            genes_df <- query_results$combined$genes_by_species[[species_id]]
            
            # Set default selection(s)
            combined_selections[[species_id]] <- genes_df$gene_id[1]
            
            # Create the UI content
            ui_content <- div(
              h6(
                species_name,
                if(nrow(genes_df) > 1) {
                  span(
                    class = "badge bg-warning text-dark ms-2",
                    style = "font-size: 0.8em;",
                    paste(nrow(genes_df), "paralogs")
                  )
                }
              ),
              if (nrow(genes_df) == 1) {
                tagList(
                  div(
                    class = "alert alert-success py-2 px-3 mb-2",
                    style = "font-size: 0.9em;",
                    icon("check-circle"),
                    " Single copy: ", genes_df$display[1]
                  ),
                  # Hidden checkbox for consistency
                  div(
                    style = "display: none;",
                    checkboxGroupInput(
                      inputId = paste0("combined_", species_id, "_selection"),
                      label = NULL,
                      choices = setNames(genes_df$gene_id, genes_df$display),
                      selected = genes_df$gene_id[1]
                    )
                  )
                )
              } else {
                tagList(
                  div(
                    class = "alert alert-info py-2 px-3 mb-2",
                    style = "font-size: 0.9em;",
                    icon("info-circle"),
                    " Multiple paralogs found. Select one or more to compare:"
                  ),
                  checkboxGroupInput(
                    inputId = paste0("combined_", species_id, "_selection"),
                    label = NULL,
                    choices = setNames(genes_df$gene_id, genes_df$display),
                    selected = genes_df$gene_id[1]
                  ),
                  tags$small(
                    class = "text-muted",
                    "Select multiple paralogs to compare their expression patterns"
                  )
                )
              }
            )
            
            # Use the existing container
            container_id <- paste0("combined_", species_id, "_selection_ui")
            container_selector <- paste0("#", container_id)
            
            # Clear existing content in container only
            removeUI(
              selector = paste0(container_selector, " > *"),
              multiple = TRUE,
              immediate = TRUE
            )
            
            # Insert new content directly
            insertUI(
              selector = container_selector,
              where = "afterBegin",
              ui = ui_content,
              immediate = TRUE
            )
            
          } else {
            # No genes found for this species
            ui_content <- div(
              h6(species_name),
              p("No genes found in this species", style = "color: #999;")
            )
            
            container_selector <- paste0("#combined_", species_id, "_selection_ui")
            
            # Clear existing content first
            removeUI(
              selector = paste0(container_selector, " > *"),
              multiple = TRUE,
              immediate = TRUE
            )
            
            insertUI(
              selector = container_selector,
              where = "afterBegin",
              ui = ui_content,
              immediate = TRUE
            )
          }
        })
      }
      
      shinyjs::delay(100, {
        config <- current_species_config()
        for (sp_id in names(config)) {
          local({
            species_id <- sp_id
            
            # Only create observer if there are genes for this species
            if (species_id %in% names(query_results$combined$genes_by_species) &&
                nrow(query_results$combined$genes_by_species[[species_id]]) > 0) {
              
              observeEvent(input[[paste0("combined_", species_id, "_selection")]], {
                new_selection <- input[[paste0("combined_", species_id, "_selection")]]
                combined_selections[[species_id]] <- new_selection
                
                # Update the table
                output$combined_orthogroup_table <- renderDT({
                  update_combined_table(query_results, combined_selections, is_dark)
                })
                
                # Update selection summary
                output$combined_selection_summary <- renderUI({
                  config <- current_species_config()
                  selected_count <- sum(sapply(names(config), function(sp) {
                    length(combined_selections[[sp]])
                  }))
                  
                  if (selected_count > 0) {
                    div(
                      icon("check"),
                      paste(selected_count, "gene(s) selected for comparison")
                    )
                  } else {
                    div(
                      icon("info-circle"),
                      "No genes selected yet"
                    )
                  }
                })
              }, ignoreInit = TRUE, ignoreNULL = FALSE)
            }
          })
        }
      })
      
      # Initial table render
      output$combined_orthogroup_table <- renderDT({
        update_combined_table(query_results, combined_selections, is_dark)
      })
      
      # Initial selection summary
      output$combined_selection_summary <- renderUI({
        div(
          icon("info-circle"),
          "Genes selected with default options"
        )
      })
      
      # Auto-click plot button if all species have only single genes
      shinyjs::delay(500, {
        all_single <- TRUE
        config <- current_species_config()
        for (sp in names(config)) {
          if (sp %in% names(query_results$combined$genes_by_species)) {
            if (nrow(query_results$combined$genes_by_species[[sp]]) > 1) {
              all_single <- FALSE
              break
            }
          }
        }
        
        if (all_single) {
          shinyjs::click("combined_plot_button")
        }
      })
      
    } else {
      shinyjs::hide("combined_orthogroup_container")
      showNotification("Gene not found in any species", type = "error")
    }
    
    waiter_hide()
  })
  
  #track created observers for cleanup
  if (is.null(session$userData$created_species_observers)) {
    session$userData$created_species_observers <- character(0)
  }
  
  #observers dynamically based on current configuration
  observe({
    config <- current_species_config()
    current_species <- names(config)
    
    #cleanup observers for removed species
    existing_observers <- session$userData$created_species_observers
    removed_species <- setdiff(existing_observers, current_species)
    
    for (sp_id in removed_species) {
      #destroy observers for removed species
      obs_names <- c(
        paste0("obs_search_", sp_id),
        paste0("obs_plot_", sp_id),
        paste0("obs_download_", sp_id)
      )
      for (obs_name in obs_names) {
        if (exists(obs_name, envir = session$userData)) {
          obs <- session$userData[[obs_name]]
          if (inherits(obs, "Observer")) {
            obs$destroy()
          }
          rm(list = obs_name, envir = session$userData)
        }
      }
    }
    session$userData$created_species_observers <- current_species
    
    #create observers for each species
    lapply(current_species, function(species_id) {
      obs_search_id <- paste0("obs_search_", species_id)
      obs_plot_id <- paste0("obs_plot_", species_id)
      obs_download_id <- paste0("obs_download_", species_id)
      
      if (!exists(obs_search_id, envir = session$userData)) {
        #search button handler
        session$userData[[obs_search_id]] <- observeEvent(input[[paste0(species_id, "_search_button")]], {
          waiter_show(html = loading_screen)
          
          gene_query <- trimws(input[[paste0(species_id, "_genename")]])
          
          if (gene_query == "") {
            showNotification("Please enter a gene name or ID", type = "warning")
            waiter_hide()
            return()
          }
          
          # Store query results in reactive values
          query_results[[species_id]] <- query_orthogroups(
            gene_query, 
            get_all_species_data(), 
            current_species_config(),
            get_species_data
          )
          gene_result <- query_results[[species_id]]
          
          if (is.null(gene_result)) {
            showNotification(paste("Gene", gene_query, "not found"), type = "error")
            waiter_hide()
            return()
          }
          
          # Show orthogroup container
          shinyjs::show(paste0(species_id, "_orthogroup_container"))
          
          # Update the orthogroup selection UI with enhanced version
          output[[paste0(species_id, "_orthogroup_selection")]] <- renderUI({
            create_orthogroup_selection_ui_enhanced(gene_result, species_id, current_species_config())
          })
          
          # Get genes for this species
          current_species_genes <- gene_result$genes_by_species[[species_id]]
          
          if (!is.null(current_species_genes) && nrow(current_species_genes) > 0) {
            # Auto-click plot button if only one gene
            if (nrow(current_species_genes) == 1) {
              # Add a small delay to ensure UI is rendered
              shinyjs::delay(100, shinyjs::click(paste0(species_id, "_plot_button")))
            }
          }
          
          if (is.null(current_species_genes) || nrow(current_species_genes) == 0) {
            # Gene not found in this species
            updateRadioButtons(
              session,
              paste0(species_id, "_", species_id, "_selection"),
              label = NULL,
              choices = c("No genes found in this species" = ""),
              selected = ""
            )
            config <- current_species_config()
            showNotification(
              paste("Gene", gene_query, "not found in", config[[species_id]]$name,
                    "but found in other species"), 
              type = "warning",
              duration = 5
            )
          } else {
            # Update radio buttons with actual genes
            genes_df <- current_species_genes
            gene_choices <- setNames(genes_df$gene_id, genes_df$display)
            
            updateRadioButtons(
              session,
              paste0(species_id, "_", species_id, "_selection"),
              label = NULL,
              choices = gene_choices,
              selected = genes_df$gene_id[1]
            )
            
            # Auto-click plot button if only one gene
            if (nrow(genes_df) == 1) {
              shinyjs::click(paste0(species_id, "_plot_button"))
            }
          }
          
          # Update search results table
          output[[paste0(species_id, "_search_results")]] <- renderDT({
            if (!is.null(gene_result$genes_by_species[[species_id]]) && 
                nrow(gene_result$genes_by_species[[species_id]]) > 0) {
              species_genes <- gene_result$genes_by_species[[species_id]]
              datatable(
                species_genes[, c("gene_id", "gene_name")],
                options = list(
                  pageLength = 5,
                  dom = 'tp',
                  scrollX = TRUE
                ),
                colnames = c("Gene ID", "Gene Name"),
                rownames = FALSE
              )
            }
          })
          
          #update orthogroup results table
          output[[paste0(species_id, "_orthogroup_results")]] <- renderDT({
            config <- current_species_config()
            
            #collect data in list first, then combine once
            ortho_list <- lapply(names(gene_result$genes_by_species), function(sp) {
              sp_data <- gene_result$genes_by_species[[sp]]
              if (nrow(sp_data) == 0) return(NULL)
              sp_data$Species <- config[[sp]]$short
              sp_data$Current <- (sp == species_id)
              sp_data[, c("Species", "gene_id", "gene_name", "Current")]
            })
            
            ortho_data <- rbindlist(Filter(Negate(is.null), ortho_list), fill = TRUE)
            
            if (nrow(ortho_data) > 0) {
              ortho_data <- ortho_data[order(ortho_data$Current, decreasing = TRUE), ]
              
              dt <- datatable(
                ortho_data[, c("Species", "gene_id", "gene_name")],
                options = list(
                  pageLength = 10,
                  dom = 'tp',
                  scrollX = TRUE
                ),
                colnames = c("Species", "Gene ID", "Gene Name"),
                rownames = FALSE
              )
              
              if (any(ortho_data$Current)) {
                dt <- dt %>% formatStyle(
                  columns = 1:3,
                  target = "row",
                  backgroundColor = styleRow(which(ortho_data$Current), 
                                             if(is_dark()) "#3a4a5a" else "#e6f3ff")
                )
              }
              
              return(dt)
            }
          })
          
          waiter_hide()
        })
      }
      
      # Plot button handler - SIMPLIFIED
      if (!exists(obs_plot_id, envir = session$userData)) {
        session$userData[[obs_plot_id]] <- observeEvent(input[[paste0(species_id, "_plot_button")]], {
          waiter_show(html = loading_screen)
          
          selected_gene <- input[[paste0(species_id, "_", species_id, "_selection")]]
          
          if (is.null(selected_gene) || selected_gene == "") {
            showNotification("Please select a gene", type = "warning")
            waiter_hide()
            return()
          }
          
          species_data <- get_species_data(species_id)
          
          output[[paste0(species_id, "_gene_plot")]] <- renderPlotly({
            config <- current_species_config()
            create_gene_plot(
              lc = get_expression_matrix(species_id, input$global_transform, species_data),
              gene = selected_gene,
              sample_info = species_data$sample_info,
              species_name = config[[species_id]]$name,
              is_dark_mode = is_dark(),
              species_colors = species_colors_dynamic(),
              transform_type = input$global_transform
            )
          })
          
          output[[paste0(species_id, "_gene_info")]] <- renderText({
            gene_info <- species_data$anno[species_data$anno$GeneID == selected_gene, ]
            if (nrow(gene_info) > 0) {
              paste("Gene ID:", selected_gene,
                    "\nGene Name:", gene_info$GeneName[1],
                    "\nChromosome:", gene_info$Chr[1])
            } else {
              paste("Gene ID:", selected_gene)
            }
          })
          
          waiter_hide()
        })
      }
      
      # Download handler
      if (!exists(obs_download_id, envir = session$userData)) {
        output[[paste0(species_id, "_download")]] <- downloadHandler(
          filename = function() {
            paste0(SPECIES_CONFIG[[species_id]]$short, "_gene_expression_", Sys.Date(), ".png")
          },
          content = function(file) {
            selected_gene <- input[[paste0(species_id, "_", species_id, "_selection")]]
            if (!is.null(selected_gene) && selected_gene != "") {
              species_data <- get_species_data(species_id)
              config <- current_species_config()
              p <- create_gene_plot(
                lc = get_expression_matrix(species_id, input$global_transform, species_data),
                gene = selected_gene,
                sample_info = species_data$sample_info,
                species_name = config[[species_id]]$name,
                is_dark_mode = is_dark(),
                species_colors = species_colors_dynamic(),
                transform_type = input$global_transform
              )
              orca(p, file)
            }
          }
        )
        session$userData[[obs_download_id]] <- TRUE
      }
    })
  })
  
  #download handler for orthology matrix
  output$download_orthology_matrix <- downloadHandler(
    filename = function() {
      paste("HOG_expression_matrix_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".csv", sep = "")
    },
    content = function(file) {
      waiter_show(html = loading_screen)
      
      tryCatch({
        # Use stored data if available
        if (!is.null(session$userData$pca_matrices)) {
          result <- session$userData$pca_matrices
        } else {
          # Fall back to extraction
          result <- extract_orthology_matrix()
        }
        
        write.csv(result$sample_matrix, file)
        
        # Also save metadata
        dir_path <- dirname(file)
        base_name <- tools::file_path_sans_ext(basename(file))
        
        write.csv(
          result$sample_metadata,
          file.path(dir_path, paste0(base_name, "_metadata.csv")),
          row.names = FALSE
        )
        
        showNotification(
          "HOG matrix exported successfully",
          type = "message",
          duration = 5
        )
      }, error = function(e) {
        showNotification(
          paste("Error generating matrix:", e$message),
          type = "error",
          duration = NULL
        )
      })
      
      waiter_hide()
    }
  )
  
  # Combined plot button observer
  observeEvent(input$combined_plot_button, {
    req(input$species_select)
    waiter_show(html = loading_screen)
    
    # Collect all selected genes
    selected_genes_list <- list()
    
    for (species_code in input$species_select) {
      # Get selections from combined_selections reactive values
      gene_ids <- combined_selections[[species_code]]
      
      if (!is.null(gene_ids) && length(gene_ids) > 0) {
        selected_genes_list[[species_code]] <- gene_ids
      }
    }
    
    # Check if we have any genes selected
    if (length(selected_genes_list) == 0) {
      showNotification("No genes selected for plotting. Please search for a gene first.", type = "warning")
      waiter_hide()
      return()
    }
    
    #create combined plot data with support for multiple genes per species
    config <- current_species_config()
    
    #collect all expression data in list first
    plot_data_list <- list()
    
    for (species_code in names(selected_genes_list)) {
      species_data <- get_species_data(species_code)
      gene_ids <- selected_genes_list[[species_code]]
      
      #get expression matrix based on transformation
      expr_matrix <- get_expression_matrix(species_code, input$global_transform, species_data)
      
      for (gene_id in gene_ids) {
        #handle K. lactis underscore issue (only for original data)
        gene_id_to_use <- gene_id
        if (data_source() == "default" && species_code == "kl" && !gene_id %in% rownames(expr_matrix)) {
          gene_id_alt <- gsub("^(KLLA0)(.*)", "\\1_\\2", gene_id)
          if (gene_id_alt %in% rownames(expr_matrix)) {
            gene_id_to_use <- gene_id_alt
          }
        }
        
        if (gene_id_to_use %in% rownames(expr_matrix)) {
          species_name <- config[[species_code]]$name
          
          #get gene name for display
          gene_name <- ""
          anno_idx <- which(species_data$anno$GeneID == gene_id)
          if (length(anno_idx) > 0) {
            gene_name <- species_data$anno$GeneName[anno_idx[1]]
            if (is.na(gene_name)) gene_name <- ""
          }
          
          gene_display <- if (gene_name != "") {
            paste0(gene_name, " (", gene_id, ")")
          } else {
            gene_id
          }
          
          expr_data <- data.frame(
            Gene = gene_display,
            GeneID = gene_id,
            Species = species_name,
            SpeciesCode = species_code,
            Timepoint = factor(species_data$sample_info$Timepoint, levels = TIME_POINTS),
            Replicate = species_data$sample_info$Replicate,
            Expression = as.numeric(expr_matrix[gene_id_to_use, ])
          )
          
          plot_data_list[[length(plot_data_list) + 1]] <- expr_data
        }
      }
    }
    
    #combine all at once
    plot_data <- if (length(plot_data_list) > 0) {
      as.data.frame(rbindlist(plot_data_list, fill = TRUE))
    } else {
      data.frame()
    }
    
    if (nrow(plot_data) > 0) {
      output$combined_gene_plot <- renderPlotly({
        #cache dark mode state once at render start
        dark_mode <- is_dark()
        
        #create a unique identifier for each gene-species combination
        plot_data$GeneSpecies <- paste(plot_data$Gene, "-", plot_data$Species)
        
        # Create color palette for all unique gene-species combinations
        unique_combinations <- unique(plot_data$GeneSpecies)
        n_combinations <- length(unique_combinations)
        
        # Use a color palette that can handle many colors
        if (n_combinations <= 8) {
          colors <- RColorBrewer::brewer.pal(max(3, n_combinations), "Set1")
        } else {
          colors <- colorRampPalette(RColorBrewer::brewer.pal(12, "Set3"))(n_combinations)
        }
        
        color_map <- setNames(colors[1:n_combinations], unique_combinations)
        
        # Add replicate information
        plot_data$GeneSpeciesRep <- paste(plot_data$GeneSpecies, "Rep", plot_data$Replicate)
        
        # Create color vector with alpha for replicates
        color_vector <- c()
        for (combo in unique_combinations) {
          base_color <- color_map[combo]
          color_vector <- c(color_vector, 
                            base_color,  # Rep 1 - full opacity
                            adjustcolor(base_color, alpha.f = 0.6))  # Rep 2 - reduced opacity
        }
        
        # Create proper labels for the color vector
        rep_labels <- c()
        for (combo in unique_combinations) {
          rep_labels <- c(rep_labels,
                          paste(combo, "Rep 1"),
                          paste(combo, "Rep 2"))
        }
        names(color_vector) <- rep_labels
        
        # Create the plot
        p <- ggplot(plot_data,
                    aes(x = Timepoint, y = Expression,
                        color = GeneSpeciesRep, group = GeneSpeciesRep,
                        text = paste("Gene:", Gene,
                                     "<br>Species:", Species,
                                     "<br>Replicate:", Replicate,
                                     "<br>Time:", Timepoint,
                                     "<br>Expression:", round(Expression, 2)))) +
          geom_point(size = 3, alpha = 0.8) +
          geom_line(linewidth = 1.2, alpha = 0.9) +
          scale_color_manual(
            values = color_vector,
            name = "Gene - Species",
            breaks = names(color_vector),
            labels = names(color_vector)
          ) +
          labs(
            y = get_expression_label(input$global_transform),
            title = "Cross-species Expression Comparison",
            subtitle = paste("Comparing", length(unique(plot_data$Gene)), "genes across", 
                             length(unique(plot_data$Species)), "species"),
            x = "Timepoint"
          ) +
          theme_minimal() +
          theme(
            axis.text.x = element_text(angle = 45, hjust = 1, size = 11),
            axis.text.y = element_text(size = 11),
            plot.title = element_text(size = 16, face = "bold"),
            plot.subtitle = element_text(size = 12),
            panel.grid.major = element_line(color = if(dark_mode) "gray30" else "gray90"),
            panel.grid.minor = element_line(color = if(dark_mode) "gray20" else "gray95"),
            plot.background = element_rect(fill = if(dark_mode) "#2c3034" else "white", color = NA),
            panel.background = element_rect(fill = if(dark_mode) "#2c3034" else "white", color = NA),
            text = element_text(color = if(dark_mode) "white" else "black"),
            axis.text = element_text(color = if(dark_mode) "white" else "black"),
            legend.text = element_text(color = if(dark_mode) "white" else "black", size = 9),
            legend.title = element_text(color = if(dark_mode) "white" else "black", size = 11),
            legend.background = element_rect(fill = if(dark_mode) "#2c3034" else "white"),
            legend.key = element_rect(fill = if(dark_mode) "#2c3034" else "white")
          )
        
        #convert to plotly with custom hover text
        ggplotly(p, tooltip = "text") %>%
          layout(
            plot_bgcolor = if(dark_mode) "#2c3034" else "white",
            paper_bgcolor = if(dark_mode) "#2c3034" else "white",
            font = list(color = if(dark_mode) "white" else "black"),
            hoverlabel = list(
              bgcolor = if(dark_mode) "#444" else "white",
              font = list(size = 12)
            ),
            showlegend = TRUE,
            legend = list(
              x = 1.02,
              y = 0.5,
              bgcolor = if(dark_mode) "#2c3034" else "white",
              bordercolor = if(dark_mode) "#444" else "#ddd",
              borderwidth = 1,
              font = list(size = 10),
              tracegroupgap = 5
            ),
            margin = list(b = 100, r = 250, t = 80, l = 60),
            xaxis = list(
              tickfont = list(size = 11)
            ),
            yaxis = list(
              tickfont = list(size = 11)
            )
          ) %>%
          config(
            displayModeBar = TRUE,
            modeBarButtons = list(
              list("zoom2d", "pan2d", "resetScale2d", "toImage")
            )
          )
      })
    } else {
      output$combined_gene_plot <- renderPlotly({
        plotly_empty() %>%
          add_annotations(
            text = "No valid expression data found for selected genes",
            showarrow = FALSE
          )
      })
      showNotification("No valid expression data found for selected genes", type = "error")
    }
    
    waiter_hide()
  })
  
  # Download handler for combined plot
  output$download_combined_plot <- downloadHandler(
    filename = function() {
      paste0("combined_expression_", Sys.Date(), ".png")
    },
    content = function(file) {
      # Get current plot
      p <- plotly::plotly_build(isolate(output$combined_gene_plot()))
      plotly::export(p, file = file)
    }
  )
  
  # Store heatmap data for download
  ortholog_result <- reactiveVal(NULL)

  # Process gene list from textarea or file
  observe({
    if (!is.null(input$ortholog_gene_file$datapath)) {
      file_ext <- tools::file_ext(input$ortholog_gene_file$name)
      
      if (file_ext == "csv") {
        genes_df <- read.csv(input$ortholog_gene_file$datapath, stringsAsFactors = FALSE)
        if (ncol(genes_df) == 1) {
          gene_list <- genes_df[[1]]
        } else {
          gene_list <- as.character(genes_df[,1])
        }
      } else {
        # txt file
        gene_list <- readLines(input$ortholog_gene_file$datapath)
      }
      
      # update the textarea with the file contents
      updateTextAreaInput(session, "ortholog_gene_list", value = paste(gene_list, collapse = "\n"))
    }
  })

  # Generate heatmap when button is clicked
  observeEvent(input$generate_ortholog_heatmap, {
    req(input$ortholog_gene_list)
    waiter_show(html = loading_screen)
    
    # split gene list by newlines, commas, or semicolons
    gene_list <- unlist(strsplit(input$ortholog_gene_list, "[\n\r,;]+"))
    gene_list <- trimws(gene_list)
    gene_list <- gene_list[gene_list != ""]
    
    # only proceed if we have genes
    if (length(gene_list) == 0) {
      showNotification("Please enter at least one gene", type = "error")
      waiter_hide()
      return()
    }
    
    config <- current_species_config()
    current_data <- get_all_species_data()
    species_data_list <- list()
    for (species_id in names(config)) {
      species_data_list[[species_id]] <- get_species_data(species_id)
    }
    
    # generate the cross-species heatmap
    result <- tryCatch({
      generate_cross_species_heatmap(
        gene_list = gene_list,
        species_data_list = species_data_list,
        normalization = input$heatmap_normalization,
        is_dark_mode = is_dark(),
        cluster_rows = input$cluster_rows,
        cluster_cols = input$cluster_cols,
        config = config,
        all_species_data = get_all_species_data(),
        transform_type = input$global_transform
      )
    }, error = function(e) {
      list(
        plot = NULL,
        table = NULL,
        error = paste("Error generating heatmap:", e$message)
      )
    })
    
    # check for errors
    if (!is.null(result$error)) {
      showNotification(result$error, type = "error", duration = NULL)
      waiter_hide()
      return()
    }
    
    # store results for download
    ortholog_result(result)
    
    # update UI with results
    output$ortholog_heatmap_plot <- renderPlotly({
      result$plot
    })
    
    output$ortholog_mapping_table <- renderDT({
      result$table
    })
    
    waiter_hide()
  })

  # Download handlers
  output$download_ortholog_heatmap <- downloadHandler(
    filename = function() {
      paste("cross_species_heatmap_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".png", sep = "")
    },
    content = function(file) {
      # make sure we have a result
      req(ortholog_result())
      result <- ortholog_result()
      
      # save plot to file (using plotly export)
      p <- result$plot
      plotly::export(p, file = file)
    }
  )

  output$download_ortholog_data <- downloadHandler(
    filename = function() {
      paste("cross_species_expression_matrix_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".csv", sep = "")
    },
    content = function(file) {
      # make sure we have a result
      req(ortholog_result())
      result <- ortholog_result()
      
      # Use the stored matrix directly if available
      if (!is.null(result$matrix)) {
        write.csv(result$matrix, file)
      } else {
        # Fallback: extract the matrix from the correct plot element
        p <- result$plot
        
        # The subplot has multiple data elements - find the main heatmap
        mat_data <- NULL
        if (length(p$x$data) > 1) {
          # Look for the data element with more than 1 row (not the species bar)
          for (i in seq_along(p$x$data)) {
            if (!is.null(p$x$data[[i]]$z) && is.matrix(p$x$data[[i]]$z)) {
              if (nrow(p$x$data[[i]]$z) > 1) {
                mat_data <- p$x$data[[i]]
                break
              }
            }
          }
        }
        
        # If still not found, use the first element as fallback
        if (is.null(mat_data)) {
          mat_data <- p$x$data[[1]]
        }
        
        # recreate the matrix
        genes <- mat_data$y
        timepoints <- mat_data$x
        expression_values <- mat_data$z
        
        # create a data frame from the matrix
        matrix_df <- as.data.frame(expression_values)
        rownames(matrix_df) <- genes
        colnames(matrix_df) <- timepoints
        
        # write to CSV
        write.csv(matrix_df, file)
      }
    }
  )
  
  #observer for ortholog mapping when checkbox is toggled
  observeEvent(input$enable_ortholog_analysis, {
    if (input$enable_ortholog_analysis) {
      #get gene list from either source
      gene_list <- NULL
      
      #check pathway definitions first if in pathway mode
      if (!is.null(input$enable_pathway_comparison) && input$enable_pathway_comparison) {
        pathway_text <- input$pathway_definitions
        if (!is.null(pathway_text) && nchar(trimws(pathway_text)) > 0) {
          #extract all genes from pathway definitions
          normalized <- gsub("\r\n", "\n", pathway_text)
          normalized <- gsub("\r", "\n", normalized)
          lines <- strsplit(normalized, "\n")[[1]]
          
          all_genes <- c()
          is_gene_line <- FALSE
          
          for (line in lines) {
            line <- trimws(line)
            if (line == "") {
              is_gene_line <- FALSE
            } else if (!is_gene_line) {
              #pathway name line, next line is genes
              is_gene_line <- TRUE
            } else {
              #gene line
              genes <- strsplit(line, "[,;\\s]+")[[1]]
              genes <- trimws(genes)
              genes <- genes[genes != ""]
              all_genes <- c(all_genes, genes)
            }
          }
          
          gene_list <- unique(all_genes)
        }
      }
      
      #fallback to regular gene list
      if (is.null(gene_list) || length(gene_list) == 0) {
        if (!is.null(input$gene_list) && nchar(trimws(input$gene_list)) > 0) {
          genes <- strsplit(trimws(input$gene_list), "[\n\r]+")[[1]]
          gene_list <- genes[genes != ""]
        }
      }
      
      if (is.null(gene_list) || length(gene_list) == 0) {
        showNotification("Please enter a gene list or pathway definitions first", type = "warning", duration = 3)
        updateCheckboxInput(session, "enable_ortholog_analysis", value = FALSE)
        return()
      }
      
      #perform initial mapping
      perform_ortholog_mapping(gene_list)
      
    } else {
      #reset when unchecked
      ortholog_state$mapped <- FALSE
      ortholog_state$gene_mapping <- NULL
      ortholog_state$coverage_stats <- NULL
      shinyjs::hide("ortholog_mapping_results")
    }
  })
  
  #reusable function to perform ortholog mapping
  perform_ortholog_mapping <- function(gene_list) {
    if (is.null(gene_list) || length(gene_list) == 0) {
      showNotification("No gene list to map", type = "warning", duration = 3)
      return(FALSE)
    }
    
    waiter_show(html = loading_screen)
    
    config <- current_species_config()
    current_data <- get_all_species_data()
    
    tryCatch({
      gene_mapping <- extract_orthology_for_genes(gene_list, current_data, config)
      
      if (is.null(gene_mapping) || length(gene_mapping) == 0) {
        showNotification("No orthologs found for input genes", type = "warning", duration = 5)
        ortholog_state$mapped <- FALSE
        shinyjs::hide("ortholog_mapping_results")
        waiter_hide()
        return(FALSE)
      }
      
      coverage_stats <- calculate_ortholog_coverage(gene_mapping, config)
      
      ortholog_state$mapped <- TRUE
      ortholog_state$gene_mapping <- gene_mapping
      ortholog_state$coverage_stats <- coverage_stats
      
      shinyjs::show("ortholog_mapping_results")
      
      #update coverage display
      output$ortholog_coverage_summary <- renderUI({
        if (is.null(coverage_stats)) return(NULL)
        
        div(
          class = "ortholog-summary-box",
          h6(icon("chart-bar"), " Ortholog Coverage by Species"),
          lapply(names(coverage_stats), function(sp_code) {
            stats <- coverage_stats[[sp_code]]
            div(
              style = "margin: 5px 0;",
              span(
                class = paste("coverage-badge", stats$coverage_class),
                paste0(stats$species_name, ": ", stats$genes_found, "/", 
                       stats$total_genes, " (", stats$coverage_pct, "%)")
              ),
              tags$small(
                style = "margin-left: 8px; color: #666;",
                paste0(stats$total_orthologs, " total ortholog", 
                       if(stats$total_orthologs != 1) "s" else "",
                       if(stats$paralog_count > 0) 
                         paste0(", ", stats$paralog_count, " paralog", 
                                if(stats$paralog_count != 1) "s" else "")
                       else "")
              )
            )
          })
        )
      })
      #generate paralog selection UI
      output$paralog_selection_ui <- renderUI({
        if (is.null(gene_mapping)) return(NULL)
        
        selection_ui <- tagList()
        
        for (gene_map in gene_mapping) {
          input_gene <- gene_map$original
          
          #create section for this input gene
          gene_ui <- div(
            class = "mb-3",
            h6(strong(input_gene), style = "color: var(--bs-primary);"),
            
            #create checkboxes for each species
            lapply(names(config), function(sp_code) {
              orthologs <- gene_map[[sp_code]]
              if (is.null(orthologs) || length(orthologs) == 0) return(NULL)
              
              sp_name <- config[[sp_code]]$short
              checkbox_id <- paste0("select_", input_gene, "_", sp_code)
              
              #create choices with gene IDs
              choices <- setNames(orthologs, 
                                  if(length(orthologs) > 1) {
                                    sapply(1:length(orthologs), function(i) {
                                      paste0(orthologs[i], " [", i, "/", length(orthologs), "]")
                                    })
                                  } else {
                                    orthologs
                                  })
              
              div(
                class = "ms-3 mb-2",
                strong(sp_name, ":"),
                checkboxGroupInput(
                  checkbox_id,
                  label = NULL,
                  choices = choices,
                  selected = orthologs[1],  #default: select first paralog only
                  inline = FALSE
                )
              )
            })
          )
          
          selection_ui <- tagList(selection_ui, gene_ui)
        }
        
        return(selection_ui)
      })
      
      #initialize selected_orthologs with first paralog from each species
      ortholog_state$selected_orthologs <- list()
      for (gene_map in gene_mapping) {
        input_gene <- gene_map$original
        for (sp_code in names(config)) {
          orthologs <- gene_map[[sp_code]]
          if (!is.null(orthologs) && length(orthologs) > 0) {
            checkbox_id <- paste0("select_", input_gene, "_", sp_code)
            ortholog_state$selected_orthologs[[checkbox_id]] <- orthologs[1]
          }
        }
      }
      showNotification(
        paste("Mapped", length(gene_mapping), "genes across", 
              length(config), "species"),
        type = "message",
        duration = 3
      )
      
      waiter_hide()
      return(TRUE)
      
    }, error = function(e) {
      showNotification(paste("Error mapping orthologs:", e$message), 
                       type = "error", duration = 5)
      ortholog_state$mapped <- FALSE
      waiter_hide()
      return(FALSE)
    })
  }
  #observer for explicit ortholog remapping button
  observeEvent(input$remap_orthologs, {
    req(input$enable_ortholog_analysis)
    
    #get current gene list
    gene_list <- if (!is.null(input$gene_list) && nchar(trimws(input$gene_list)) > 0) {
      genes <- strsplit(trimws(input$gene_list), "[\n\r]+")[[1]]
      genes[genes != ""]
    } else {
      NULL
    }
    
    #perform remapping
    perform_ortholog_mapping(gene_list)
  })
  
  #observer for "Select All" button
  observeEvent(input$select_all_paralogs, {
    req(ortholog_state$gene_mapping)
    
    config <- current_species_config()
    
    for (gene_map in ortholog_state$gene_mapping) {
      input_gene <- gene_map$original
      for (sp_code in names(config)) {
        orthologs <- gene_map[[sp_code]]
        if (!is.null(orthologs) && length(orthologs) > 0) {
          checkbox_id <- paste0("select_", input_gene, "_", sp_code)
          updateCheckboxGroupInput(session, checkbox_id, selected = orthologs)
        }
      }
    }
    
    showNotification("Selected all orthologs", type = "message", duration = 2)
  })
  
  #observer for "Select First Only" button
  observeEvent(input$select_first_paralogs, {
    req(ortholog_state$gene_mapping)
    
    config <- current_species_config()
    
    for (gene_map in ortholog_state$gene_mapping) {
      input_gene <- gene_map$original
      for (sp_code in names(config)) {
        orthologs <- gene_map[[sp_code]]
        if (!is.null(orthologs) && length(orthologs) > 0) {
          checkbox_id <- paste0("select_", input_gene, "_", sp_code)
          updateCheckboxGroupInput(session, checkbox_id, selected = orthologs[1])
        }
      }
    }
    
    showNotification("Selected first ortholog from each species", type = "message", duration = 2)
  })
  
  # Observer to show detailed ortholog mapping
  observeEvent(input$view_ortholog_details, {
    req(ortholog_state$gene_mapping)
    
    config <- current_species_config()
    mapping_table <- create_ortholog_mapping_table(ortholog_state$gene_mapping, config)
    
    showModal(modalDialog(
      title = div(icon("sitemap"), " Detailed Ortholog Mapping"),
      size = "xl",
      DTOutput("ortholog_mapping_modal_table"),
      footer = tagList(
        downloadButton("download_ortholog_mapping", "Download CSV", 
                       class = "btn btn-primary"),
        modalButton("Close")
      )
    ))
    
    output$ortholog_mapping_modal_table <- renderDT({
      datatable(
        mapping_table,
        options = list(
          pageLength = 20,
          scrollX = TRUE,
          dom = 'Bfrtip'
        ),
        rownames = FALSE
      )
    })
  })
  
  # Download handler for ortholog mapping
  output$download_ortholog_mapping <- downloadHandler(
    filename = function() {
      paste0("ortholog_mapping_", format(Sys.Date(), "%Y%m%d"), ".csv")
    },
    content = function(file) {
      req(ortholog_state$gene_mapping)
      config <- current_species_config()
      mapping_table <- create_ortholog_mapping_table(ortholog_state$gene_mapping, config)
      write.csv(mapping_table, file, row.names = FALSE)
    }
  )
  #download handler for coverage statistics
  output$download_coverage_stats <- downloadHandler(
    filename = function() {
      paste0("ortholog_coverage_stats_", format(Sys.Date(), "%Y%m%d"), ".csv")
    },
    content = function(file) {
      req(ortholog_state$coverage_stats)
      config <- current_species_config()
      stats_list <- ortholog_state$coverage_stats
      stats_df <- data.frame(
        Species = sapply(names(stats_list), function(sp) config[[sp]]$short),
        Species_Code = names(stats_list),
        Genes_Found = sapply(stats_list, function(x) x$genes_found),
        Total_Input_Genes = sapply(stats_list, function(x) x$total_genes),
        Coverage_Percent = sapply(stats_list, function(x) x$coverage_pct),
        Total_Orthologs = sapply(stats_list, function(x) x$total_orthologs),
        Paralog_Count = sapply(stats_list, function(x) x$paralog_count),
        Coverage_Class = sapply(stats_list, function(x) x$coverage_class),
        stringsAsFactors = FALSE
      )
      write.csv(stats_df, file, row.names = FALSE)
    }
  )
  #parse pathway definitions from text input
  parse_pathway_definitions <- reactive({
    if (input$enable_pathway_comparison) {
      #check for file upload first
      pathway_text <- if (!is.null(input$pathway_file$datapath)) {
        readLines(input$pathway_file$datapath, warn = FALSE)
      } else if (!is.null(input$pathway_definitions) && nchar(trimws(input$pathway_definitions)) > 0) {
        #split on single newline to preserve blank lines
        #normalize line endings first (handle \r\n, \r, \n)
        normalized <- gsub("\r\n", "\n", input$pathway_definitions)
        normalized <- gsub("\r", "\n", normalized)
        strsplit(normalized, "\n")[[1]]
      } else {
        return(NULL)
      }
      
      if (is.null(pathway_text) || length(pathway_text) == 0) {
        return(NULL)
      }
      
      #parse pathway format
      pathway_list <- list()
      current_pathway <- NULL
      current_genes <- c()
      
      for (line in pathway_text) {
        line <- trimws(line)
        
        if (line == "") {
          #blank line indicates pathway boundary
          if (!is.null(current_pathway) && length(current_genes) > 0) {
            pathway_list[[current_pathway]] <- current_genes
            current_pathway <- NULL
            current_genes <- c()
          }
        } else if (is.null(current_pathway)) {
          #this is a pathway name
          current_pathway <- line
        } else {
          #this line contains genes (split on comma, semicolon, or whitespace)
          genes <- strsplit(line, "[,;\\s]+")[[1]]
          genes <- trimws(genes)
          genes <- genes[genes != ""]
          current_genes <- c(current_genes, genes)
        }
      }
      
      #add last pathway if exists (handles case with no trailing blank line)
      if (!is.null(current_pathway) && length(current_genes) > 0) {
        pathway_list[[current_pathway]] <- current_genes
      }
      
      if (length(pathway_list) == 0) {
        return(NULL)
      }
      
      return(pathway_list)
    }
    return(NULL)
  })
  
  observeEvent(input$analyze_gene_groups, {
    req(!is.null(input$gene_list) || !is.null(input$gene_group_file))
    if (is.null(input$gene_list) && is.null(input$gene_group_file)) {
      showNotification("Please provide either a gene list or upload a file", type = "error")
      return()
    }
    
    waiter_show(html = loading_screen)
    
    tryCatch({
      #check if pathway comparison mode is enabled
      if (input$enable_pathway_comparison) {
        #pathway comparison mode
        pathway_defs <- parse_pathway_definitions()
        
        if (is.null(pathway_defs) || length(pathway_defs) == 0) {
          showNotification("Please define at least one pathway", type = "error")
          waiter_hide()
          return()
        }
        
        config <- current_species_config()
        pathway_results <- NULL
        
        #branch based on cross-species ortholog analysis checkbox
        if (input$enable_ortholog_analysis) {
          #multi-species mode via orthology
          current_data <- get_all_species_data()
          
          species_data_list <- list()
          for (sp_code in names(config)) {
            species_data_list[[sp_code]] <- get_species_data(sp_code)
          }
          
          pathway_results <- process_pathway_comparison(
            pathway_defs,
            species_data_list,
            config,
            current_data
          )
        } else {
          #single-species mode (no orthology)
          selected_species <- input$group_analysis_species
          if (is.null(selected_species) || selected_species == "") {
            selected_species <- names(config)[1]
          }
          
          species_data <- get_species_data(selected_species)
          species_name <- config[[selected_species]]$short
          
          pathway_results <- process_single_species_pathway(
            pathway_defs,
            species_data,
            species_name,
            input$global_transform
          )
        }
        
        if (is.null(pathway_results) || nrow(pathway_results) == 0) {
          showNotification("No valid expression data found for pathways", 
                           type = "error", duration = 5)
          waiter_hide()
          return()
        }
        
        #generate pathway heatmap
        output$gene_group_plot <- renderPlotly({
          create_pathway_heatmap(
            pathway_data = pathway_results,
            value_type = input$pathway_value_type,
            is_dark_mode = is_dark(),
            cluster_pathways = input$cluster_pathways,
            timepoint_mode = input$timepoint_display_mode
          )
        })
        
        #generate summary table with gene details
        output$gene_group_table <- renderDT({
          #get gene details from attribute
          gene_details <- attr(pathway_results, "gene_details")
          
          summary_table <- pathway_results %>%
            group_by(Pathway, Species) %>%
            summarise(
              NGenes = first(NGenes),
              Mean_Baseline = MeanExpression[Timepoint == "0min"],
              Mean_Peak = max(MeanExpression, na.rm = TRUE),
              Mean_Final = MeanExpression[Timepoint == "8h"],
              .groups = 'drop'
            )
          
          #join gene details if available
          if (!is.null(gene_details) && nrow(gene_details) > 0) {
            summary_table <- left_join(summary_table, 
                                       gene_details[, c("Pathway", "Species", "Genes"), drop = FALSE],
                                       by = c("Pathway", "Species"))
          } else {
            summary_table$Genes <- NA_character_
          }
          
          if (input$pathway_value_type == "foldchange") {
            fc_summary <- calculate_pathway_foldchange(pathway_results) %>%
              group_by(Pathway, Species) %>%
              summarise(
                Max_FoldChange = max(abs(Log2FC), na.rm = TRUE),
                .groups = 'drop'
              )
            summary_table <- left_join(summary_table, fc_summary, by = c("Pathway", "Species"))
          }
          
          #create pathway color mapping using pastel palette
          unique_pathways <- unique(summary_table$Pathway)
          n_pathways <- length(unique_pathways)
          pastel_colors <- if (n_pathways <= 8) {
            RColorBrewer::brewer.pal(max(3, n_pathways), "Pastel1")[1:n_pathways]
          } else if (n_pathways <= 12) {
            RColorBrewer::brewer.pal(n_pathways, "Set3")
          } else {
            colorRampPalette(RColorBrewer::brewer.pal(8, "Pastel1"))(n_pathways)
          }
          pathway_colors <- setNames(pastel_colors, unique_pathways)
          
          #add color column for styling (will be hidden)
          summary_table$RowColor <- pathway_colors[summary_table$Pathway]
          
          #reorder columns to put Genes before Max_FoldChange if present
          col_order <- c("Pathway", "Species", "NGenes", "Mean_Baseline", "Mean_Peak", "Mean_Final", "Genes")
          if ("Max_FoldChange" %in% colnames(summary_table)) {
            col_order <- c(col_order, "Max_FoldChange")
          }
          col_order <- c(col_order, "RowColor")
          summary_table <- summary_table[, col_order]
          
          datatable(
            summary_table,
            options = list(
              pageLength = 20,
              scrollX = TRUE,
              dom = 'tip',
              columnDefs = list(
                list(visible = FALSE, targets = ncol(summary_table) - 1),
                list(width = '180px', targets = which(colnames(summary_table) == "Genes") - 1)
              )
            ),
            rownames = FALSE,
            caption = "Pathway Expression Summary"
          ) %>%
            formatRound(columns = which(sapply(summary_table[, -ncol(summary_table)], is.numeric)), digits = 2) %>%
            formatStyle(
              'Pathway',
              'RowColor',
              backgroundColor = styleEqual(
                unique(summary_table$RowColor),
                unique(summary_table$RowColor)
              )
            ) %>%
            formatStyle(
              columns = 1:(ncol(summary_table) - 1),
              'RowColor',
              backgroundColor = styleEqual(
                unique(summary_table$RowColor),
                unique(summary_table$RowColor)
              )
            )
        })
        
        #render pathway legend
        output$pathway_table_legend <- renderUI({
          unique_pathways <- unique(pathway_results$Pathway)
          n_pathways <- length(unique_pathways)
          
          pastel_colors <- if (n_pathways <= 8) {
            RColorBrewer::brewer.pal(max(3, n_pathways), "Pastel1")[1:n_pathways]
          } else if (n_pathways <= 12) {
            RColorBrewer::brewer.pal(n_pathways, "Set3")
          } else {
            colorRampPalette(RColorBrewer::brewer.pal(8, "Pastel1"))(n_pathways)
          }
          
          #create legend items
          legend_items <- lapply(seq_along(unique_pathways), function(i) {
            tags$span(
              style = "display: inline-flex; align-items: center; margin-right: 16px; margin-bottom: 4px;",
              tags$span(
                style = paste0(
                  "display: inline-block; width: 16px; height: 16px; ",
                  "background-color: ", pastel_colors[i], "; ",
                  "border: 1px solid #ccc; border-radius: 3px; margin-right: 6px;"
                )
              ),
              tags$span(unique_pathways[i], style = "font-size: 0.9em;")
            )
          })
          
          div(
            class = "mt-3 mb-2 p-2",
            style = "background-color: var(--bs-body-bg); border-radius: 4px; border: 1px solid var(--bs-border-color);",
            tags$strong("Pathway Legend:", style = "margin-right: 12px;"),
            div(
              style = "display: flex; flex-wrap: wrap; align-items: center; margin-top: 6px;",
              legend_items
            )
          )
        })
        
        waiter_hide()
        return()
      }
      
      #clear pathway legend when not in pathway mode
      output$pathway_table_legend <- renderUI({ NULL })
      
      # Process input data (ORIGINAL SINGLE/MULTI-GENE MODE)
      gene_groups <- if (!is.null(input$gene_group_file$datapath)) {
        read.csv(input$gene_group_file$datapath)
      } else {
        # Make sure gene_list is not empty and process it
        gene_list <- trimws(input$gene_list)
        if (nchar(gene_list) > 0) {
          genes <- strsplit(gene_list, "[\n\r]+")[[1]]
          genes <- genes[genes != ""] # Remove empty lines
          data.frame(
            group_name = "Custom Group",
            group_member = genes
          )
        } else {
          showNotification("Please enter at least one gene", type = "error")
          return()
        }
      }
      
      # Get species data
      species_data <- get_species_data(input$group_analysis_species)
      
      #process gene expression data with HOG support; dynamic!
      if (input$enable_ortholog_analysis && ortholog_state$mapped) {
        # Multi-species mode using ortholog mapping
        config <- current_species_config()
        current_data <- get_all_species_data()
        
        # Get species data for all species
        species_data_list <- list()
        for (sp_code in names(config)) {
          species_data_list[[sp_code]] <- get_species_data(sp_code)
        }
        
        #process multi-species data
        plot_data <- process_multi_species_gene_set(
          ortholog_state$gene_mapping,
          species_data_list,
          config
        )
        
        if (is.null(plot_data) || nrow(plot_data) == 0) {
          showNotification("No valid expression data found for orthologs", 
                           type = "error", duration = 5)
          waiter_hide()
          return()
        }
        
        #filter plot data based on user selections
        selected_gene_ids <- c()
        for (gene_map in ortholog_state$gene_mapping) {
          input_gene <- gene_map$original
          for (sp_code in names(config)) {
            checkbox_id <- paste0("select_", input_gene, "_", sp_code)
            selected <- input[[checkbox_id]]
            if (!is.null(selected) && length(selected) > 0) {
              selected_gene_ids <- c(selected_gene_ids, selected)
            }
          }
        }
        
        #filter to only selected orthologs
        if (length(selected_gene_ids) > 0) {
          plot_data <- plot_data[plot_data$GeneID %in% selected_gene_ids, ]
        }
        
        if (nrow(plot_data) == 0) {
          showNotification("No orthologs selected for plotting", 
                           type = "warning", duration = 5)
          waiter_hide()
          return()
        }
        
        #store for later use
        ortholog_state$multi_species_data <- plot_data
        
      } else {
        # Single species mode (existing behavior)
        config <- current_species_config()  
        current_data <- get_all_species_data()
        plot_data <- process_gene_group_data(
          gene_groups, 
          species_data, 
          current_data,
          config,  
          input$group_analysis_species  
        )
      }
      
      # check if we got any valid data
      if (is.null(plot_data) || nrow(plot_data) == 0) {
        showNotification("No valid gene expression data found", type = "error")
        return()
      }
      
      # Create a reactive value to store the current significance test parameters
      sig_test_params <- reactiveValues(
        gene = NULL,
        comparisons = NULL
      )
      
      # Event handler for applying significance test
      observeEvent(input$apply_sig_test, {
        req(input$sig_test_gene, input$sig_test_timepoints)
        
        sig_test_params$gene <- input$sig_test_gene
        sig_test_params$comparisons <- input$sig_test_timepoints
        
        # Regenerate the plot
        output$gene_group_plot <- renderPlotly({
          create_group_visualization(
            plot_data = plot_data, 
            viz_type = input$group_viz_type, 
            is_dark_mode = is_dark(), 
            distance_method = input$distance_method,
            data_transform = input$data_transform,
            show_significance = input$show_significance,
            alpha = input$significance_threshold,
            selected_gene = sig_test_params$gene,
            selected_comparisons = sig_test_params$comparisons
          )
        })
      })
      
      #initialize the plot without significance testing
      # Store flag for multi-species mode
      is_multi_species <- input$enable_ortholog_analysis && 
        ortholog_state$mapped && 
        "Species" %in% colnames(plot_data)
      
      #initialize the plot without significance testing
      output$gene_group_plot <- renderPlotly({
        # Check if we have multi-species data
        if (is_multi_species) {
          #check if aggregation to species mean is requested
          if (!is.null(input$aggregation_level) && input$aggregation_level == "species_mean") {
            plot_data <- aggregate_to_species_mean(plot_data)
          }
          
          # Use multi-species visualization
          if (input$group_viz_type == "line") {
            #create unique identifier for each gene including paralog info
            plot_data$GeneLabel <- ifelse(
              duplicated(paste(plot_data$Gene, plot_data$Species)) | 
                duplicated(paste(plot_data$Gene, plot_data$Species), fromLast = TRUE),
              paste0(plot_data$Gene, " (", plot_data$GeneID, ")"),
              plot_data$Gene
            )
            
            #check if aggregation to species mean is requested
            if (!is.null(input$aggregation_level) && input$aggregation_level == "species_mean") {
              #calculate mean and SE for error bars
              plot_summary <- plot_data %>%
                group_by(Species, Timepoint) %>%
                summarise(
                  Mean = mean(Expression, na.rm = TRUE),
                  SE = sd(Expression, na.rm = TRUE) / sqrt(n()),
                  .groups = 'drop'
                )
              p <- plot_ly(plot_summary, x = ~Timepoint, y = ~Mean, color = ~Species,
                           type = 'scatter', mode = 'lines+markers',
                           error_y = list(
                             type = "data",
                             array = ~SE,
                             visible = TRUE
                           )) %>%
                layout(
                  title = "Multi-Species Mean Gene Expression",
                  xaxis = list(title = "Timepoint"),
                  yaxis = list(title = "Mean log2 CPM"),
                  hovermode = "closest"
                )
              return(p)
            }
            #create multi-species line plot with paralog distinction
            p <- ggplot(plot_data, 
                        aes(x = Timepoint, y = Expression,
                            color = interaction(GeneLabel, Species),
                            group = interaction(GeneID, Species, Replicate),
                            text = paste("Gene:", GeneLabel,
                                         "<br>Gene ID:", GeneID,
                                         "<br>Species:", Species,
                                         "<br>Replicate:", Replicate,
                                         "<br>Time:", Timepoint,
                                         "<br>Expression:", round(Expression, 2)))) +
              geom_point(size = 3, alpha = 0.8) +
              geom_line(linewidth = 1.2, alpha = 0.9) +
              labs(
                y = "log2 count per million",
                title = "Multi-Species Gene Set Expression",
                subtitle = paste("Comparing", length(unique(plot_data$GeneID)), 
                                 "total orthologs across", length(unique(plot_data$Species)), "species"),
                x = "Timepoint",
                color = "Gene - Species"
              ) +
              theme_minimal() +
              theme(
                axis.text.x = element_text(angle = 45, hjust = 1, size = 11),
                axis.text.y = element_text(size = 11),
                plot.title = element_text(size = 16, face = "bold"),
                plot.subtitle = element_text(size = 12),
                panel.grid.major = element_line(color = if(is_dark()) "gray30" else "gray90"),
                panel.grid.minor = element_line(color = if(is_dark()) "gray20" else "gray95"),
                plot.background = element_rect(fill = if(is_dark()) "#2c3034" else "white", color = NA),
                panel.background = element_rect(fill = if(is_dark()) "#2c3034" else "white", color = NA),
                text = element_text(color = if(is_dark()) "white" else "black"),
                axis.text = element_text(color = if(is_dark()) "white" else "black"),
                legend.text = element_text(color = if(is_dark()) "white" else "black"),
                legend.title = element_text(color = if(is_dark()) "white" else "black"),
                legend.background = element_rect(fill = if(is_dark()) "#2c3034" else "white")
              )
            
            ggplotly(p, tooltip = "text") %>%
              layout(
                plot_bgcolor = if(is_dark()) "#2c3034" else "white",
                paper_bgcolor = if(is_dark()) "#2c3034" else "white",
                font = list(color = if(is_dark()) "white" else "black")
              )
          } else if (input$group_viz_type == "heatmap") {
            # Create multi-species heatmap
            # Prepare data: average replicates first
            heatmap_data <- plot_data %>%
              group_by(Gene, Species, Timepoint) %>%
              summarise(AvgExpression = mean(Expression, na.rm = TRUE), .groups = 'drop') %>%
              mutate(GeneSpecies = paste(Gene, Species, sep = "_"))
            
            # Create wide format matrix
            hm_matrix <- heatmap_data %>%
              select(GeneSpecies, Timepoint, AvgExpression) %>%
              pivot_wider(names_from = Timepoint, values_from = AvgExpression) %>%
              column_to_rownames("GeneSpecies") %>%
              as.matrix()
            
            # Apply transformation
            if (input$data_transform == "zscore") {
              hm_matrix <- t(scale(t(hm_matrix)))
              hm_matrix[!is.finite(hm_matrix)] <- 0
            } else if (input$data_transform == "centered") {
              hm_matrix <- t(scale(t(hm_matrix), center = TRUE, scale = FALSE))
            }
            
            plot_ly(
              z = hm_matrix,
              x = colnames(hm_matrix),
              y = rownames(hm_matrix),
              type = "heatmap",
              colorscale = "Viridis",
              hoverinfo = "text",
              text = matrix(
                paste(
                  "Gene-Species:", rep(rownames(hm_matrix), each = ncol(hm_matrix)),
                  "<br>Time:", rep(colnames(hm_matrix), times = nrow(hm_matrix)),
                  "<br>Value:", round(as.vector(t(hm_matrix)), 2)
                ),
                nrow = nrow(hm_matrix),
                ncol = ncol(hm_matrix),
                byrow = TRUE
              )
            ) %>%
              layout(
                title = "Multi-Species Gene Expression Heatmap",
                xaxis = list(
                  title = "Timepoint",
                  tickangle = -45
                ),
                yaxis = list(
                  title = "Gene - Species",
                  autorange = "reversed"
                ),
                plot_bgcolor = if(is_dark()) "#2c3034" else "white",
                paper_bgcolor = if(is_dark()) "#2c3034" else "white",
                font = list(color = if(is_dark()) "white" else "black")
              )
          } else {
            # For bar chart in multi-species mode
            summary_data <- plot_data %>%
              group_by(Timepoint, Species, Gene) %>%
              summarise(Mean = mean(Expression, na.rm = TRUE), .groups = 'drop')
            
            p <- ggplot(summary_data, aes(x = Timepoint, y = Mean, fill = interaction(Gene, Species))) +
              geom_bar(stat = "identity", position = "dodge") +
              labs(
                title = "Multi-Species Gene Set Expression",
                y = "Mean log2 CPM",
                x = "Timepoint",
                fill = "Gene - Species"
              ) +
              theme_minimal() +
              theme(
                axis.text.x = element_text(angle = 45, hjust = 1),
                plot.background = element_rect(fill = if(is_dark()) "#2c3034" else "white", color = NA),
                panel.background = element_rect(fill = if(is_dark()) "#2c3034" else "white", color = NA),
                text = element_text(color = if(is_dark()) "white" else "black"),
                legend.background = element_rect(fill = if(is_dark()) "#2c3034" else "white")
              )
            
            ggplotly(p) %>%
              layout(
                plot_bgcolor = if(is_dark()) "#2c3034" else "white",
                paper_bgcolor = if(is_dark()) "#2c3034" else "white"
              )
          }
        } else {
          # Single species mode - use existing visualization
          create_group_visualization(
            plot_data = plot_data, 
            viz_type = input$group_viz_type, 
            is_dark_mode = is_dark(), 
            distance_method = input$distance_method,
            data_transform = input$data_transform,
            show_significance = input$show_significance,
            alpha = input$significance_threshold,
            selected_gene = NULL,
            selected_comparisons = NULL
          )
        }
      })
      # Generate summary table based on mode
      output$gene_group_table <- renderDT({
        if (is_multi_species) {
          # Multi-species summary table
          summary_data <- plot_data %>%
            group_by(Gene, Species) %>%
            summarise(
              Mean_Expression = mean(Expression, na.rm = TRUE),
              Max_Expression = max(Expression, na.rm = TRUE),
              Min_Expression = min(Expression, na.rm = TRUE),
              SD_Expression = sd(Expression, na.rm = TRUE),
              .groups = 'drop'
            )
          
          datatable(
            summary_data,
            options = list(
              pageLength = 10,
              scrollX = TRUE,
              dom = 'tp'
            ),
            rownames = FALSE,
            caption = "Multi-Species Expression Summary"
          ) %>%
            formatRound(columns = c('Mean_Expression', 'Max_Expression', 'Min_Expression', 'SD_Expression'), 
                        digits = 2)
        } else {
          # Single species mode - use existing function
          config <- current_species_config()
          species_name <- config[[input$group_analysis_species]]$name
          create_group_summary_table(plot_data, species_name)
        }
      })
      
    }, error = function(e) {
      showNotification(
        paste("Error processing gene groups:", e$message),
        type = "error"
      )
    })
    
    waiter_hide()
  })

  # Download handler for gene group plot
  output$download_group_plot <- downloadHandler(
    filename = function() {
      if (input$enable_pathway_comparison) {
        paste("pathway_comparison_", input$pathway_value_type, "_", Sys.Date(), ".png", sep = "")
      } else {
        paste("gene_group_", input$group_viz_type, "_", Sys.Date(), ".png", sep = "")
      }
    },
    content = function(file) {
      p <- plotly::plotly_build(isolate(output$gene_group_plot()))
      plotly::export(p, file = file)
    }
  )
  
  #download handler for pathway data matrix
  output$download_pathway_data <- downloadHandler(
    filename = function() {
      paste("pathway_data_", format(Sys.Date(), "%Y%m%d"), ".csv", sep = "")
    },
    content = function(file) {
      if (input$enable_pathway_comparison) {
        pathway_defs <- parse_pathway_definitions()
        config <- current_species_config()
        current_data <- get_all_species_data()
        
        species_data_list <- list()
        for (sp_code in names(config)) {
          species_data_list[[sp_code]] <- get_species_data(sp_code)
        }
        
        pathway_results <- process_pathway_comparison(
          pathway_defs,
          species_data_list,
          config,
          current_data
        )
        
        if (input$pathway_value_type == "foldchange") {
          pathway_results <- calculate_pathway_foldchange(pathway_results)
        }
        
        write.csv(pathway_results, file, row.names = FALSE)
      }
    }
  )

  # Ridgeline Plot handlers
  observeEvent(input$generate_ridgeline, {
    waiter_show(html = loading_screen)
    
    # Get data for selected species or all species
    species_data_list <- list()
    
    if (input$ridgeline_species == "all") {
      config <- current_species_config()
      species_list <- names(config)
    } else {
      species_list <- c(input$ridgeline_species)
    }
    
    for (species_id in species_list) {
      species_data_list[[species_id]] <- get_species_data(species_id)
    }
    
    # Create the ridgeline plot
    output$ridgeline_plot <- renderPlot({
      if (input$ridgeline_view == "distribution") {
        create_ridgeline_plot(
          species_data_list = species_data_list,
          is_dark_mode = is_dark()
        )
      } else {
        create_threshold_ridgeline(
          species_data_list = species_data_list,
          threshold = input$expression_threshold,
          is_dark_mode = is_dark()
        )
      }
    })
    
    waiter_hide()
  })
  
  #global search observer 
  observeEvent(input$global_search_button, {
    req(input$global_gene_query)
    waiter_show(html = loading_screen)
    
    query <- trimws(input$global_gene_query)
    
    if (query == "") {
      showNotification("Please enter a gene name or ID", type = "warning")
      waiter_hide()
      return()
    }
    
    # Store in global state
    global_query_state$current_query <- query
    global_query_state$last_search_time <- Sys.time()
    
    # Search across all species
    query_result <- NULL
    found_species <- NULL
    config <- current_species_config()
    current_data <- get_all_species_data()
    
    for (species_id in names(config)) {
      species_data <- get_species_data(species_id)
      result <- query_gene_flexible(query, species_data, current_data)
      
      if (!is.null(result) && result$source != "none") {
        query_result <- result
        found_species <- species_id
        break
      }
    }
    
    if (!is.null(query_result)) {
      # Store the result globally
      global_query_state$query_result <- query_result
      
      # Show the results containers
      shinyjs::show("gene_explorer_results")
      shinyjs::show("query_status_container")
      
      # Update query status
      output$query_status <- renderUI({
        div(
          class = "alert alert-success",
          icon("check-circle"),
          strong("Query successful!"),
          br(),
          paste("Found", query, "in orthogroup", query_result$orthogroup),
          br(),
          tags$small(
            "Species with orthologs: ",
            paste(sapply(names(query_result$genes_by_species), function(sp) {
              config[[sp]]$short  # Use local config variable instead of SPECIES_CONFIG
            }), collapse = ", ")
          )
        )
      })
      
      if (!is.null(query_result$og_id)) {
        tree <- load_gene_tree(query_result$og_id, current_data)  # Pass current_data
        global_query_state$tree_data <- tree
        
        # Dynamic UI for the tree plot
      output$phylo_tree_plot_ui <- renderUI({
        if (!is.null(tree)) {
          n_tips <- length(tree$tip.label)
          # Calculate height based on number of tips (minimum 400px, 30px per tip)
          plot_height <- max(400, min(900, n_tips * 30))
          plotOutput("phylo_tree_plot", height = paste0(plot_height, "px"))
        } else {
          plotOutput("phylo_tree_plot", height = "400px")
        }
      })
      
      output$phylo_tree_plot <- renderPlot({
        if (!is.null(tree)) {
          create_phylo_tree_plot(tree, query_result$genes_by_species, query_result$orthogroup, is_dark(), current_data, species_colors_dynamic(), current_species_config())
        } else {
          plot.new()
          text(0.5, 0.5, "Phylogenetic tree not available for this orthogroup", 
               cex = 1.2, col = if(is_dark()) "white" else "black")
        }
      }, bg = if(is_dark()) "#2c3034" else "white", res = 120)
      }
      
      #update orthogroup summary  
      output$orthogroup_summary <- renderUI({
        create_orthogroup_summary(query_result, current_species_config())
      })
      
      # Update the orthogroup table with enhanced formatting
      output$explorer_orthogroup_table <- renderDT({
        create_orthogroup_details_table(query_result, current_species_config())
      })
      
    } else {
      # Not found
      shinyjs::hide("gene_explorer_results")
      shinyjs::show("query_status_container")
      
      output$query_status <- renderUI({
        div(
          class = "alert alert-warning",
          icon("exclamation-triangle"),
          strong("Gene not found!"),
          br(),
          paste("Could not find", query, "in any species."),
          br(),
          tags$small("Try using a different gene name or ID format.")
        )
      })
    }
    
    waiter_hide()
  })
  
  #quick action: view in Species Analysis
  observeEvent(input$explore_species_view, {
    req(global_query_state$query_result)
    
    # Find which species has the gene
    result <- global_query_state$query_result
    config <- current_species_config()
    
    if (!is.null(result$genes_by_species)) {
      species_list <- names(result$genes_by_species)
      
     if(length(species_list) == 1) {
        # Only one species - navigate directly
        first_species <- species_list[1]
        config <- current_species_config()  # Get current config
        species_name <- config[[first_species]]$name
        
        # Navigate to Species Analysis and then to the specific species tab
        updateTabsetPanel(session, "nav", selected = "species_analysis_container")
        
        # Small delay to ensure the main tab is loaded
        shinyjs::delay(100, {
          updateTabsetPanel(session, "species_tabs", selected = first_species)
          
          # Scroll to top of page
          shinyjs::runjs("window.scrollTo(0, 0);")
          
          # Pre-fill and trigger search
          updateTextInput(session, paste0(first_species, "_genename"), 
                          value = global_query_state$current_query)
          shinyjs::delay(100, {
            shinyjs::click(paste0(first_species, "_search_button"))
          })
        })
        
        #JavaScript to directly activate the tab panel WITHOUT opening the dropdown
        #navigate to Species Analysis and then to the specific species tab
        updateTabsetPanel(session, "nav", selected = "species_analysis_container")
        
        # Small delay to ensure the main tab is loaded
        shinyjs::delay(100, {
          updateTabsetPanel(session, "species_tabs", selected = selected_species)
          
          # Scroll to top of page
          shinyjs::runjs("window.scrollTo(0, 0);")
          
          # Pre-fill and trigger search
          updateTextInput(session, paste0(selected_species, "_genename"), 
                          value = global_query_state$current_query)
          shinyjs::delay(100, {
            shinyjs::click(paste0(selected_species, "_search_button"))
          })
        })
        
        updateTextInput(session, paste0(first_species, "_genename"), 
                        value = global_query_state$current_query)
        shinyjs::delay(100, {
          shinyjs::click(paste0(first_species, "_search_button"))
        })
      } else {
        #multiple species; selection modal 
        config <- current_species_config()  
        species_choices <- setNames(
          species_list,
          sapply(species_list, function(sp) {
            sp_config <- config[[sp]]
            genes_count <- nrow(result$genes_by_species[[sp]])
            paste0(sp_config$name, " (", genes_count, " gene", 
                   if(genes_count > 1) "s" else "", ")")
          })
        )
        
        showModal(modalDialog(
          title = "Select Species for Analysis",
          tags$p("This gene was found in multiple species. Select which species to analyze:"),
          radioButtons(
            "species_selection_modal",
            label = NULL,
            choices = species_choices,
            selected = species_list[1]
          ),
          footer = tagList(
            modalButton("Cancel"),
            actionButton("confirm_species_selection", "Go to Species", 
                         class = "btn btn-primary")
          ),
          size = "m",
          easyClose = TRUE
        ))
      }
    }
  })
  
  #handler for species selection confirmation
  observeEvent(input$confirm_species_selection, {
    req(input$species_selection_modal)
    
    selected_species <- input$species_selection_modal
    config <- current_species_config()  
    species_name <- config[[selected_species]]$name
    
    # Close the modal
    removeModal()
    
    # Navigate to Species Analysis and then to the specific species tab
    updateTabsetPanel(session, "nav", selected = "species_analysis_container")
    
    # Small delay to ensure the main tab is loaded
    shinyjs::delay(100, {
      updateTabsetPanel(session, "species_tabs", selected = selected_species)
      
      # Pre-fill and trigger search
      updateTextInput(session, paste0(selected_species, "_genename"), 
                      value = global_query_state$current_query)
      shinyjs::delay(100, {
        shinyjs::click(paste0(selected_species, "_search_button"))
      })
    })
    
    # Pre-fill and trigger search
    updateTextInput(session, paste0(selected_species, "_genename"), 
                    value = global_query_state$current_query)
    shinyjs::delay(100, {
      shinyjs::click(paste0(selected_species, "_search_button"))
    })
  })
  
  # Quick action: View in Combined Analysis
  observeEvent(input$explore_combined_view, {
    req(global_query_state$query_result)
    
    # Navigate to combined view
    updateTabsetPanel(session, "nav", selected = "Combined View")
    
    # Pre-fill the search box
    updateTextInput(session, "combined_genename", 
                    value = global_query_state$current_query)
    
    # Trigger the search
    shinyjs::delay(100, {
      shinyjs::click("combined_search_button")
    })
  })
  
  # Quick action: Generate Cross-Species Heatmap
  observeEvent(input$explore_heatmap, {
    req(global_query_state$query_result)
    
    # Navigate to heatmap tab
    updateTabsetPanel(session, "nav", selected = "Cross-Species Heatmap")
    
    # Get all genes from the orthogroup
    all_genes <- c()
    for (sp in names(global_query_state$query_result$genes_by_species)) {
      genes_df <- global_query_state$query_result$genes_by_species[[sp]]
      if (nrow(genes_df) > 0) {
        # Add the first gene from each species
        all_genes <- c(all_genes, genes_df$gene_id[1])
      }
    }
    
    # Pre-fill the gene list
    updateTextAreaInput(session, "ortholog_gene_list", 
                        value = paste(all_genes, collapse = "\n"))
    
    # Trigger heatmap generation
    shinyjs::delay(100, {
      shinyjs::click("generate_ortholog_heatmap")
    })
  })
  
  # Add download handler for ridgeline plots
  output$download_ridgeline <- downloadHandler(
    filename = function() {
      paste("ridgeline_plot_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".png", sep = "")
    },
    content = function(file) {
      species_data_list <- list()
      
      if (input$ridgeline_species == "all") {
        config <- current_species_config()
        species_list <- names(config)
      } else {
        species_list <- c(input$ridgeline_species)
      }
      
      for (species_id in species_list) {
        species_data_list[[species_id]] <- get_species_data(species_id)
      }
      
      p <- if (input$ridgeline_view == "distribution") {
        create_ridgeline_plot(
          species_data_list = species_data_list,
          is_dark_mode = is_dark()
        )
      } else {
        create_threshold_ridgeline(
          species_data_list = species_data_list,
          threshold = input$expression_threshold,
          is_dark_mode = is_dark()
        )
      }
      
      ggsave(file, p, width = 10, height = 8, dpi = 300)
    }
  )
  # File reading helper
  read_data_file <- function(file_path, file_name = "") {
    if (is.null(file_path)) return(NULL)
    
    ext <- tools::file_ext(file_path)
    
    tryCatch({
      if (ext %in% c("tsv", "txt")) {
        data <- read.table(file_path, header = TRUE, sep = "\t", 
                           stringsAsFactors = FALSE, check.names = FALSE)
      } else if (ext == "csv") {
        data <- read.csv(file_path, stringsAsFactors = FALSE, check.names = FALSE)
      } else {
        stop("Unsupported file format")
      }
      return(data)
    }, error = function(e) {
      showNotification(paste("Error reading", file_name, ":", e$message), 
                       type = "error", duration = 5)
      return(NULL)
    })
  }
  
  # Validation function for expression matrix
  validate_expression_matrix <- function(expr_data, species_name) {
    errors <- c()
    warnings <- c()
    
    if (is.null(expr_data)) {
      errors <- c(errors, paste(species_name, ": No expression data provided"))
      return(list(valid = FALSE, errors = errors, warnings = warnings))
    }
    
    # Check if numeric
    if (!all(sapply(expr_data, is.numeric))) {
      errors <- c(errors, paste(species_name, ": Expression matrix must contain only numeric values"))
    }
    
    # Check for row names (gene IDs)
    if (is.null(rownames(expr_data)) || all(rownames(expr_data) == as.character(1:nrow(expr_data)))) {
      warnings <- c(warnings, paste(species_name, ": No gene IDs found in row names, using first column"))
    }
    
    # Check for reasonable values (log2 CPM typically between -5 and 20)
    if (any(expr_data < -10 | expr_data > 30, na.rm = TRUE)) {
      warnings <- c(warnings, paste(species_name, ": Some expression values outside typical log2 CPM range"))
    }
    
    return(list(valid = length(errors) == 0, errors = errors, warnings = warnings))
  }
  
  validate_sample_info <- function(sample_data, species_name, expr_data = NULL) {
    errors <- c()
    warnings <- c()
    
    # Auto-generate sample_info from column names if not provided
    if (is.null(sample_data) && !is.null(expr_data)) {
      # Try to parse column names like T0_R1, T15_R2, etc.
      col_names <- colnames(expr_data)
      if (all(grepl("^T\\d+_R\\d+$", col_names))) {
        # Parse timepoint and replicate from column names
        timepoint_minutes <- as.integer(gsub("^T(\\d+)_R\\d+$", "\\1", col_names))
        replicates <- as.integer(gsub("^T\\d+_R(\\d+)$", "\\1", col_names))
        
        # Convert minutes to appropriate format
        timepoints <- sapply(timepoint_minutes, function(mins) {
          if (mins < 60) {
            return(paste0(mins, "min"))
          } else {
            hours <- mins / 60
            if (hours == floor(hours)) {
              return(paste0(as.integer(hours), "h"))
            } else {
              return(paste0(hours, "h"))
            }
          }
        })
        
        sample_data <- data.frame(
          Sample = col_names,
          Timepoint = timepoints,
          Replicate = replicates,
          stringsAsFactors = FALSE
        )
        
        warnings <- c(warnings, paste(species_name, ": Auto-generated sample info from column names"))
        return(list(valid = TRUE, errors = errors, warnings = warnings, data = sample_data))
      }
    }
    
    if (is.null(sample_data)) {
      errors <- c(errors, paste(species_name, ": No sample info provided"))
      return(list(valid = FALSE, errors = errors, warnings = warnings))
    }
    
    # Check required columns
    required_cols <- c("Sample", "Timepoint", "Replicate")
    missing_cols <- setdiff(required_cols, colnames(sample_data))
    
    if (length(missing_cols) > 0) {
      errors <- c(errors, paste(species_name, ": Missing required columns:", 
                                paste(missing_cols, collapse = ", ")))
    }
    
    # Check sample names match expression matrix columns if provided
    if (!is.null(expr_data) && "Sample" %in% colnames(sample_data)) {
      expr_samples <- colnames(expr_data)
      info_samples <- sample_data$Sample
      
      if (!all(info_samples %in% expr_samples)) {
        errors <- c(errors, paste(species_name, 
                                  ": Sample names in metadata don't match expression matrix columns"))
      }
    }
    
    return(list(valid = length(errors) == 0, errors = errors, warnings = warnings))
  }
  
  # Validation function for annotations
  validate_annotations <- function(anno_data, species_name) {
    errors <- c()
    warnings <- c()
    
    if (is.null(anno_data)) {
      warnings <- c(warnings, paste(species_name, ": No annotation data provided, will use gene IDs only"))
      return(list(valid = TRUE, errors = errors, warnings = warnings))
    }
    
    # Check required columns
    required_cols <- c("GeneID", "GeneName", "Chr")
    missing_cols <- setdiff(required_cols, colnames(anno_data))
    
    if (length(missing_cols) > 0) {
      errors <- c(errors, paste(species_name, ": Missing required annotation columns:", 
                                paste(missing_cols, collapse = ", ")))
    }
    
    return(list(valid = length(errors) == 0, errors = errors, warnings = warnings))
  }
  
  build_gene_lookup <- function(species_data_list, ortho_data = NULL) {
    lookup_entries <- list()
    
    for (species_id in names(species_data_list)) {
      # Skip non-species entries
      if (species_id %in% c("orthofinder", "metadata", "gene_lookup", "phylo_trees")) {
        next
      }
      
      sp_data <- species_data_list[[species_id]]
      
      if (!is.null(sp_data$anno)) {
        gene_ids <- sp_data$anno$GeneID
        gene_names <- sp_data$anno$GeneName
      } else if (!is.null(sp_data$lcpm)) {
        gene_ids <- rownames(sp_data$lcpm)
        gene_names <- rep("", length(gene_ids))
      } else {
        next
      }
      
      for (i in seq_along(gene_ids)) {
        # Create single entry per gene with both ID and name
        entry <- data.frame(
          gene_id = gene_ids[i],
          species = species_id,
          expression_id = gene_ids[i],
          id_type = paste0(toupper(species_id), "GL0"),
          source_info = "original",
          gene_name = if(length(gene_names) >= i && !is.na(gene_names[i])) gene_names[i] else "",
          hog_id = "",
          og_id = "",
          stringsAsFactors = FALSE
        )
        lookup_entries[[length(lookup_entries) + 1]] <- entry
      }
    }
    
    lookup_table <- as.data.frame(rbindlist(lookup_entries, fill = TRUE))
    
    # Add orthology information if provided
    if (!is.null(ortho_data) && "gene_id" %in% colnames(ortho_data)) {
      for (i in 1:nrow(lookup_table)) {
        gene_match <- which(ortho_data$gene_id == lookup_table$gene_id[i])
        if (length(gene_match) > 0) {
          if ("hog_id" %in% colnames(ortho_data)) {
            lookup_table$hog_id[i] <- ortho_data$hog_id[gene_match[1]]
          }
          if ("og_id" %in% colnames(ortho_data)) {
            lookup_table$og_id[i] <- ortho_data$og_id[gene_match[1]]
          }
        }
      }
    }
    
    return(as.data.table(lookup_table))
  }
  
  # Process OrthoFinder output
  process_orthofinder_output <- function(orthogroups_file, hog_file = NULL) {
    ortho_data <- read_data_file(orthogroups_file, "Orthogroups")
    
    if (is.null(ortho_data)) return(NULL)
    
    # Parse OrthoFinder format (wide format with OG in first column)
    og_list <- list()
    
    for (i in 1:nrow(ortho_data)) {
      og_id <- ortho_data[i, 1]
      
      for (j in 2:ncol(ortho_data)) {
        genes <- ortho_data[i, j]
        if (!is.na(genes) && genes != "") {
          # Split multiple genes
          gene_list <- unlist(strsplit(genes, "[, ]+"))
          species <- colnames(ortho_data)[j]
          
          for (gene in gene_list) {
            og_list[[length(og_list) + 1]] <- data.frame(
              gene_id = gene,
              og_id = og_id,
              hog_id = og_id,  # Default HOG to OG if not provided
              species = species,
              stringsAsFactors = FALSE
            )
          }
        }
      }
    }
    
    orthogroups_df <- do.call(rbind, og_list)
    
    # Process HOG file if provided
    if (!is.null(hog_file)) {
      hog_data <- read_data_file(hog_file, "HOG")
      # Process HOG data and update orthogroups_df
      # Implementation depends on HOG file format
    }
    
    return(orthogroups_df)
  }
  
  # Validate uploads observer
  observeEvent(input$validate_uploads, {
    upload_state$validation_errors <- list()
    upload_state$validation_warnings <- list()
    upload_state$uploaded_data <- list()
    
    waiter_show(html = loading_screen)
    
    # Process each user-defined species
    species <- defined_species()
    
    if (length(species) == 0) {
      showNotification("Please define at least one species first", type = "error")
      waiter_hide()
      return()
    }
    
    for (species_id in names(species)) {
      species_info <- species[[species_id]]
      species_name <- species_info$name
      
      # Read files
      expr_file <- input[[paste0("upload_", species_id, "_expr")]]
      sample_file <- input[[paste0("upload_", species_id, "_samples")]]
      anno_file <- input[[paste0("upload_", species_id, "_anno")]]
      
      expr_data <- if (!is.null(expr_file)) read_data_file(expr_file$datapath, paste(species_name, "expression"))
      
      #Process gene IDs before validation
      if (!is.null(expr_data)) {
        # Check if first column is unnamed (empty string) - this happens with row.names CSV export
        if (names(expr_data)[1] == "") {
          # First column is unnamed and contains gene IDs
          rownames(expr_data) <- as.character(expr_data[,1])  # Convert to character first
          expr_data <- expr_data[,-1, drop=FALSE]  # Remove the first column, keep as data frame
        } else if ("GeneID" %in% colnames(expr_data)) {
          rownames(expr_data) <- as.character(expr_data$GeneID)
          expr_data$GeneID <- NULL
        } else if ("gene_id" %in% colnames(expr_data)) {
          rownames(expr_data) <- as.character(expr_data$gene_id)
          expr_data$gene_id <- NULL
        } else if ("Gene" %in% colnames(expr_data)) {
          rownames(expr_data) <- as.character(expr_data$Gene)
          expr_data$Gene <- NULL
        }
      }
      #debug output
      if (!is.null(expr_data) && DEBUG_MODE) {
        debug_print(paste("Species:", species_name))
        debug_print(paste("Columns:", paste(names(expr_data), collapse=", ")))
        debug_print(paste("Column types:", paste(sapply(expr_data, class), collapse=", ")))
        debug_print(paste("First rownames:", paste(head(rownames(expr_data), 3), collapse=", ")))
        debug_print(paste("Dimensions:", nrow(expr_data), "x", ncol(expr_data)))
        debug_print(paste("All numeric?", all(sapply(expr_data, is.numeric))))
      }
      
      # NEW: Process gene IDs before validation
      if (!is.null(expr_data)) {
        # Check for GeneID column and handle it
        if ("GeneID" %in% colnames(expr_data)) {
          rownames(expr_data) <- expr_data$GeneID
          expr_data$GeneID <- NULL
        } else if ("gene_id" %in% colnames(expr_data)) {
          rownames(expr_data) <- expr_data$gene_id
          expr_data$gene_id <- NULL
        } else if ("Gene" %in% colnames(expr_data)) {
          rownames(expr_data) <- expr_data$Gene
          expr_data$Gene <- NULL
        }
      }
      
      sample_data <- if (!is.null(sample_file)) {
        uploaded_sample <- read_data_file(sample_file$datapath, paste(species_name, "samples"))
        
        # If uploaded sample metadata exists, normalize timepoint format if needed
        if (!is.null(uploaded_sample) && "Timepoint" %in% colnames(uploaded_sample)) {
          # Handle various timepoint formats (T60 -> 1h, 60 -> 1h, etc.)
          uploaded_sample$Timepoint <- sapply(uploaded_sample$Timepoint, function(tp) {
            tp_str <- as.character(tp)
            
            # If it's already in correct format (0min, 1h, etc.), keep it
            if (grepl("^\\d+min$|^\\d+(\\.\\d+)?h$", tp_str)) {
              return(tp_str)
            }
            
            # Extract numeric value from T60, 60, 60min, etc.
            numeric_val <- as.numeric(gsub("^T?(\\d+).*", "\\1", tp_str))
            
            if (!is.na(numeric_val)) {
              if (numeric_val < 60) {
                return(paste0(numeric_val, "min"))
              } else {
                hours <- numeric_val / 60
                if (hours == floor(hours)) {
                  return(paste0(as.integer(hours), "h"))
                } else {
                  return(paste0(hours, "h"))
                }
              }
            }
            
            return(tp_str)  # Return as-is if can't parse
          })
        }
        
        uploaded_sample
      } else {
        NULL
      }
      anno_data <- if (!is.null(anno_file)) read_data_file(anno_file$datapath, paste(species_name, "annotations"))
      
      # Validate each component
      expr_valid <- validate_expression_matrix(expr_data, species_name)
      sample_valid <- validate_sample_info(sample_data, species_name, expr_data)
      anno_valid <- validate_annotations(anno_data, species_name)
      
      # Use auto-generated sample data if provided
      if (!is.null(sample_valid$data)) {
        sample_data <- sample_valid$data
      }
      
      # Collect errors and warnings
      upload_state$validation_errors <- c(upload_state$validation_errors, 
                                          expr_valid$errors, sample_valid$errors, anno_valid$errors)
      upload_state$validation_warnings <- c(upload_state$validation_warnings,
                                            expr_valid$warnings, sample_valid$warnings, anno_valid$warnings)
      
      #properly using auto-generated sample_info
      if (expr_valid$valid && sample_valid$valid) {
        # Use auto-generated sample data if validation provided it
        if (!is.null(sample_valid$data)) {
          sample_data <- sample_valid$data
        }
        
        # Ensure expression matrix is properly formatted
        if (!is.null(expr_data)) {
          expr_matrix <- as.matrix(expr_data)
          
          # Handle row names
          if (is.null(rownames(expr_matrix)) || all(rownames(expr_matrix) == as.character(1:nrow(expr_matrix)))) {
            if ("GeneID" %in% colnames(expr_data)) {
              rownames(expr_matrix) <- expr_data$GeneID
              expr_matrix <- expr_matrix[, colnames(expr_matrix) != "GeneID"]
            }
          }
          
          # Store with CONSISTENT naming (no prefixes in main structure)
          upload_state$uploaded_data[[species_id]] <- list(
            lcpm = expr_matrix,
            sample_info = sample_data,  # Now uses the auto-generated data with correct timepoints
            anno = anno_data
          )
          
          # Always add prefixed versions for compatibility (for ALL species)
          upload_state$uploaded_data[[species_id]][[paste0(species_id, "_lcpm")]] <- expr_matrix
          upload_state$uploaded_data[[species_id]][[paste0(species_id, "_sample_info")]] <- sample_data
          upload_state$uploaded_data[[species_id]][[paste0(species_id, "_anno")]] <- anno_data
        }
      }
    }
    
    # Process orthology data
    if (input$orthology_source == "orthofinder" && !is.null(input$upload_orthogroups)) {
      ortho_data <- process_orthofinder_output(
        input$upload_orthogroups$datapath,
        if (!is.null(input$upload_hog)) input$upload_hog$datapath else NULL
      )
      upload_state$uploaded_data$orthofinder <- list(orthogroups = ortho_data)
    } else if (input$orthology_source == "custom" && !is.null(input$upload_custom_ortho)) {
      ortho_data <- read_data_file(input$upload_custom_ortho$datapath, "Custom orthology")
      upload_state$uploaded_data$orthofinder <- list(orthogroups = ortho_data)
    }
    
    # Update validation status
    upload_state$validated <- length(upload_state$validation_errors) == 0
    
    # Enable process button if validated
    if (upload_state$validated) {
      shinyjs::enable("process_uploads")
      showNotification("Validation successful! You can now process the data.", 
                       type = "message", duration = 5)
    } else {
      shinyjs::disable("process_uploads")
      showNotification("Validation failed. Please fix the errors and try again.", 
                       type = "error", duration = 5)
    }
    
    waiter_hide()
  })
  
  # Process uploads observer
  observeEvent(input$process_uploads, {
    req(upload_state$validated)
    
    waiter_show(html = loading_screen)
    
    tryCatch({
      # Build gene lookup table
      gene_lookup <- build_gene_lookup(
        upload_state$uploaded_data,
        if (!is.null(upload_state$uploaded_data$orthofinder)) {
          upload_state$uploaded_data$orthofinder$orthogroups
        } else NULL
      )
      
      # Create custom all_species_data structure
      custom_data <- upload_state$uploaded_data
      custom_data$gene_lookup <- gene_lookup
      
      # Add metadata
      custom_data$metadata <- list(
        source_file = "User uploaded",
        date_parsed = Sys.Date(),
        hog_level = "N0",
        n_hogs = length(unique(gene_lookup$hog_id[gene_lookup$hog_id != ""])),
        n_ogs = length(unique(gene_lookup$og_id[gene_lookup$og_id != ""])),
        n_genes = nrow(gene_lookup),
        species_included = paste(input$upload_species_select, collapse = ", "),
        note = "Custom user data upload"
      )
      
      # Store in upload state
      upload_state$custom_all_species_data <- custom_data
      upload_state$processed <- TRUE
      
      # Switch data source to custom
      data_source("custom")
      
      # Clear species data cache to force reload
      rm(list = ls(species_data_cache), envir = species_data_cache)
      
      showNotification("Data processed successfully! The app is now using your uploaded data.", 
                       type = "success", duration = 5)
      
      # Show success banner
      shinyjs::show("upload_status_banner")
      output$upload_status_content <- renderUI({
        div(
          icon("check-circle"),
          strong("Custom data loaded successfully!"),
          br(),
          paste("Active species:", paste(input$upload_species_select, collapse = ", ")),
          actionButton("dismiss_upload_banner", "Dismiss", 
                       class = "btn btn-sm btn-light float-right")
        )
      })
      
      # Update class for success
      shinyjs::removeClass("upload_status_banner", "alert-warning")
      shinyjs::addClass("upload_status_banner", "alert-success")
      
    }, error = function(e) {
      showNotification(paste("Error processing data:", e$message), 
                       type = "error", duration = NULL)
      upload_state$processed <- FALSE
    })
    
    waiter_hide()
  })
  
  # Reset to default data
  observeEvent(input$reset_to_default, {
    data_source("default")
    upload_state$custom_all_species_data <- NULL
    upload_state$processed <- FALSE
    upload_state$validated <- FALSE
    
    # Clear species data cache
    rm(list = ls(species_data_cache), envir = species_data_cache)
    
    shinyjs::hide("upload_status_banner")
    shinyjs::disable("process_uploads")
    
    showNotification("Reset to demo data successful!", type = "success", duration = 3)
  })
  
  # Dismiss banner
  observeEvent(input$dismiss_upload_banner, {
    shinyjs::hide("upload_status_banner")
  })
  
  # Validation results output
  output$validation_results <- renderUI({
    if (!upload_state$validated && length(upload_state$validation_errors) == 0) {
      return(div(
        class = "text-muted",
        icon("info-circle"),
        " Upload your data files and click 'Validate Data' to begin"
      ))
    }
    
    ui_elements <- list()
    
    # Show errors
    if (length(upload_state$validation_errors) > 0) {
      ui_elements[[length(ui_elements) + 1]] <- div(
        class = "alert alert-danger",
        h5(icon("times-circle"), " Validation Errors"),
        tags$ul(
          lapply(upload_state$validation_errors, function(err) tags$li(err))
        )
      )
    }
    
    # Show warnings
    if (length(upload_state$validation_warnings) > 0) {
      ui_elements[[length(ui_elements) + 1]] <- div(
        class = "alert alert-warning",
        h5(icon("exclamation-triangle"), " Warnings"),
        tags$ul(
          lapply(upload_state$validation_warnings, function(warn) tags$li(warn))
        )
      )
    }
    
    # Show success
    if (upload_state$validated) {
      ui_elements[[length(ui_elements) + 1]] <- div(
        class = "alert alert-success",
        h5(icon("check-circle"), " Validation Successful"),
        p("All required data components are valid. You can now process the data.")
      )
    }
    
    do.call(tagList, ui_elements)
  })
  
  # Preview outputs
  output$upload_expr_preview <- renderDT({
    if (length(upload_state$uploaded_data) > 0) {
      # Show first species with data
      for (sp_id in names(upload_state$uploaded_data)) {
        if (!is.null(upload_state$uploaded_data[[sp_id]]$lcpm)) {
          expr_data <- upload_state$uploaded_data[[sp_id]]$lcpm
          preview <- expr_data[1:min(10, nrow(expr_data)), 1:min(5, ncol(expr_data))]
          return(datatable(preview, options = list(dom = 't', pageLength = 10)))
        }
      }
    }
  })
  
  output$upload_sample_preview <- renderDT({
    if (length(upload_state$uploaded_data) > 0) {
      for (sp_id in names(upload_state$uploaded_data)) {
        if (!is.null(upload_state$uploaded_data[[sp_id]]$sample_info)) {
          return(datatable(upload_state$uploaded_data[[sp_id]]$sample_info, 
                           options = list(dom = 't', pageLength = 10)))
        }
      }
    }
  })
  
  output$upload_anno_preview <- renderDT({
    if (length(upload_state$uploaded_data) > 0) {
      for (sp_id in names(upload_state$uploaded_data)) {
        if (!is.null(upload_state$uploaded_data[[sp_id]]$anno)) {
          preview <- upload_state$uploaded_data[[sp_id]]$anno[1:min(10, nrow(upload_state$uploaded_data[[sp_id]]$anno)), ]
          return(datatable(preview, options = list(dom = 't', pageLength = 10)))
        }
      }
    }
  })
  
  output$upload_ortho_preview <- renderDT({
    if (!is.null(upload_state$uploaded_data$orthofinder)) {
      ortho_data <- upload_state$uploaded_data$orthofinder$orthogroups
      if (!is.null(ortho_data)) {
        preview <- ortho_data[1:min(20, nrow(ortho_data)), ]
        return(datatable(preview, options = list(dom = 't', pageLength = 20)))
      }
    }
  })
  
  # Make processed status available to UI
  output$data_processed <- reactive({
    upload_state$processed
  })
  outputOptions(output, "data_processed", suspendWhenHidden = FALSE)
  
  # Download handlers
  output$download_processed_rdata <- downloadHandler(
    filename = function() {
      paste0("RNAcross_custom_data_", format(Sys.Date(), "%Y%m%d"), ".RData")
    },
    content = function(file) {
      all_species_data <- upload_state$custom_all_species_data
      save(all_species_data, file = file)
    }
  )
  # Dynamic species panels based on current configuration
  output$dynamic_species_panels <- renderUI({
    config <- current_species_config()
    
    # Create tab panels for each species
    tabs <- lapply(names(config), function(id) {
      species <- c(list(id = id), config[[id]])
      tabPanel(
        title = species$name,
        value = id,
        create_species_panel(species)
      )
    })
    
    # Return tabsetPanel with all species
    do.call(tabsetPanel, c(tabs, list(id = "species_tabs")))
  })
  output$download_gene_lookup <- downloadHandler(
    filename = function() {
      paste0("gene_lookup_table_", format(Sys.Date(), "%Y%m%d"), ".csv")
    },
    content = function(file) {
      if (!is.null(upload_state$custom_all_species_data$gene_lookup)) {
        write.csv(upload_state$custom_all_species_data$gene_lookup, file, row.names = FALSE)
      }
    }
  )
  
}

# Run the app
shinyApp(ui = ui, server = server, options = list(height = 1080))
```